
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model accounts
 * 
 */
export type accounts = $Result.DefaultSelection<Prisma.$accountsPayload>
/**
 * Model bookings
 * 
 */
export type bookings = $Result.DefaultSelection<Prisma.$bookingsPayload>
/**
 * Model cancellations
 * 
 */
export type cancellations = $Result.DefaultSelection<Prisma.$cancellationsPayload>
/**
 * Model clients
 * 
 */
export type clients = $Result.DefaultSelection<Prisma.$clientsPayload>
/**
 * Model hotel_policies
 * 
 */
export type hotel_policies = $Result.DefaultSelection<Prisma.$hotel_policiesPayload>
/**
 * Model hotels
 * 
 */
export type hotels = $Result.DefaultSelection<Prisma.$hotelsPayload>
/**
 * Model invoices
 * 
 */
export type invoices = $Result.DefaultSelection<Prisma.$invoicesPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model permissions
 * 
 */
export type permissions = $Result.DefaultSelection<Prisma.$permissionsPayload>
/**
 * Model quotes
 * 
 */
export type quotes = $Result.DefaultSelection<Prisma.$quotesPayload>
/**
 * Model rack_rates
 * 
 */
export type rack_rates = $Result.DefaultSelection<Prisma.$rack_ratesPayload>
/**
 * Model rate_cards
 * 
 */
export type rate_cards = $Result.DefaultSelection<Prisma.$rate_cardsPayload>
/**
 * Model reminders
 * 
 */
export type reminders = $Result.DefaultSelection<Prisma.$remindersPayload>
/**
 * Model seasons
 * 
 */
export type seasons = $Result.DefaultSelection<Prisma.$seasonsPayload>
/**
 * Model sessions
 * 
 */
export type sessions = $Result.DefaultSelection<Prisma.$sessionsPayload>
/**
 * Model transportation
 * 
 */
export type transportation = $Result.DefaultSelection<Prisma.$transportationPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model branches
 * 
 */
export type branches = $Result.DefaultSelection<Prisma.$branchesPayload>
/**
 * Model users_branches
 * 
 */
export type users_branches = $Result.DefaultSelection<Prisma.$users_branchesPayload>
/**
 * Model events_log
 * 
 */
export type events_log = $Result.DefaultSelection<Prisma.$events_logPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const shared_status: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  DELETED: 'DELETED'
};

export type shared_status = (typeof shared_status)[keyof typeof shared_status]


export const transportation_type: {
  AIR: 'AIR',
  SGR: 'SGR',
  SGR_TRANSFER: 'SGR_TRANSFER',
  ROAD: 'ROAD',
  OTHER: 'OTHER'
};

export type transportation_type = (typeof transportation_type)[keyof typeof transportation_type]


export const seasons_period_type: {
  LOW_SEASON: 'LOW_SEASON',
  SHOULDER_SEASON: 'SHOULDER_SEASON',
  HIGH_SEASON: 'HIGH_SEASON',
  PEAK_SEASON: 'PEAK_SEASON'
};

export type seasons_period_type = (typeof seasons_period_type)[keyof typeof seasons_period_type]


export const quotes_status: {
  ACTIVE: 'ACTIVE',
  CONVERTED: 'CONVERTED',
  EXPIRED: 'EXPIRED',
  DELETED: 'DELETED'
};

export type quotes_status = (typeof quotes_status)[keyof typeof quotes_status]


export const rack_rates_travel_period: {
  LOW_SEASON: 'LOW_SEASON',
  SHOULDER_SEASON: 'SHOULDER_SEASON',
  HIGH_SEASON: 'HIGH_SEASON',
  PEAK_SEASON: 'PEAK_SEASON'
};

export type rack_rates_travel_period = (typeof rack_rates_travel_period)[keyof typeof rack_rates_travel_period]


export const payments_payment_method: {
  CASH: 'CASH',
  CREDIT_CARD: 'CREDIT_CARD',
  BANK_TRANSFER: 'BANK_TRANSFER',
  MOBILE_MONEY: 'MOBILE_MONEY',
  CHEQUE: 'CHEQUE'
};

export type payments_payment_method = (typeof payments_payment_method)[keyof typeof payments_payment_method]


export const rack_rates_meal_plan: {
  ROOM_ONLY: 'ROOM_ONLY',
  BED_AND_BREAKFAST: 'BED_AND_BREAKFAST',
  HALF_BOARD: 'HALF_BOARD',
  FULL_BOARD: 'FULL_BOARD',
  ALL_INCLUSIVE: 'ALL_INCLUSIVE'
};

export type rack_rates_meal_plan = (typeof rack_rates_meal_plan)[keyof typeof rack_rates_meal_plan]


export const rack_rates_room_category: {
  STANDARD: 'STANDARD',
  DELUXE: 'DELUXE',
  SUITE: 'SUITE',
  EXECUTIVE: 'EXECUTIVE',
  PRESIDENTIAL: 'PRESIDENTIAL'
};

export type rack_rates_room_category = (typeof rack_rates_room_category)[keyof typeof rack_rates_room_category]


export const notifications_type: {
  PAYMENT_REMINDER: 'PAYMENT_REMINDER',
  BOOKING_CONFIRMATION: 'BOOKING_CONFIRMATION',
  INVOICE_GENERATED: 'INVOICE_GENERATED',
  CANCELLATION: 'CANCELLATION',
  SYSTEM_ALERT: 'SYSTEM_ALERT'
};

export type notifications_type = (typeof notifications_type)[keyof typeof notifications_type]


export const bookings_meal_plan: {
  ROOM_ONLY: 'ROOM_ONLY',
  BED_AND_BREAKFAST: 'BED_AND_BREAKFAST',
  HALF_BOARD: 'HALF_BOARD',
  FULL_BOARD: 'FULL_BOARD',
  ALL_INCLUSIVE: 'ALL_INCLUSIVE'
};

export type bookings_meal_plan = (typeof bookings_meal_plan)[keyof typeof bookings_meal_plan]


export const users_role: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  AGENT: 'AGENT',
  ACCOUNTANT: 'ACCOUNTANT'
};

export type users_role = (typeof users_role)[keyof typeof users_role]


export const bookings_room_category: {
  STANDARD: 'STANDARD',
  DELUXE: 'DELUXE',
  SUITE: 'SUITE',
  EXECUTIVE: 'EXECUTIVE',
  PRESIDENTIAL: 'PRESIDENTIAL'
};

export type bookings_room_category = (typeof bookings_room_category)[keyof typeof bookings_room_category]


export const invoices_status: {
  UNPAID: 'UNPAID',
  PARTIALLY_PAID: 'PARTIALLY_PAID',
  PAID: 'PAID',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED',
  DELETED: 'DELETED'
};

export type invoices_status = (typeof invoices_status)[keyof typeof invoices_status]


export const bookings_status: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED',
  DELETED: 'DELETED'
};

export type bookings_status = (typeof bookings_status)[keyof typeof bookings_status]


export const rate_cards_travel_period: {
  LOW_SEASON: 'LOW_SEASON',
  SHOULDER_SEASON: 'SHOULDER_SEASON',
  HIGH_SEASON: 'HIGH_SEASON',
  PEAK_SEASON: 'PEAK_SEASON'
};

export type rate_cards_travel_period = (typeof rate_cards_travel_period)[keyof typeof rate_cards_travel_period]


export const rate_cards_meal_plan: {
  ROOM_ONLY: 'ROOM_ONLY',
  BED_AND_BREAKFAST: 'BED_AND_BREAKFAST',
  HALF_BOARD: 'HALF_BOARD',
  FULL_BOARD: 'FULL_BOARD',
  ALL_INCLUSIVE: 'ALL_INCLUSIVE'
};

export type rate_cards_meal_plan = (typeof rate_cards_meal_plan)[keyof typeof rate_cards_meal_plan]


export const transportation_status: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED',
  DELETED: 'DELETED'
};

export type transportation_status = (typeof transportation_status)[keyof typeof transportation_status]


export const rate_cards_room_category: {
  STANDARD: 'STANDARD',
  DELUXE: 'DELUXE',
  SUITE: 'SUITE',
  EXECUTIVE: 'EXECUTIVE',
  PRESIDENTIAL: 'PRESIDENTIAL'
};

export type rate_cards_room_category = (typeof rate_cards_room_category)[keyof typeof rate_cards_room_category]


export const users_status: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED',
  SUSPENDED: 'SUSPENDED',
  DELETED: 'DELETED'
};

export type users_status = (typeof users_status)[keyof typeof users_status]

}

export type shared_status = $Enums.shared_status

export const shared_status: typeof $Enums.shared_status

export type transportation_type = $Enums.transportation_type

export const transportation_type: typeof $Enums.transportation_type

export type seasons_period_type = $Enums.seasons_period_type

export const seasons_period_type: typeof $Enums.seasons_period_type

export type quotes_status = $Enums.quotes_status

export const quotes_status: typeof $Enums.quotes_status

export type rack_rates_travel_period = $Enums.rack_rates_travel_period

export const rack_rates_travel_period: typeof $Enums.rack_rates_travel_period

export type payments_payment_method = $Enums.payments_payment_method

export const payments_payment_method: typeof $Enums.payments_payment_method

export type rack_rates_meal_plan = $Enums.rack_rates_meal_plan

export const rack_rates_meal_plan: typeof $Enums.rack_rates_meal_plan

export type rack_rates_room_category = $Enums.rack_rates_room_category

export const rack_rates_room_category: typeof $Enums.rack_rates_room_category

export type notifications_type = $Enums.notifications_type

export const notifications_type: typeof $Enums.notifications_type

export type bookings_meal_plan = $Enums.bookings_meal_plan

export const bookings_meal_plan: typeof $Enums.bookings_meal_plan

export type users_role = $Enums.users_role

export const users_role: typeof $Enums.users_role

export type bookings_room_category = $Enums.bookings_room_category

export const bookings_room_category: typeof $Enums.bookings_room_category

export type invoices_status = $Enums.invoices_status

export const invoices_status: typeof $Enums.invoices_status

export type bookings_status = $Enums.bookings_status

export const bookings_status: typeof $Enums.bookings_status

export type rate_cards_travel_period = $Enums.rate_cards_travel_period

export const rate_cards_travel_period: typeof $Enums.rate_cards_travel_period

export type rate_cards_meal_plan = $Enums.rate_cards_meal_plan

export const rate_cards_meal_plan: typeof $Enums.rate_cards_meal_plan

export type transportation_status = $Enums.transportation_status

export const transportation_status: typeof $Enums.transportation_status

export type rate_cards_room_category = $Enums.rate_cards_room_category

export const rate_cards_room_category: typeof $Enums.rate_cards_room_category

export type users_status = $Enums.users_status

export const users_status: typeof $Enums.users_status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.accounts.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.accounts.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.accounts`: Exposes CRUD operations for the **accounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.accounts.findMany()
    * ```
    */
  get accounts(): Prisma.accountsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookings`: Exposes CRUD operations for the **bookings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.bookings.findMany()
    * ```
    */
  get bookings(): Prisma.bookingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cancellations`: Exposes CRUD operations for the **cancellations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cancellations
    * const cancellations = await prisma.cancellations.findMany()
    * ```
    */
  get cancellations(): Prisma.cancellationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clients`: Exposes CRUD operations for the **clients** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.clients.findMany()
    * ```
    */
  get clients(): Prisma.clientsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotel_policies`: Exposes CRUD operations for the **hotel_policies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hotel_policies
    * const hotel_policies = await prisma.hotel_policies.findMany()
    * ```
    */
  get hotel_policies(): Prisma.hotel_policiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.hotels`: Exposes CRUD operations for the **hotels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hotels
    * const hotels = await prisma.hotels.findMany()
    * ```
    */
  get hotels(): Prisma.hotelsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoices`: Exposes CRUD operations for the **invoices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoices.findMany()
    * ```
    */
  get invoices(): Prisma.invoicesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permissions`: Exposes CRUD operations for the **permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permissions.findMany()
    * ```
    */
  get permissions(): Prisma.permissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quotes`: Exposes CRUD operations for the **quotes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quotes
    * const quotes = await prisma.quotes.findMany()
    * ```
    */
  get quotes(): Prisma.quotesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rack_rates`: Exposes CRUD operations for the **rack_rates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rack_rates
    * const rack_rates = await prisma.rack_rates.findMany()
    * ```
    */
  get rack_rates(): Prisma.rack_ratesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rate_cards`: Exposes CRUD operations for the **rate_cards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rate_cards
    * const rate_cards = await prisma.rate_cards.findMany()
    * ```
    */
  get rate_cards(): Prisma.rate_cardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reminders`: Exposes CRUD operations for the **reminders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reminders
    * const reminders = await prisma.reminders.findMany()
    * ```
    */
  get reminders(): Prisma.remindersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seasons`: Exposes CRUD operations for the **seasons** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seasons
    * const seasons = await prisma.seasons.findMany()
    * ```
    */
  get seasons(): Prisma.seasonsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transportation`: Exposes CRUD operations for the **transportation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transportation
    * const transportation = await prisma.transportation.findMany()
    * ```
    */
  get transportation(): Prisma.transportationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.branches`: Exposes CRUD operations for the **branches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branches.findMany()
    * ```
    */
  get branches(): Prisma.branchesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users_branches`: Exposes CRUD operations for the **users_branches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users_branches
    * const users_branches = await prisma.users_branches.findMany()
    * ```
    */
  get users_branches(): Prisma.users_branchesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.events_log`: Exposes CRUD operations for the **events_log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events_logs
    * const events_logs = await prisma.events_log.findMany()
    * ```
    */
  get events_log(): Prisma.events_logDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    accounts: 'accounts',
    bookings: 'bookings',
    cancellations: 'cancellations',
    clients: 'clients',
    hotel_policies: 'hotel_policies',
    hotels: 'hotels',
    invoices: 'invoices',
    notifications: 'notifications',
    payments: 'payments',
    permissions: 'permissions',
    quotes: 'quotes',
    rack_rates: 'rack_rates',
    rate_cards: 'rate_cards',
    reminders: 'reminders',
    seasons: 'seasons',
    sessions: 'sessions',
    transportation: 'transportation',
    users: 'users',
    branches: 'branches',
    users_branches: 'users_branches',
    events_log: 'events_log'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "accounts" | "bookings" | "cancellations" | "clients" | "hotel_policies" | "hotels" | "invoices" | "notifications" | "payments" | "permissions" | "quotes" | "rack_rates" | "rate_cards" | "reminders" | "seasons" | "sessions" | "transportation" | "users" | "branches" | "users_branches" | "events_log"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      accounts: {
        payload: Prisma.$accountsPayload<ExtArgs>
        fields: Prisma.accountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.accountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.accountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          findFirst: {
            args: Prisma.accountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.accountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          findMany: {
            args: Prisma.accountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>[]
          }
          create: {
            args: Prisma.accountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          createMany: {
            args: Prisma.accountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.accountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          update: {
            args: Prisma.accountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          deleteMany: {
            args: Prisma.accountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.accountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.accountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$accountsPayload>
          }
          aggregate: {
            args: Prisma.AccountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccounts>
          }
          groupBy: {
            args: Prisma.accountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.accountsCountArgs<ExtArgs>
            result: $Utils.Optional<AccountsCountAggregateOutputType> | number
          }
        }
      }
      bookings: {
        payload: Prisma.$bookingsPayload<ExtArgs>
        fields: Prisma.bookingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bookingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bookingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          findFirst: {
            args: Prisma.bookingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bookingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          findMany: {
            args: Prisma.bookingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>[]
          }
          create: {
            args: Prisma.bookingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          createMany: {
            args: Prisma.bookingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bookingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          update: {
            args: Prisma.bookingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          deleteMany: {
            args: Prisma.bookingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bookingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bookingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bookingsPayload>
          }
          aggregate: {
            args: Prisma.BookingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookings>
          }
          groupBy: {
            args: Prisma.bookingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.bookingsCountArgs<ExtArgs>
            result: $Utils.Optional<BookingsCountAggregateOutputType> | number
          }
        }
      }
      cancellations: {
        payload: Prisma.$cancellationsPayload<ExtArgs>
        fields: Prisma.cancellationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cancellationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cancellationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cancellationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cancellationsPayload>
          }
          findFirst: {
            args: Prisma.cancellationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cancellationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cancellationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cancellationsPayload>
          }
          findMany: {
            args: Prisma.cancellationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cancellationsPayload>[]
          }
          create: {
            args: Prisma.cancellationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cancellationsPayload>
          }
          createMany: {
            args: Prisma.cancellationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cancellationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cancellationsPayload>
          }
          update: {
            args: Prisma.cancellationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cancellationsPayload>
          }
          deleteMany: {
            args: Prisma.cancellationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cancellationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cancellationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cancellationsPayload>
          }
          aggregate: {
            args: Prisma.CancellationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCancellations>
          }
          groupBy: {
            args: Prisma.cancellationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CancellationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.cancellationsCountArgs<ExtArgs>
            result: $Utils.Optional<CancellationsCountAggregateOutputType> | number
          }
        }
      }
      clients: {
        payload: Prisma.$clientsPayload<ExtArgs>
        fields: Prisma.clientsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clientsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clientsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          findFirst: {
            args: Prisma.clientsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clientsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          findMany: {
            args: Prisma.clientsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>[]
          }
          create: {
            args: Prisma.clientsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          createMany: {
            args: Prisma.clientsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.clientsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          update: {
            args: Prisma.clientsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          deleteMany: {
            args: Prisma.clientsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clientsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.clientsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clientsPayload>
          }
          aggregate: {
            args: Prisma.ClientsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClients>
          }
          groupBy: {
            args: Prisma.clientsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientsGroupByOutputType>[]
          }
          count: {
            args: Prisma.clientsCountArgs<ExtArgs>
            result: $Utils.Optional<ClientsCountAggregateOutputType> | number
          }
        }
      }
      hotel_policies: {
        payload: Prisma.$hotel_policiesPayload<ExtArgs>
        fields: Prisma.hotel_policiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hotel_policiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotel_policiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hotel_policiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotel_policiesPayload>
          }
          findFirst: {
            args: Prisma.hotel_policiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotel_policiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hotel_policiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotel_policiesPayload>
          }
          findMany: {
            args: Prisma.hotel_policiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotel_policiesPayload>[]
          }
          create: {
            args: Prisma.hotel_policiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotel_policiesPayload>
          }
          createMany: {
            args: Prisma.hotel_policiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hotel_policiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotel_policiesPayload>
          }
          update: {
            args: Prisma.hotel_policiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotel_policiesPayload>
          }
          deleteMany: {
            args: Prisma.hotel_policiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hotel_policiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hotel_policiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotel_policiesPayload>
          }
          aggregate: {
            args: Prisma.Hotel_policiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotel_policies>
          }
          groupBy: {
            args: Prisma.hotel_policiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Hotel_policiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.hotel_policiesCountArgs<ExtArgs>
            result: $Utils.Optional<Hotel_policiesCountAggregateOutputType> | number
          }
        }
      }
      hotels: {
        payload: Prisma.$hotelsPayload<ExtArgs>
        fields: Prisma.hotelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hotelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hotelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotelsPayload>
          }
          findFirst: {
            args: Prisma.hotelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hotelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotelsPayload>
          }
          findMany: {
            args: Prisma.hotelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotelsPayload>[]
          }
          create: {
            args: Prisma.hotelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotelsPayload>
          }
          createMany: {
            args: Prisma.hotelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.hotelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotelsPayload>
          }
          update: {
            args: Prisma.hotelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotelsPayload>
          }
          deleteMany: {
            args: Prisma.hotelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.hotelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.hotelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$hotelsPayload>
          }
          aggregate: {
            args: Prisma.HotelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotels>
          }
          groupBy: {
            args: Prisma.hotelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.hotelsCountArgs<ExtArgs>
            result: $Utils.Optional<HotelsCountAggregateOutputType> | number
          }
        }
      }
      invoices: {
        payload: Prisma.$invoicesPayload<ExtArgs>
        fields: Prisma.invoicesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invoicesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invoicesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          findFirst: {
            args: Prisma.invoicesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invoicesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          findMany: {
            args: Prisma.invoicesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>[]
          }
          create: {
            args: Prisma.invoicesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          createMany: {
            args: Prisma.invoicesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.invoicesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          update: {
            args: Prisma.invoicesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          deleteMany: {
            args: Prisma.invoicesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invoicesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.invoicesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invoicesPayload>
          }
          aggregate: {
            args: Prisma.InvoicesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoices>
          }
          groupBy: {
            args: Prisma.invoicesGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoicesGroupByOutputType>[]
          }
          count: {
            args: Prisma.invoicesCountArgs<ExtArgs>
            result: $Utils.Optional<InvoicesCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      permissions: {
        payload: Prisma.$permissionsPayload<ExtArgs>
        fields: Prisma.permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          findFirst: {
            args: Prisma.permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          findMany: {
            args: Prisma.permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>[]
          }
          create: {
            args: Prisma.permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          createMany: {
            args: Prisma.permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          update: {
            args: Prisma.permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          deleteMany: {
            args: Prisma.permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          aggregate: {
            args: Prisma.PermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissions>
          }
          groupBy: {
            args: Prisma.permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionsCountAggregateOutputType> | number
          }
        }
      }
      quotes: {
        payload: Prisma.$quotesPayload<ExtArgs>
        fields: Prisma.quotesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.quotesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.quotesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotesPayload>
          }
          findFirst: {
            args: Prisma.quotesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.quotesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotesPayload>
          }
          findMany: {
            args: Prisma.quotesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotesPayload>[]
          }
          create: {
            args: Prisma.quotesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotesPayload>
          }
          createMany: {
            args: Prisma.quotesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.quotesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotesPayload>
          }
          update: {
            args: Prisma.quotesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotesPayload>
          }
          deleteMany: {
            args: Prisma.quotesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.quotesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.quotesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quotesPayload>
          }
          aggregate: {
            args: Prisma.QuotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuotes>
          }
          groupBy: {
            args: Prisma.quotesGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.quotesCountArgs<ExtArgs>
            result: $Utils.Optional<QuotesCountAggregateOutputType> | number
          }
        }
      }
      rack_rates: {
        payload: Prisma.$rack_ratesPayload<ExtArgs>
        fields: Prisma.rack_ratesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rack_ratesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rack_ratesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rack_ratesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rack_ratesPayload>
          }
          findFirst: {
            args: Prisma.rack_ratesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rack_ratesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rack_ratesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rack_ratesPayload>
          }
          findMany: {
            args: Prisma.rack_ratesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rack_ratesPayload>[]
          }
          create: {
            args: Prisma.rack_ratesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rack_ratesPayload>
          }
          createMany: {
            args: Prisma.rack_ratesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rack_ratesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rack_ratesPayload>
          }
          update: {
            args: Prisma.rack_ratesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rack_ratesPayload>
          }
          deleteMany: {
            args: Prisma.rack_ratesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rack_ratesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rack_ratesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rack_ratesPayload>
          }
          aggregate: {
            args: Prisma.Rack_ratesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRack_rates>
          }
          groupBy: {
            args: Prisma.rack_ratesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Rack_ratesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rack_ratesCountArgs<ExtArgs>
            result: $Utils.Optional<Rack_ratesCountAggregateOutputType> | number
          }
        }
      }
      rate_cards: {
        payload: Prisma.$rate_cardsPayload<ExtArgs>
        fields: Prisma.rate_cardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rate_cardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rate_cardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rate_cardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rate_cardsPayload>
          }
          findFirst: {
            args: Prisma.rate_cardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rate_cardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rate_cardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rate_cardsPayload>
          }
          findMany: {
            args: Prisma.rate_cardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rate_cardsPayload>[]
          }
          create: {
            args: Prisma.rate_cardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rate_cardsPayload>
          }
          createMany: {
            args: Prisma.rate_cardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rate_cardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rate_cardsPayload>
          }
          update: {
            args: Prisma.rate_cardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rate_cardsPayload>
          }
          deleteMany: {
            args: Prisma.rate_cardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rate_cardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rate_cardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rate_cardsPayload>
          }
          aggregate: {
            args: Prisma.Rate_cardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRate_cards>
          }
          groupBy: {
            args: Prisma.rate_cardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Rate_cardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.rate_cardsCountArgs<ExtArgs>
            result: $Utils.Optional<Rate_cardsCountAggregateOutputType> | number
          }
        }
      }
      reminders: {
        payload: Prisma.$remindersPayload<ExtArgs>
        fields: Prisma.remindersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.remindersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$remindersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.remindersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$remindersPayload>
          }
          findFirst: {
            args: Prisma.remindersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$remindersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.remindersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$remindersPayload>
          }
          findMany: {
            args: Prisma.remindersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$remindersPayload>[]
          }
          create: {
            args: Prisma.remindersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$remindersPayload>
          }
          createMany: {
            args: Prisma.remindersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.remindersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$remindersPayload>
          }
          update: {
            args: Prisma.remindersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$remindersPayload>
          }
          deleteMany: {
            args: Prisma.remindersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.remindersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.remindersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$remindersPayload>
          }
          aggregate: {
            args: Prisma.RemindersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReminders>
          }
          groupBy: {
            args: Prisma.remindersGroupByArgs<ExtArgs>
            result: $Utils.Optional<RemindersGroupByOutputType>[]
          }
          count: {
            args: Prisma.remindersCountArgs<ExtArgs>
            result: $Utils.Optional<RemindersCountAggregateOutputType> | number
          }
        }
      }
      seasons: {
        payload: Prisma.$seasonsPayload<ExtArgs>
        fields: Prisma.seasonsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.seasonsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.seasonsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>
          }
          findFirst: {
            args: Prisma.seasonsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.seasonsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>
          }
          findMany: {
            args: Prisma.seasonsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>[]
          }
          create: {
            args: Prisma.seasonsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>
          }
          createMany: {
            args: Prisma.seasonsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.seasonsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>
          }
          update: {
            args: Prisma.seasonsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>
          }
          deleteMany: {
            args: Prisma.seasonsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.seasonsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.seasonsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seasonsPayload>
          }
          aggregate: {
            args: Prisma.SeasonsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeasons>
          }
          groupBy: {
            args: Prisma.seasonsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeasonsGroupByOutputType>[]
          }
          count: {
            args: Prisma.seasonsCountArgs<ExtArgs>
            result: $Utils.Optional<SeasonsCountAggregateOutputType> | number
          }
        }
      }
      sessions: {
        payload: Prisma.$sessionsPayload<ExtArgs>
        fields: Prisma.sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findFirst: {
            args: Prisma.sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findMany: {
            args: Prisma.sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          create: {
            args: Prisma.sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          createMany: {
            args: Prisma.sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          update: {
            args: Prisma.sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          deleteMany: {
            args: Prisma.sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
      transportation: {
        payload: Prisma.$transportationPayload<ExtArgs>
        fields: Prisma.transportationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transportationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transportationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transportationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transportationPayload>
          }
          findFirst: {
            args: Prisma.transportationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transportationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transportationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transportationPayload>
          }
          findMany: {
            args: Prisma.transportationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transportationPayload>[]
          }
          create: {
            args: Prisma.transportationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transportationPayload>
          }
          createMany: {
            args: Prisma.transportationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.transportationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transportationPayload>
          }
          update: {
            args: Prisma.transportationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transportationPayload>
          }
          deleteMany: {
            args: Prisma.transportationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transportationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transportationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transportationPayload>
          }
          aggregate: {
            args: Prisma.TransportationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransportation>
          }
          groupBy: {
            args: Prisma.transportationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransportationGroupByOutputType>[]
          }
          count: {
            args: Prisma.transportationCountArgs<ExtArgs>
            result: $Utils.Optional<TransportationCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      branches: {
        payload: Prisma.$branchesPayload<ExtArgs>
        fields: Prisma.branchesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.branchesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.branchesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          findFirst: {
            args: Prisma.branchesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.branchesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          findMany: {
            args: Prisma.branchesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>[]
          }
          create: {
            args: Prisma.branchesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          createMany: {
            args: Prisma.branchesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.branchesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          update: {
            args: Prisma.branchesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          deleteMany: {
            args: Prisma.branchesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.branchesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.branchesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$branchesPayload>
          }
          aggregate: {
            args: Prisma.BranchesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranches>
          }
          groupBy: {
            args: Prisma.branchesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchesGroupByOutputType>[]
          }
          count: {
            args: Prisma.branchesCountArgs<ExtArgs>
            result: $Utils.Optional<BranchesCountAggregateOutputType> | number
          }
        }
      }
      users_branches: {
        payload: Prisma.$users_branchesPayload<ExtArgs>
        fields: Prisma.users_branchesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.users_branchesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_branchesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.users_branchesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_branchesPayload>
          }
          findFirst: {
            args: Prisma.users_branchesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_branchesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.users_branchesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_branchesPayload>
          }
          findMany: {
            args: Prisma.users_branchesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_branchesPayload>[]
          }
          create: {
            args: Prisma.users_branchesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_branchesPayload>
          }
          createMany: {
            args: Prisma.users_branchesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.users_branchesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_branchesPayload>
          }
          update: {
            args: Prisma.users_branchesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_branchesPayload>
          }
          deleteMany: {
            args: Prisma.users_branchesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.users_branchesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.users_branchesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$users_branchesPayload>
          }
          aggregate: {
            args: Prisma.Users_branchesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers_branches>
          }
          groupBy: {
            args: Prisma.users_branchesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Users_branchesGroupByOutputType>[]
          }
          count: {
            args: Prisma.users_branchesCountArgs<ExtArgs>
            result: $Utils.Optional<Users_branchesCountAggregateOutputType> | number
          }
        }
      }
      events_log: {
        payload: Prisma.$events_logPayload<ExtArgs>
        fields: Prisma.events_logFieldRefs
        operations: {
          findUnique: {
            args: Prisma.events_logFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$events_logPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.events_logFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$events_logPayload>
          }
          findFirst: {
            args: Prisma.events_logFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$events_logPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.events_logFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$events_logPayload>
          }
          findMany: {
            args: Prisma.events_logFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$events_logPayload>[]
          }
          create: {
            args: Prisma.events_logCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$events_logPayload>
          }
          createMany: {
            args: Prisma.events_logCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.events_logDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$events_logPayload>
          }
          update: {
            args: Prisma.events_logUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$events_logPayload>
          }
          deleteMany: {
            args: Prisma.events_logDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.events_logUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.events_logUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$events_logPayload>
          }
          aggregate: {
            args: Prisma.Events_logAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvents_log>
          }
          groupBy: {
            args: Prisma.events_logGroupByArgs<ExtArgs>
            result: $Utils.Optional<Events_logGroupByOutputType>[]
          }
          count: {
            args: Prisma.events_logCountArgs<ExtArgs>
            result: $Utils.Optional<Events_logCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    accounts?: accountsOmit
    bookings?: bookingsOmit
    cancellations?: cancellationsOmit
    clients?: clientsOmit
    hotel_policies?: hotel_policiesOmit
    hotels?: hotelsOmit
    invoices?: invoicesOmit
    notifications?: notificationsOmit
    payments?: paymentsOmit
    permissions?: permissionsOmit
    quotes?: quotesOmit
    rack_rates?: rack_ratesOmit
    rate_cards?: rate_cardsOmit
    reminders?: remindersOmit
    seasons?: seasonsOmit
    sessions?: sessionsOmit
    transportation?: transportationOmit
    users?: usersOmit
    branches?: branchesOmit
    users_branches?: users_branchesOmit
    events_log?: events_logOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BookingsCountOutputType
   */

  export type BookingsCountOutputType = {
    cancellations: number
    transportation: number
    payments: number
  }

  export type BookingsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cancellations?: boolean | BookingsCountOutputTypeCountCancellationsArgs
    transportation?: boolean | BookingsCountOutputTypeCountTransportationArgs
    payments?: boolean | BookingsCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * BookingsCountOutputType without action
   */
  export type BookingsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingsCountOutputType
     */
    select?: BookingsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingsCountOutputType without action
   */
  export type BookingsCountOutputTypeCountCancellationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cancellationsWhereInput
  }

  /**
   * BookingsCountOutputType without action
   */
  export type BookingsCountOutputTypeCountTransportationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transportationWhereInput
  }

  /**
   * BookingsCountOutputType without action
   */
  export type BookingsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }


  /**
   * Count Type ClientsCountOutputType
   */

  export type ClientsCountOutputType = {
    bookings: number
    invoices: number
    quotes: number
  }

  export type ClientsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ClientsCountOutputTypeCountBookingsArgs
    invoices?: boolean | ClientsCountOutputTypeCountInvoicesArgs
    quotes?: boolean | ClientsCountOutputTypeCountQuotesArgs
  }

  // Custom InputTypes
  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientsCountOutputType
     */
    select?: ClientsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingsWhereInput
  }

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoicesWhereInput
  }

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quotesWhereInput
  }


  /**
   * Count Type Hotel_policiesCountOutputType
   */

  export type Hotel_policiesCountOutputType = {
    seasons: number
  }

  export type Hotel_policiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seasons?: boolean | Hotel_policiesCountOutputTypeCountSeasonsArgs
  }

  // Custom InputTypes
  /**
   * Hotel_policiesCountOutputType without action
   */
  export type Hotel_policiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel_policiesCountOutputType
     */
    select?: Hotel_policiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Hotel_policiesCountOutputType without action
   */
  export type Hotel_policiesCountOutputTypeCountSeasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: seasonsWhereInput
  }


  /**
   * Count Type HotelsCountOutputType
   */

  export type HotelsCountOutputType = {
    bookings: number
    hotel_policies: number
    rack_rates: number
    rate_cards: number
  }

  export type HotelsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | HotelsCountOutputTypeCountBookingsArgs
    hotel_policies?: boolean | HotelsCountOutputTypeCountHotel_policiesArgs
    rack_rates?: boolean | HotelsCountOutputTypeCountRack_ratesArgs
    rate_cards?: boolean | HotelsCountOutputTypeCountRate_cardsArgs
  }

  // Custom InputTypes
  /**
   * HotelsCountOutputType without action
   */
  export type HotelsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelsCountOutputType
     */
    select?: HotelsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelsCountOutputType without action
   */
  export type HotelsCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingsWhereInput
  }

  /**
   * HotelsCountOutputType without action
   */
  export type HotelsCountOutputTypeCountHotel_policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hotel_policiesWhereInput
  }

  /**
   * HotelsCountOutputType without action
   */
  export type HotelsCountOutputTypeCountRack_ratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rack_ratesWhereInput
  }

  /**
   * HotelsCountOutputType without action
   */
  export type HotelsCountOutputTypeCountRate_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rate_cardsWhereInput
  }


  /**
   * Count Type InvoicesCountOutputType
   */

  export type InvoicesCountOutputType = {
    payments: number
    reminders: number
    users: number
  }

  export type InvoicesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | InvoicesCountOutputTypeCountPaymentsArgs
    reminders?: boolean | InvoicesCountOutputTypeCountRemindersArgs
    users?: boolean | InvoicesCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicesCountOutputType
     */
    select?: InvoicesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeCountRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: remindersWhereInput
  }

  /**
   * InvoicesCountOutputType without action
   */
  export type InvoicesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type PaymentsCountOutputType
   */

  export type PaymentsCountOutputType = {
    bookings: number
  }

  export type PaymentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | PaymentsCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * PaymentsCountOutputType without action
   */
  export type PaymentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentsCountOutputType
     */
    select?: PaymentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentsCountOutputType without action
   */
  export type PaymentsCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingsWhereInput
  }


  /**
   * Count Type Rack_ratesCountOutputType
   */

  export type Rack_ratesCountOutputType = {
    rate_cards: number
  }

  export type Rack_ratesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rate_cards?: boolean | Rack_ratesCountOutputTypeCountRate_cardsArgs
  }

  // Custom InputTypes
  /**
   * Rack_ratesCountOutputType without action
   */
  export type Rack_ratesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rack_ratesCountOutputType
     */
    select?: Rack_ratesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Rack_ratesCountOutputType without action
   */
  export type Rack_ratesCountOutputTypeCountRate_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rate_cardsWhereInput
  }


  /**
   * Count Type Rate_cardsCountOutputType
   */

  export type Rate_cardsCountOutputType = {
    quotes: number
  }

  export type Rate_cardsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotes?: boolean | Rate_cardsCountOutputTypeCountQuotesArgs
  }

  // Custom InputTypes
  /**
   * Rate_cardsCountOutputType without action
   */
  export type Rate_cardsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rate_cardsCountOutputType
     */
    select?: Rate_cardsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Rate_cardsCountOutputType without action
   */
  export type Rate_cardsCountOutputTypeCountQuotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quotesWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    accounts: number
    bookings: number
    cancellations: number
    events: number
    notifications: number
    rate_cards: number
    sessions: number
    users_branches: number
    invoices: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UsersCountOutputTypeCountAccountsArgs
    bookings?: boolean | UsersCountOutputTypeCountBookingsArgs
    cancellations?: boolean | UsersCountOutputTypeCountCancellationsArgs
    events?: boolean | UsersCountOutputTypeCountEventsArgs
    notifications?: boolean | UsersCountOutputTypeCountNotificationsArgs
    rate_cards?: boolean | UsersCountOutputTypeCountRate_cardsArgs
    sessions?: boolean | UsersCountOutputTypeCountSessionsArgs
    users_branches?: boolean | UsersCountOutputTypeCountUsers_branchesArgs
    invoices?: boolean | UsersCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCancellationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cancellationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: events_logWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRate_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rate_cardsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUsers_branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: users_branchesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoicesWhereInput
  }


  /**
   * Count Type BranchesCountOutputType
   */

  export type BranchesCountOutputType = {
    clients: number
    users: number
    users_branches: number
  }

  export type BranchesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | BranchesCountOutputTypeCountClientsArgs
    users?: boolean | BranchesCountOutputTypeCountUsersArgs
    users_branches?: boolean | BranchesCountOutputTypeCountUsers_branchesArgs
  }

  // Custom InputTypes
  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchesCountOutputType
     */
    select?: BranchesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientsWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }

  /**
   * BranchesCountOutputType without action
   */
  export type BranchesCountOutputTypeCountUsers_branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: users_branchesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model accounts
   */

  export type AggregateAccounts = {
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  export type AccountsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    expires_at: number | null
  }

  export type AccountsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    expires_at: number | null
  }

  export type AccountsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    provider: string | null
    provider_account_id: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type AccountsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    provider: string | null
    provider_account_id: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type AccountsCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    provider_account_id: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type AccountsAvgAggregateInputType = {
    id?: true
    userId?: true
    expires_at?: true
  }

  export type AccountsSumAggregateInputType = {
    id?: true
    userId?: true
    expires_at?: true
  }

  export type AccountsMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    provider_account_id?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type AccountsMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    provider_account_id?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type AccountsCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    provider_account_id?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type AccountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to aggregate.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accounts
    **/
    _count?: true | AccountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountsMaxAggregateInputType
  }

  export type GetAccountsAggregateType<T extends AccountsAggregateArgs> = {
        [P in keyof T & keyof AggregateAccounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccounts[P]>
      : GetScalarType<T[P], AggregateAccounts[P]>
  }




  export type accountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: accountsWhereInput
    orderBy?: accountsOrderByWithAggregationInput | accountsOrderByWithAggregationInput[]
    by: AccountsScalarFieldEnum[] | AccountsScalarFieldEnum
    having?: accountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountsCountAggregateInputType | true
    _avg?: AccountsAvgAggregateInputType
    _sum?: AccountsSumAggregateInputType
    _min?: AccountsMinAggregateInputType
    _max?: AccountsMaxAggregateInputType
  }

  export type AccountsGroupByOutputType = {
    id: number
    userId: number
    type: string
    provider: string
    provider_account_id: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    created_at: Date
    updated_at: Date
    deleted_at: Date | null
    _count: AccountsCountAggregateOutputType | null
    _avg: AccountsAvgAggregateOutputType | null
    _sum: AccountsSumAggregateOutputType | null
    _min: AccountsMinAggregateOutputType | null
    _max: AccountsMaxAggregateOutputType | null
  }

  type GetAccountsGroupByPayload<T extends accountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountsGroupByOutputType[P]>
            : GetScalarType<T[P], AccountsGroupByOutputType[P]>
        }
      >
    >


  export type accountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    provider_account_id?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accounts"]>



  export type accountsSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    provider_account_id?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type accountsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "provider_account_id" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["accounts"]>
  export type accountsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $accountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "accounts"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: string
      provider: string
      provider_account_id: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
      created_at: Date
      updated_at: Date
      deleted_at: Date | null
    }, ExtArgs["result"]["accounts"]>
    composites: {}
  }

  type accountsGetPayload<S extends boolean | null | undefined | accountsDefaultArgs> = $Result.GetResult<Prisma.$accountsPayload, S>

  type accountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<accountsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountsCountAggregateInputType | true
    }

  export interface accountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['accounts'], meta: { name: 'accounts' } }
    /**
     * Find zero or one Accounts that matches the filter.
     * @param {accountsFindUniqueArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends accountsFindUniqueArgs>(args: SelectSubset<T, accountsFindUniqueArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Accounts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {accountsFindUniqueOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends accountsFindUniqueOrThrowArgs>(args: SelectSubset<T, accountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindFirstArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends accountsFindFirstArgs>(args?: SelectSubset<T, accountsFindFirstArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Accounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindFirstOrThrowArgs} args - Arguments to find a Accounts
     * @example
     * // Get one Accounts
     * const accounts = await prisma.accounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends accountsFindFirstOrThrowArgs>(args?: SelectSubset<T, accountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.accounts.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.accounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountsWithIdOnly = await prisma.accounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends accountsFindManyArgs>(args?: SelectSubset<T, accountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Accounts.
     * @param {accountsCreateArgs} args - Arguments to create a Accounts.
     * @example
     * // Create one Accounts
     * const Accounts = await prisma.accounts.create({
     *   data: {
     *     // ... data to create a Accounts
     *   }
     * })
     * 
     */
    create<T extends accountsCreateArgs>(args: SelectSubset<T, accountsCreateArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {accountsCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const accounts = await prisma.accounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends accountsCreateManyArgs>(args?: SelectSubset<T, accountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Accounts.
     * @param {accountsDeleteArgs} args - Arguments to delete one Accounts.
     * @example
     * // Delete one Accounts
     * const Accounts = await prisma.accounts.delete({
     *   where: {
     *     // ... filter to delete one Accounts
     *   }
     * })
     * 
     */
    delete<T extends accountsDeleteArgs>(args: SelectSubset<T, accountsDeleteArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Accounts.
     * @param {accountsUpdateArgs} args - Arguments to update one Accounts.
     * @example
     * // Update one Accounts
     * const accounts = await prisma.accounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends accountsUpdateArgs>(args: SelectSubset<T, accountsUpdateArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {accountsDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.accounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends accountsDeleteManyArgs>(args?: SelectSubset<T, accountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const accounts = await prisma.accounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends accountsUpdateManyArgs>(args: SelectSubset<T, accountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Accounts.
     * @param {accountsUpsertArgs} args - Arguments to update or create a Accounts.
     * @example
     * // Update or create a Accounts
     * const accounts = await prisma.accounts.upsert({
     *   create: {
     *     // ... data to create a Accounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Accounts we want to update
     *   }
     * })
     */
    upsert<T extends accountsUpsertArgs>(args: SelectSubset<T, accountsUpsertArgs<ExtArgs>>): Prisma__accountsClient<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.accounts.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends accountsCountArgs>(
      args?: Subset<T, accountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountsAggregateArgs>(args: Subset<T, AccountsAggregateArgs>): Prisma.PrismaPromise<GetAccountsAggregateType<T>>

    /**
     * Group by Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends accountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: accountsGroupByArgs['orderBy'] }
        : { orderBy?: accountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, accountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the accounts model
   */
  readonly fields: accountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for accounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__accountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the accounts model
   */
  interface accountsFieldRefs {
    readonly id: FieldRef<"accounts", 'Int'>
    readonly userId: FieldRef<"accounts", 'Int'>
    readonly type: FieldRef<"accounts", 'String'>
    readonly provider: FieldRef<"accounts", 'String'>
    readonly provider_account_id: FieldRef<"accounts", 'String'>
    readonly refresh_token: FieldRef<"accounts", 'String'>
    readonly access_token: FieldRef<"accounts", 'String'>
    readonly expires_at: FieldRef<"accounts", 'Int'>
    readonly token_type: FieldRef<"accounts", 'String'>
    readonly scope: FieldRef<"accounts", 'String'>
    readonly id_token: FieldRef<"accounts", 'String'>
    readonly session_state: FieldRef<"accounts", 'String'>
    readonly created_at: FieldRef<"accounts", 'DateTime'>
    readonly updated_at: FieldRef<"accounts", 'DateTime'>
    readonly deleted_at: FieldRef<"accounts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * accounts findUnique
   */
  export type accountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts findUniqueOrThrow
   */
  export type accountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts findFirst
   */
  export type accountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts findFirstOrThrow
   */
  export type accountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts findMany
   */
  export type accountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accounts.
     */
    cursor?: accountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * accounts create
   */
  export type accountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The data needed to create a accounts.
     */
    data: XOR<accountsCreateInput, accountsUncheckedCreateInput>
  }

  /**
   * accounts createMany
   */
  export type accountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many accounts.
     */
    data: accountsCreateManyInput | accountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * accounts update
   */
  export type accountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The data needed to update a accounts.
     */
    data: XOR<accountsUpdateInput, accountsUncheckedUpdateInput>
    /**
     * Choose, which accounts to update.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts updateMany
   */
  export type accountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update accounts.
     */
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountsWhereInput
    /**
     * Limit how many accounts to update.
     */
    limit?: number
  }

  /**
   * accounts upsert
   */
  export type accountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * The filter to search for the accounts to update in case it exists.
     */
    where: accountsWhereUniqueInput
    /**
     * In case the accounts found by the `where` argument doesn't exist, create a new accounts with this data.
     */
    create: XOR<accountsCreateInput, accountsUncheckedCreateInput>
    /**
     * In case the accounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accountsUpdateInput, accountsUncheckedUpdateInput>
  }

  /**
   * accounts delete
   */
  export type accountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    /**
     * Filter which accounts to delete.
     */
    where: accountsWhereUniqueInput
  }

  /**
   * accounts deleteMany
   */
  export type accountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which accounts to delete
     */
    where?: accountsWhereInput
    /**
     * Limit how many accounts to delete.
     */
    limit?: number
  }

  /**
   * accounts without action
   */
  export type accountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
  }


  /**
   * Model bookings
   */

  export type AggregateBookings = {
    _count: BookingsCountAggregateOutputType | null
    _avg: BookingsAvgAggregateOutputType | null
    _sum: BookingsSumAggregateOutputType | null
    _min: BookingsMinAggregateOutputType | null
    _max: BookingsMaxAggregateOutputType | null
  }

  export type BookingsAvgAggregateOutputType = {
    id: number | null
    quote_id: number | null
    client_id: number | null
    hotel_id: number | null
    agent_id: number | null
    invoiceid: number | null
  }

  export type BookingsSumAggregateOutputType = {
    id: number | null
    quote_id: number | null
    client_id: number | null
    hotel_id: number | null
    agent_id: number | null
    invoiceid: number | null
  }

  export type BookingsMinAggregateOutputType = {
    id: number | null
    quote_id: number | null
    client_id: number | null
    hotel_id: number | null
    travel_date: Date | null
    return_date: Date | null
    meal_plan: $Enums.bookings_meal_plan | null
    room_category: $Enums.bookings_room_category | null
    status: $Enums.bookings_status | null
    voucher_url: string | null
    agent_id: number | null
    invoiceid: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string | null
  }

  export type BookingsMaxAggregateOutputType = {
    id: number | null
    quote_id: number | null
    client_id: number | null
    hotel_id: number | null
    travel_date: Date | null
    return_date: Date | null
    meal_plan: $Enums.bookings_meal_plan | null
    room_category: $Enums.bookings_room_category | null
    status: $Enums.bookings_status | null
    voucher_url: string | null
    agent_id: number | null
    invoiceid: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string | null
  }

  export type BookingsCountAggregateOutputType = {
    id: number
    quote_id: number
    client_id: number
    hotel_id: number
    travel_date: number
    return_date: number
    meal_plan: number
    room_category: number
    status: number
    voucher_url: number
    agent_id: number
    invoiceid: number
    created_at: number
    updated_at: number
    deleted_at: number
    public_id: number
    _all: number
  }


  export type BookingsAvgAggregateInputType = {
    id?: true
    quote_id?: true
    client_id?: true
    hotel_id?: true
    agent_id?: true
    invoiceid?: true
  }

  export type BookingsSumAggregateInputType = {
    id?: true
    quote_id?: true
    client_id?: true
    hotel_id?: true
    agent_id?: true
    invoiceid?: true
  }

  export type BookingsMinAggregateInputType = {
    id?: true
    quote_id?: true
    client_id?: true
    hotel_id?: true
    travel_date?: true
    return_date?: true
    meal_plan?: true
    room_category?: true
    status?: true
    voucher_url?: true
    agent_id?: true
    invoiceid?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
  }

  export type BookingsMaxAggregateInputType = {
    id?: true
    quote_id?: true
    client_id?: true
    hotel_id?: true
    travel_date?: true
    return_date?: true
    meal_plan?: true
    room_category?: true
    status?: true
    voucher_url?: true
    agent_id?: true
    invoiceid?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
  }

  export type BookingsCountAggregateInputType = {
    id?: true
    quote_id?: true
    client_id?: true
    hotel_id?: true
    travel_date?: true
    return_date?: true
    meal_plan?: true
    room_category?: true
    status?: true
    voucher_url?: true
    agent_id?: true
    invoiceid?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
    _all?: true
  }

  export type BookingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bookings to aggregate.
     */
    where?: bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bookings
    **/
    _count?: true | BookingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingsMaxAggregateInputType
  }

  export type GetBookingsAggregateType<T extends BookingsAggregateArgs> = {
        [P in keyof T & keyof AggregateBookings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookings[P]>
      : GetScalarType<T[P], AggregateBookings[P]>
  }




  export type bookingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bookingsWhereInput
    orderBy?: bookingsOrderByWithAggregationInput | bookingsOrderByWithAggregationInput[]
    by: BookingsScalarFieldEnum[] | BookingsScalarFieldEnum
    having?: bookingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingsCountAggregateInputType | true
    _avg?: BookingsAvgAggregateInputType
    _sum?: BookingsSumAggregateInputType
    _min?: BookingsMinAggregateInputType
    _max?: BookingsMaxAggregateInputType
  }

  export type BookingsGroupByOutputType = {
    id: number
    quote_id: number
    client_id: number
    hotel_id: number
    travel_date: Date
    return_date: Date
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status: $Enums.bookings_status
    voucher_url: string | null
    agent_id: number
    invoiceid: number | null
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string
    _count: BookingsCountAggregateOutputType | null
    _avg: BookingsAvgAggregateOutputType | null
    _sum: BookingsSumAggregateOutputType | null
    _min: BookingsMinAggregateOutputType | null
    _max: BookingsMaxAggregateOutputType | null
  }

  type GetBookingsGroupByPayload<T extends bookingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingsGroupByOutputType[P]>
            : GetScalarType<T[P], BookingsGroupByOutputType[P]>
        }
      >
    >


  export type bookingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quote_id?: boolean
    client_id?: boolean
    hotel_id?: boolean
    travel_date?: boolean
    return_date?: boolean
    meal_plan?: boolean
    room_category?: boolean
    status?: boolean
    voucher_url?: boolean
    agent_id?: boolean
    invoiceid?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    public_id?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    client?: boolean | clientsDefaultArgs<ExtArgs>
    hotel?: boolean | hotelsDefaultArgs<ExtArgs>
    invoice?: boolean | bookings$invoiceArgs<ExtArgs>
    quote?: boolean | quotesDefaultArgs<ExtArgs>
    cancellations?: boolean | bookings$cancellationsArgs<ExtArgs>
    transportation?: boolean | bookings$transportationArgs<ExtArgs>
    payments?: boolean | bookings$paymentsArgs<ExtArgs>
    _count?: boolean | BookingsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookings"]>



  export type bookingsSelectScalar = {
    id?: boolean
    quote_id?: boolean
    client_id?: boolean
    hotel_id?: boolean
    travel_date?: boolean
    return_date?: boolean
    meal_plan?: boolean
    room_category?: boolean
    status?: boolean
    voucher_url?: boolean
    agent_id?: boolean
    invoiceid?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    public_id?: boolean
  }

  export type bookingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quote_id" | "client_id" | "hotel_id" | "travel_date" | "return_date" | "meal_plan" | "room_category" | "status" | "voucher_url" | "agent_id" | "invoiceid" | "created_at" | "updated_at" | "deleted_at" | "public_id", ExtArgs["result"]["bookings"]>
  export type bookingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    client?: boolean | clientsDefaultArgs<ExtArgs>
    hotel?: boolean | hotelsDefaultArgs<ExtArgs>
    invoice?: boolean | bookings$invoiceArgs<ExtArgs>
    quote?: boolean | quotesDefaultArgs<ExtArgs>
    cancellations?: boolean | bookings$cancellationsArgs<ExtArgs>
    transportation?: boolean | bookings$transportationArgs<ExtArgs>
    payments?: boolean | bookings$paymentsArgs<ExtArgs>
    _count?: boolean | BookingsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $bookingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bookings"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      client: Prisma.$clientsPayload<ExtArgs>
      hotel: Prisma.$hotelsPayload<ExtArgs>
      invoice: Prisma.$invoicesPayload<ExtArgs> | null
      quote: Prisma.$quotesPayload<ExtArgs>
      cancellations: Prisma.$cancellationsPayload<ExtArgs>[]
      transportation: Prisma.$transportationPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quote_id: number
      client_id: number
      hotel_id: number
      travel_date: Date
      return_date: Date
      meal_plan: $Enums.bookings_meal_plan
      room_category: $Enums.bookings_room_category
      status: $Enums.bookings_status
      voucher_url: string | null
      agent_id: number
      invoiceid: number | null
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
      public_id: string
    }, ExtArgs["result"]["bookings"]>
    composites: {}
  }

  type bookingsGetPayload<S extends boolean | null | undefined | bookingsDefaultArgs> = $Result.GetResult<Prisma.$bookingsPayload, S>

  type bookingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bookingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingsCountAggregateInputType | true
    }

  export interface bookingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bookings'], meta: { name: 'bookings' } }
    /**
     * Find zero or one Bookings that matches the filter.
     * @param {bookingsFindUniqueArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bookingsFindUniqueArgs>(args: SelectSubset<T, bookingsFindUniqueArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bookings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bookingsFindUniqueOrThrowArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bookingsFindUniqueOrThrowArgs>(args: SelectSubset<T, bookingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsFindFirstArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bookingsFindFirstArgs>(args?: SelectSubset<T, bookingsFindFirstArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bookings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsFindFirstOrThrowArgs} args - Arguments to find a Bookings
     * @example
     * // Get one Bookings
     * const bookings = await prisma.bookings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bookingsFindFirstOrThrowArgs>(args?: SelectSubset<T, bookingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.bookings.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.bookings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingsWithIdOnly = await prisma.bookings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bookingsFindManyArgs>(args?: SelectSubset<T, bookingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bookings.
     * @param {bookingsCreateArgs} args - Arguments to create a Bookings.
     * @example
     * // Create one Bookings
     * const Bookings = await prisma.bookings.create({
     *   data: {
     *     // ... data to create a Bookings
     *   }
     * })
     * 
     */
    create<T extends bookingsCreateArgs>(args: SelectSubset<T, bookingsCreateArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {bookingsCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const bookings = await prisma.bookings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bookingsCreateManyArgs>(args?: SelectSubset<T, bookingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bookings.
     * @param {bookingsDeleteArgs} args - Arguments to delete one Bookings.
     * @example
     * // Delete one Bookings
     * const Bookings = await prisma.bookings.delete({
     *   where: {
     *     // ... filter to delete one Bookings
     *   }
     * })
     * 
     */
    delete<T extends bookingsDeleteArgs>(args: SelectSubset<T, bookingsDeleteArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bookings.
     * @param {bookingsUpdateArgs} args - Arguments to update one Bookings.
     * @example
     * // Update one Bookings
     * const bookings = await prisma.bookings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bookingsUpdateArgs>(args: SelectSubset<T, bookingsUpdateArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {bookingsDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.bookings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bookingsDeleteManyArgs>(args?: SelectSubset<T, bookingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const bookings = await prisma.bookings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bookingsUpdateManyArgs>(args: SelectSubset<T, bookingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bookings.
     * @param {bookingsUpsertArgs} args - Arguments to update or create a Bookings.
     * @example
     * // Update or create a Bookings
     * const bookings = await prisma.bookings.upsert({
     *   create: {
     *     // ... data to create a Bookings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bookings we want to update
     *   }
     * })
     */
    upsert<T extends bookingsUpsertArgs>(args: SelectSubset<T, bookingsUpsertArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.bookings.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends bookingsCountArgs>(
      args?: Subset<T, bookingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingsAggregateArgs>(args: Subset<T, BookingsAggregateArgs>): Prisma.PrismaPromise<GetBookingsAggregateType<T>>

    /**
     * Group by Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bookingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bookingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bookingsGroupByArgs['orderBy'] }
        : { orderBy?: bookingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bookingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bookings model
   */
  readonly fields: bookingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bookings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bookingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends clientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clientsDefaultArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    hotel<T extends hotelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, hotelsDefaultArgs<ExtArgs>>): Prisma__hotelsClient<$Result.GetResult<Prisma.$hotelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends bookings$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, bookings$invoiceArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quote<T extends quotesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, quotesDefaultArgs<ExtArgs>>): Prisma__quotesClient<$Result.GetResult<Prisma.$quotesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cancellations<T extends bookings$cancellationsArgs<ExtArgs> = {}>(args?: Subset<T, bookings$cancellationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cancellationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transportation<T extends bookings$transportationArgs<ExtArgs> = {}>(args?: Subset<T, bookings$transportationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transportationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends bookings$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, bookings$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bookings model
   */
  interface bookingsFieldRefs {
    readonly id: FieldRef<"bookings", 'Int'>
    readonly quote_id: FieldRef<"bookings", 'Int'>
    readonly client_id: FieldRef<"bookings", 'Int'>
    readonly hotel_id: FieldRef<"bookings", 'Int'>
    readonly travel_date: FieldRef<"bookings", 'DateTime'>
    readonly return_date: FieldRef<"bookings", 'DateTime'>
    readonly meal_plan: FieldRef<"bookings", 'bookings_meal_plan'>
    readonly room_category: FieldRef<"bookings", 'bookings_room_category'>
    readonly status: FieldRef<"bookings", 'bookings_status'>
    readonly voucher_url: FieldRef<"bookings", 'String'>
    readonly agent_id: FieldRef<"bookings", 'Int'>
    readonly invoiceid: FieldRef<"bookings", 'Int'>
    readonly created_at: FieldRef<"bookings", 'DateTime'>
    readonly updated_at: FieldRef<"bookings", 'DateTime'>
    readonly deleted_at: FieldRef<"bookings", 'DateTime'>
    readonly public_id: FieldRef<"bookings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * bookings findUnique
   */
  export type bookingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where: bookingsWhereUniqueInput
  }

  /**
   * bookings findUniqueOrThrow
   */
  export type bookingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where: bookingsWhereUniqueInput
  }

  /**
   * bookings findFirst
   */
  export type bookingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where?: bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bookings.
     */
    cursor?: bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bookings.
     */
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * bookings findFirstOrThrow
   */
  export type bookingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where?: bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bookings.
     */
    cursor?: bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bookings.
     */
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * bookings findMany
   */
  export type bookingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter, which bookings to fetch.
     */
    where?: bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bookings to fetch.
     */
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bookings.
     */
    cursor?: bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bookings.
     */
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * bookings create
   */
  export type bookingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * The data needed to create a bookings.
     */
    data: XOR<bookingsCreateInput, bookingsUncheckedCreateInput>
  }

  /**
   * bookings createMany
   */
  export type bookingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bookings.
     */
    data: bookingsCreateManyInput | bookingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bookings update
   */
  export type bookingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * The data needed to update a bookings.
     */
    data: XOR<bookingsUpdateInput, bookingsUncheckedUpdateInput>
    /**
     * Choose, which bookings to update.
     */
    where: bookingsWhereUniqueInput
  }

  /**
   * bookings updateMany
   */
  export type bookingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bookings.
     */
    data: XOR<bookingsUpdateManyMutationInput, bookingsUncheckedUpdateManyInput>
    /**
     * Filter which bookings to update
     */
    where?: bookingsWhereInput
    /**
     * Limit how many bookings to update.
     */
    limit?: number
  }

  /**
   * bookings upsert
   */
  export type bookingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * The filter to search for the bookings to update in case it exists.
     */
    where: bookingsWhereUniqueInput
    /**
     * In case the bookings found by the `where` argument doesn't exist, create a new bookings with this data.
     */
    create: XOR<bookingsCreateInput, bookingsUncheckedCreateInput>
    /**
     * In case the bookings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bookingsUpdateInput, bookingsUncheckedUpdateInput>
  }

  /**
   * bookings delete
   */
  export type bookingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    /**
     * Filter which bookings to delete.
     */
    where: bookingsWhereUniqueInput
  }

  /**
   * bookings deleteMany
   */
  export type bookingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bookings to delete
     */
    where?: bookingsWhereInput
    /**
     * Limit how many bookings to delete.
     */
    limit?: number
  }

  /**
   * bookings.invoice
   */
  export type bookings$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    where?: invoicesWhereInput
  }

  /**
   * bookings.cancellations
   */
  export type bookings$cancellationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cancellations
     */
    select?: cancellationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cancellations
     */
    omit?: cancellationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cancellationsInclude<ExtArgs> | null
    where?: cancellationsWhereInput
    orderBy?: cancellationsOrderByWithRelationInput | cancellationsOrderByWithRelationInput[]
    cursor?: cancellationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CancellationsScalarFieldEnum | CancellationsScalarFieldEnum[]
  }

  /**
   * bookings.transportation
   */
  export type bookings$transportationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transportation
     */
    select?: transportationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transportation
     */
    omit?: transportationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transportationInclude<ExtArgs> | null
    where?: transportationWhereInput
    orderBy?: transportationOrderByWithRelationInput | transportationOrderByWithRelationInput[]
    cursor?: transportationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransportationScalarFieldEnum | TransportationScalarFieldEnum[]
  }

  /**
   * bookings.payments
   */
  export type bookings$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * bookings without action
   */
  export type bookingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
  }


  /**
   * Model cancellations
   */

  export type AggregateCancellations = {
    _count: CancellationsCountAggregateOutputType | null
    _avg: CancellationsAvgAggregateOutputType | null
    _sum: CancellationsSumAggregateOutputType | null
    _min: CancellationsMinAggregateOutputType | null
    _max: CancellationsMaxAggregateOutputType | null
  }

  export type CancellationsAvgAggregateOutputType = {
    id: number | null
    booking_id: number | null
    hotel_charges: number | null
    refund_amount: number | null
    processed_by: number | null
  }

  export type CancellationsSumAggregateOutputType = {
    id: number | null
    booking_id: number | null
    hotel_charges: number | null
    refund_amount: number | null
    processed_by: number | null
  }

  export type CancellationsMinAggregateOutputType = {
    id: number | null
    booking_id: number | null
    cancellation_date: Date | null
    reason: string | null
    hotel_charges: number | null
    credit_note_url: string | null
    refund_amount: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    processed_by: number | null
    status: $Enums.shared_status | null
  }

  export type CancellationsMaxAggregateOutputType = {
    id: number | null
    booking_id: number | null
    cancellation_date: Date | null
    reason: string | null
    hotel_charges: number | null
    credit_note_url: string | null
    refund_amount: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    processed_by: number | null
    status: $Enums.shared_status | null
  }

  export type CancellationsCountAggregateOutputType = {
    id: number
    booking_id: number
    cancellation_date: number
    reason: number
    hotel_charges: number
    credit_note_url: number
    refund_amount: number
    created_at: number
    updated_at: number
    deleted_at: number
    processed_by: number
    status: number
    _all: number
  }


  export type CancellationsAvgAggregateInputType = {
    id?: true
    booking_id?: true
    hotel_charges?: true
    refund_amount?: true
    processed_by?: true
  }

  export type CancellationsSumAggregateInputType = {
    id?: true
    booking_id?: true
    hotel_charges?: true
    refund_amount?: true
    processed_by?: true
  }

  export type CancellationsMinAggregateInputType = {
    id?: true
    booking_id?: true
    cancellation_date?: true
    reason?: true
    hotel_charges?: true
    credit_note_url?: true
    refund_amount?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    processed_by?: true
    status?: true
  }

  export type CancellationsMaxAggregateInputType = {
    id?: true
    booking_id?: true
    cancellation_date?: true
    reason?: true
    hotel_charges?: true
    credit_note_url?: true
    refund_amount?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    processed_by?: true
    status?: true
  }

  export type CancellationsCountAggregateInputType = {
    id?: true
    booking_id?: true
    cancellation_date?: true
    reason?: true
    hotel_charges?: true
    credit_note_url?: true
    refund_amount?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    processed_by?: true
    status?: true
    _all?: true
  }

  export type CancellationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cancellations to aggregate.
     */
    where?: cancellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cancellations to fetch.
     */
    orderBy?: cancellationsOrderByWithRelationInput | cancellationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cancellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cancellations
    **/
    _count?: true | CancellationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CancellationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CancellationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CancellationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CancellationsMaxAggregateInputType
  }

  export type GetCancellationsAggregateType<T extends CancellationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCancellations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCancellations[P]>
      : GetScalarType<T[P], AggregateCancellations[P]>
  }




  export type cancellationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cancellationsWhereInput
    orderBy?: cancellationsOrderByWithAggregationInput | cancellationsOrderByWithAggregationInput[]
    by: CancellationsScalarFieldEnum[] | CancellationsScalarFieldEnum
    having?: cancellationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CancellationsCountAggregateInputType | true
    _avg?: CancellationsAvgAggregateInputType
    _sum?: CancellationsSumAggregateInputType
    _min?: CancellationsMinAggregateInputType
    _max?: CancellationsMaxAggregateInputType
  }

  export type CancellationsGroupByOutputType = {
    id: number
    booking_id: number
    cancellation_date: Date
    reason: string | null
    hotel_charges: number
    credit_note_url: string | null
    refund_amount: number
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    processed_by: number
    status: $Enums.shared_status
    _count: CancellationsCountAggregateOutputType | null
    _avg: CancellationsAvgAggregateOutputType | null
    _sum: CancellationsSumAggregateOutputType | null
    _min: CancellationsMinAggregateOutputType | null
    _max: CancellationsMaxAggregateOutputType | null
  }

  type GetCancellationsGroupByPayload<T extends cancellationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CancellationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CancellationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CancellationsGroupByOutputType[P]>
            : GetScalarType<T[P], CancellationsGroupByOutputType[P]>
        }
      >
    >


  export type cancellationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    booking_id?: boolean
    cancellation_date?: boolean
    reason?: boolean
    hotel_charges?: boolean
    credit_note_url?: boolean
    refund_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    processed_by?: boolean
    status?: boolean
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cancellations"]>



  export type cancellationsSelectScalar = {
    id?: boolean
    booking_id?: boolean
    cancellation_date?: boolean
    reason?: boolean
    hotel_charges?: boolean
    credit_note_url?: boolean
    refund_amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    processed_by?: boolean
    status?: boolean
  }

  export type cancellationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "booking_id" | "cancellation_date" | "reason" | "hotel_charges" | "credit_note_url" | "refund_amount" | "created_at" | "updated_at" | "deleted_at" | "processed_by" | "status", ExtArgs["result"]["cancellations"]>
  export type cancellationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | bookingsDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $cancellationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cancellations"
    objects: {
      booking: Prisma.$bookingsPayload<ExtArgs>
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      booking_id: number
      cancellation_date: Date
      reason: string | null
      hotel_charges: number
      credit_note_url: string | null
      refund_amount: number
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
      processed_by: number
      status: $Enums.shared_status
    }, ExtArgs["result"]["cancellations"]>
    composites: {}
  }

  type cancellationsGetPayload<S extends boolean | null | undefined | cancellationsDefaultArgs> = $Result.GetResult<Prisma.$cancellationsPayload, S>

  type cancellationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cancellationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CancellationsCountAggregateInputType | true
    }

  export interface cancellationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cancellations'], meta: { name: 'cancellations' } }
    /**
     * Find zero or one Cancellations that matches the filter.
     * @param {cancellationsFindUniqueArgs} args - Arguments to find a Cancellations
     * @example
     * // Get one Cancellations
     * const cancellations = await prisma.cancellations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cancellationsFindUniqueArgs>(args: SelectSubset<T, cancellationsFindUniqueArgs<ExtArgs>>): Prisma__cancellationsClient<$Result.GetResult<Prisma.$cancellationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cancellations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cancellationsFindUniqueOrThrowArgs} args - Arguments to find a Cancellations
     * @example
     * // Get one Cancellations
     * const cancellations = await prisma.cancellations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cancellationsFindUniqueOrThrowArgs>(args: SelectSubset<T, cancellationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cancellationsClient<$Result.GetResult<Prisma.$cancellationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cancellations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cancellationsFindFirstArgs} args - Arguments to find a Cancellations
     * @example
     * // Get one Cancellations
     * const cancellations = await prisma.cancellations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cancellationsFindFirstArgs>(args?: SelectSubset<T, cancellationsFindFirstArgs<ExtArgs>>): Prisma__cancellationsClient<$Result.GetResult<Prisma.$cancellationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cancellations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cancellationsFindFirstOrThrowArgs} args - Arguments to find a Cancellations
     * @example
     * // Get one Cancellations
     * const cancellations = await prisma.cancellations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cancellationsFindFirstOrThrowArgs>(args?: SelectSubset<T, cancellationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__cancellationsClient<$Result.GetResult<Prisma.$cancellationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cancellations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cancellationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cancellations
     * const cancellations = await prisma.cancellations.findMany()
     * 
     * // Get first 10 Cancellations
     * const cancellations = await prisma.cancellations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cancellationsWithIdOnly = await prisma.cancellations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cancellationsFindManyArgs>(args?: SelectSubset<T, cancellationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cancellationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cancellations.
     * @param {cancellationsCreateArgs} args - Arguments to create a Cancellations.
     * @example
     * // Create one Cancellations
     * const Cancellations = await prisma.cancellations.create({
     *   data: {
     *     // ... data to create a Cancellations
     *   }
     * })
     * 
     */
    create<T extends cancellationsCreateArgs>(args: SelectSubset<T, cancellationsCreateArgs<ExtArgs>>): Prisma__cancellationsClient<$Result.GetResult<Prisma.$cancellationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cancellations.
     * @param {cancellationsCreateManyArgs} args - Arguments to create many Cancellations.
     * @example
     * // Create many Cancellations
     * const cancellations = await prisma.cancellations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cancellationsCreateManyArgs>(args?: SelectSubset<T, cancellationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cancellations.
     * @param {cancellationsDeleteArgs} args - Arguments to delete one Cancellations.
     * @example
     * // Delete one Cancellations
     * const Cancellations = await prisma.cancellations.delete({
     *   where: {
     *     // ... filter to delete one Cancellations
     *   }
     * })
     * 
     */
    delete<T extends cancellationsDeleteArgs>(args: SelectSubset<T, cancellationsDeleteArgs<ExtArgs>>): Prisma__cancellationsClient<$Result.GetResult<Prisma.$cancellationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cancellations.
     * @param {cancellationsUpdateArgs} args - Arguments to update one Cancellations.
     * @example
     * // Update one Cancellations
     * const cancellations = await prisma.cancellations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cancellationsUpdateArgs>(args: SelectSubset<T, cancellationsUpdateArgs<ExtArgs>>): Prisma__cancellationsClient<$Result.GetResult<Prisma.$cancellationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cancellations.
     * @param {cancellationsDeleteManyArgs} args - Arguments to filter Cancellations to delete.
     * @example
     * // Delete a few Cancellations
     * const { count } = await prisma.cancellations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cancellationsDeleteManyArgs>(args?: SelectSubset<T, cancellationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cancellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cancellationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cancellations
     * const cancellations = await prisma.cancellations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cancellationsUpdateManyArgs>(args: SelectSubset<T, cancellationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cancellations.
     * @param {cancellationsUpsertArgs} args - Arguments to update or create a Cancellations.
     * @example
     * // Update or create a Cancellations
     * const cancellations = await prisma.cancellations.upsert({
     *   create: {
     *     // ... data to create a Cancellations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cancellations we want to update
     *   }
     * })
     */
    upsert<T extends cancellationsUpsertArgs>(args: SelectSubset<T, cancellationsUpsertArgs<ExtArgs>>): Prisma__cancellationsClient<$Result.GetResult<Prisma.$cancellationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cancellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cancellationsCountArgs} args - Arguments to filter Cancellations to count.
     * @example
     * // Count the number of Cancellations
     * const count = await prisma.cancellations.count({
     *   where: {
     *     // ... the filter for the Cancellations we want to count
     *   }
     * })
    **/
    count<T extends cancellationsCountArgs>(
      args?: Subset<T, cancellationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CancellationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cancellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CancellationsAggregateArgs>(args: Subset<T, CancellationsAggregateArgs>): Prisma.PrismaPromise<GetCancellationsAggregateType<T>>

    /**
     * Group by Cancellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cancellationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cancellationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cancellationsGroupByArgs['orderBy'] }
        : { orderBy?: cancellationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cancellationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCancellationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cancellations model
   */
  readonly fields: cancellationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cancellations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cancellationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends bookingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookingsDefaultArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cancellations model
   */
  interface cancellationsFieldRefs {
    readonly id: FieldRef<"cancellations", 'Int'>
    readonly booking_id: FieldRef<"cancellations", 'Int'>
    readonly cancellation_date: FieldRef<"cancellations", 'DateTime'>
    readonly reason: FieldRef<"cancellations", 'String'>
    readonly hotel_charges: FieldRef<"cancellations", 'Float'>
    readonly credit_note_url: FieldRef<"cancellations", 'String'>
    readonly refund_amount: FieldRef<"cancellations", 'Float'>
    readonly created_at: FieldRef<"cancellations", 'DateTime'>
    readonly updated_at: FieldRef<"cancellations", 'DateTime'>
    readonly deleted_at: FieldRef<"cancellations", 'DateTime'>
    readonly processed_by: FieldRef<"cancellations", 'Int'>
    readonly status: FieldRef<"cancellations", 'shared_status'>
  }
    

  // Custom InputTypes
  /**
   * cancellations findUnique
   */
  export type cancellationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cancellations
     */
    select?: cancellationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cancellations
     */
    omit?: cancellationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cancellationsInclude<ExtArgs> | null
    /**
     * Filter, which cancellations to fetch.
     */
    where: cancellationsWhereUniqueInput
  }

  /**
   * cancellations findUniqueOrThrow
   */
  export type cancellationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cancellations
     */
    select?: cancellationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cancellations
     */
    omit?: cancellationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cancellationsInclude<ExtArgs> | null
    /**
     * Filter, which cancellations to fetch.
     */
    where: cancellationsWhereUniqueInput
  }

  /**
   * cancellations findFirst
   */
  export type cancellationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cancellations
     */
    select?: cancellationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cancellations
     */
    omit?: cancellationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cancellationsInclude<ExtArgs> | null
    /**
     * Filter, which cancellations to fetch.
     */
    where?: cancellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cancellations to fetch.
     */
    orderBy?: cancellationsOrderByWithRelationInput | cancellationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cancellations.
     */
    cursor?: cancellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cancellations.
     */
    distinct?: CancellationsScalarFieldEnum | CancellationsScalarFieldEnum[]
  }

  /**
   * cancellations findFirstOrThrow
   */
  export type cancellationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cancellations
     */
    select?: cancellationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cancellations
     */
    omit?: cancellationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cancellationsInclude<ExtArgs> | null
    /**
     * Filter, which cancellations to fetch.
     */
    where?: cancellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cancellations to fetch.
     */
    orderBy?: cancellationsOrderByWithRelationInput | cancellationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cancellations.
     */
    cursor?: cancellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cancellations.
     */
    distinct?: CancellationsScalarFieldEnum | CancellationsScalarFieldEnum[]
  }

  /**
   * cancellations findMany
   */
  export type cancellationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cancellations
     */
    select?: cancellationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cancellations
     */
    omit?: cancellationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cancellationsInclude<ExtArgs> | null
    /**
     * Filter, which cancellations to fetch.
     */
    where?: cancellationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cancellations to fetch.
     */
    orderBy?: cancellationsOrderByWithRelationInput | cancellationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cancellations.
     */
    cursor?: cancellationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cancellations.
     */
    skip?: number
    distinct?: CancellationsScalarFieldEnum | CancellationsScalarFieldEnum[]
  }

  /**
   * cancellations create
   */
  export type cancellationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cancellations
     */
    select?: cancellationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cancellations
     */
    omit?: cancellationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cancellationsInclude<ExtArgs> | null
    /**
     * The data needed to create a cancellations.
     */
    data: XOR<cancellationsCreateInput, cancellationsUncheckedCreateInput>
  }

  /**
   * cancellations createMany
   */
  export type cancellationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cancellations.
     */
    data: cancellationsCreateManyInput | cancellationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cancellations update
   */
  export type cancellationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cancellations
     */
    select?: cancellationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cancellations
     */
    omit?: cancellationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cancellationsInclude<ExtArgs> | null
    /**
     * The data needed to update a cancellations.
     */
    data: XOR<cancellationsUpdateInput, cancellationsUncheckedUpdateInput>
    /**
     * Choose, which cancellations to update.
     */
    where: cancellationsWhereUniqueInput
  }

  /**
   * cancellations updateMany
   */
  export type cancellationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cancellations.
     */
    data: XOR<cancellationsUpdateManyMutationInput, cancellationsUncheckedUpdateManyInput>
    /**
     * Filter which cancellations to update
     */
    where?: cancellationsWhereInput
    /**
     * Limit how many cancellations to update.
     */
    limit?: number
  }

  /**
   * cancellations upsert
   */
  export type cancellationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cancellations
     */
    select?: cancellationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cancellations
     */
    omit?: cancellationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cancellationsInclude<ExtArgs> | null
    /**
     * The filter to search for the cancellations to update in case it exists.
     */
    where: cancellationsWhereUniqueInput
    /**
     * In case the cancellations found by the `where` argument doesn't exist, create a new cancellations with this data.
     */
    create: XOR<cancellationsCreateInput, cancellationsUncheckedCreateInput>
    /**
     * In case the cancellations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cancellationsUpdateInput, cancellationsUncheckedUpdateInput>
  }

  /**
   * cancellations delete
   */
  export type cancellationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cancellations
     */
    select?: cancellationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cancellations
     */
    omit?: cancellationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cancellationsInclude<ExtArgs> | null
    /**
     * Filter which cancellations to delete.
     */
    where: cancellationsWhereUniqueInput
  }

  /**
   * cancellations deleteMany
   */
  export type cancellationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cancellations to delete
     */
    where?: cancellationsWhereInput
    /**
     * Limit how many cancellations to delete.
     */
    limit?: number
  }

  /**
   * cancellations without action
   */
  export type cancellationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cancellations
     */
    select?: cancellationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cancellations
     */
    omit?: cancellationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cancellationsInclude<ExtArgs> | null
  }


  /**
   * Model clients
   */

  export type AggregateClients = {
    _count: ClientsCountAggregateOutputType | null
    _avg: ClientsAvgAggregateOutputType | null
    _sum: ClientsSumAggregateOutputType | null
    _min: ClientsMinAggregateOutputType | null
    _max: ClientsMaxAggregateOutputType | null
  }

  export type ClientsAvgAggregateOutputType = {
    id: number | null
    branch_id: number | null
  }

  export type ClientsSumAggregateOutputType = {
    id: number | null
    branch_id: number | null
  }

  export type ClientsMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string | null
    status: $Enums.shared_status | null
    enc_phone: string | null
    branch_id: number | null
  }

  export type ClientsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string | null
    status: $Enums.shared_status | null
    enc_phone: string | null
    branch_id: number | null
  }

  export type ClientsCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    address: number
    created_at: number
    updated_at: number
    deleted_at: number
    public_id: number
    status: number
    enc_phone: number
    branch_id: number
    _all: number
  }


  export type ClientsAvgAggregateInputType = {
    id?: true
    branch_id?: true
  }

  export type ClientsSumAggregateInputType = {
    id?: true
    branch_id?: true
  }

  export type ClientsMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
    status?: true
    enc_phone?: true
    branch_id?: true
  }

  export type ClientsMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
    status?: true
    enc_phone?: true
    branch_id?: true
  }

  export type ClientsCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
    status?: true
    enc_phone?: true
    branch_id?: true
    _all?: true
  }

  export type ClientsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clients to aggregate.
     */
    where?: clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientsOrderByWithRelationInput | clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clients
    **/
    _count?: true | ClientsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientsMaxAggregateInputType
  }

  export type GetClientsAggregateType<T extends ClientsAggregateArgs> = {
        [P in keyof T & keyof AggregateClients]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClients[P]>
      : GetScalarType<T[P], AggregateClients[P]>
  }




  export type clientsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clientsWhereInput
    orderBy?: clientsOrderByWithAggregationInput | clientsOrderByWithAggregationInput[]
    by: ClientsScalarFieldEnum[] | ClientsScalarFieldEnum
    having?: clientsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientsCountAggregateInputType | true
    _avg?: ClientsAvgAggregateInputType
    _sum?: ClientsSumAggregateInputType
    _min?: ClientsMinAggregateInputType
    _max?: ClientsMaxAggregateInputType
  }

  export type ClientsGroupByOutputType = {
    id: number
    name: string
    email: string
    phone: string
    address: string | null
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string
    status: $Enums.shared_status
    enc_phone: string
    branch_id: number | null
    _count: ClientsCountAggregateOutputType | null
    _avg: ClientsAvgAggregateOutputType | null
    _sum: ClientsSumAggregateOutputType | null
    _min: ClientsMinAggregateOutputType | null
    _max: ClientsMaxAggregateOutputType | null
  }

  type GetClientsGroupByPayload<T extends clientsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientsGroupByOutputType[P]>
            : GetScalarType<T[P], ClientsGroupByOutputType[P]>
        }
      >
    >


  export type clientsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    public_id?: boolean
    status?: boolean
    enc_phone?: boolean
    branch_id?: boolean
    bookings?: boolean | clients$bookingsArgs<ExtArgs>
    branch?: boolean | clients$branchArgs<ExtArgs>
    invoices?: boolean | clients$invoicesArgs<ExtArgs>
    quotes?: boolean | clients$quotesArgs<ExtArgs>
    _count?: boolean | ClientsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clients"]>



  export type clientsSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    public_id?: boolean
    status?: boolean
    enc_phone?: boolean
    branch_id?: boolean
  }

  export type clientsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "phone" | "address" | "created_at" | "updated_at" | "deleted_at" | "public_id" | "status" | "enc_phone" | "branch_id", ExtArgs["result"]["clients"]>
  export type clientsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | clients$bookingsArgs<ExtArgs>
    branch?: boolean | clients$branchArgs<ExtArgs>
    invoices?: boolean | clients$invoicesArgs<ExtArgs>
    quotes?: boolean | clients$quotesArgs<ExtArgs>
    _count?: boolean | ClientsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $clientsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clients"
    objects: {
      bookings: Prisma.$bookingsPayload<ExtArgs>[]
      branch: Prisma.$branchesPayload<ExtArgs> | null
      invoices: Prisma.$invoicesPayload<ExtArgs>[]
      quotes: Prisma.$quotesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      phone: string
      address: string | null
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
      public_id: string
      status: $Enums.shared_status
      enc_phone: string
      branch_id: number | null
    }, ExtArgs["result"]["clients"]>
    composites: {}
  }

  type clientsGetPayload<S extends boolean | null | undefined | clientsDefaultArgs> = $Result.GetResult<Prisma.$clientsPayload, S>

  type clientsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clientsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientsCountAggregateInputType | true
    }

  export interface clientsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clients'], meta: { name: 'clients' } }
    /**
     * Find zero or one Clients that matches the filter.
     * @param {clientsFindUniqueArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clientsFindUniqueArgs>(args: SelectSubset<T, clientsFindUniqueArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clients that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clientsFindUniqueOrThrowArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clientsFindUniqueOrThrowArgs>(args: SelectSubset<T, clientsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsFindFirstArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clientsFindFirstArgs>(args?: SelectSubset<T, clientsFindFirstArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clients that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsFindFirstOrThrowArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clientsFindFirstOrThrowArgs>(args?: SelectSubset<T, clientsFindFirstOrThrowArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.clients.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.clients.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientsWithIdOnly = await prisma.clients.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clientsFindManyArgs>(args?: SelectSubset<T, clientsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clients.
     * @param {clientsCreateArgs} args - Arguments to create a Clients.
     * @example
     * // Create one Clients
     * const Clients = await prisma.clients.create({
     *   data: {
     *     // ... data to create a Clients
     *   }
     * })
     * 
     */
    create<T extends clientsCreateArgs>(args: SelectSubset<T, clientsCreateArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {clientsCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const clients = await prisma.clients.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clientsCreateManyArgs>(args?: SelectSubset<T, clientsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clients.
     * @param {clientsDeleteArgs} args - Arguments to delete one Clients.
     * @example
     * // Delete one Clients
     * const Clients = await prisma.clients.delete({
     *   where: {
     *     // ... filter to delete one Clients
     *   }
     * })
     * 
     */
    delete<T extends clientsDeleteArgs>(args: SelectSubset<T, clientsDeleteArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clients.
     * @param {clientsUpdateArgs} args - Arguments to update one Clients.
     * @example
     * // Update one Clients
     * const clients = await prisma.clients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clientsUpdateArgs>(args: SelectSubset<T, clientsUpdateArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {clientsDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.clients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clientsDeleteManyArgs>(args?: SelectSubset<T, clientsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const clients = await prisma.clients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clientsUpdateManyArgs>(args: SelectSubset<T, clientsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clients.
     * @param {clientsUpsertArgs} args - Arguments to update or create a Clients.
     * @example
     * // Update or create a Clients
     * const clients = await prisma.clients.upsert({
     *   create: {
     *     // ... data to create a Clients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clients we want to update
     *   }
     * })
     */
    upsert<T extends clientsUpsertArgs>(args: SelectSubset<T, clientsUpsertArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.clients.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends clientsCountArgs>(
      args?: Subset<T, clientsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientsAggregateArgs>(args: Subset<T, ClientsAggregateArgs>): Prisma.PrismaPromise<GetClientsAggregateType<T>>

    /**
     * Group by Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clientsGroupByArgs['orderBy'] }
        : { orderBy?: clientsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clientsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clients model
   */
  readonly fields: clientsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clientsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends clients$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, clients$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branch<T extends clients$branchArgs<ExtArgs> = {}>(args?: Subset<T, clients$branchArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoices<T extends clients$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, clients$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotes<T extends clients$quotesArgs<ExtArgs> = {}>(args?: Subset<T, clients$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clients model
   */
  interface clientsFieldRefs {
    readonly id: FieldRef<"clients", 'Int'>
    readonly name: FieldRef<"clients", 'String'>
    readonly email: FieldRef<"clients", 'String'>
    readonly phone: FieldRef<"clients", 'String'>
    readonly address: FieldRef<"clients", 'String'>
    readonly created_at: FieldRef<"clients", 'DateTime'>
    readonly updated_at: FieldRef<"clients", 'DateTime'>
    readonly deleted_at: FieldRef<"clients", 'DateTime'>
    readonly public_id: FieldRef<"clients", 'String'>
    readonly status: FieldRef<"clients", 'shared_status'>
    readonly enc_phone: FieldRef<"clients", 'String'>
    readonly branch_id: FieldRef<"clients", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * clients findUnique
   */
  export type clientsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where: clientsWhereUniqueInput
  }

  /**
   * clients findUniqueOrThrow
   */
  export type clientsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where: clientsWhereUniqueInput
  }

  /**
   * clients findFirst
   */
  export type clientsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where?: clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientsOrderByWithRelationInput | clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     */
    cursor?: clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     */
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[]
  }

  /**
   * clients findFirstOrThrow
   */
  export type clientsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where?: clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientsOrderByWithRelationInput | clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clients.
     */
    cursor?: clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clients.
     */
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[]
  }

  /**
   * clients findMany
   */
  export type clientsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter, which clients to fetch.
     */
    where?: clientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clients to fetch.
     */
    orderBy?: clientsOrderByWithRelationInput | clientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clients.
     */
    cursor?: clientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clients.
     */
    skip?: number
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[]
  }

  /**
   * clients create
   */
  export type clientsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * The data needed to create a clients.
     */
    data: XOR<clientsCreateInput, clientsUncheckedCreateInput>
  }

  /**
   * clients createMany
   */
  export type clientsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clients.
     */
    data: clientsCreateManyInput | clientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clients update
   */
  export type clientsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * The data needed to update a clients.
     */
    data: XOR<clientsUpdateInput, clientsUncheckedUpdateInput>
    /**
     * Choose, which clients to update.
     */
    where: clientsWhereUniqueInput
  }

  /**
   * clients updateMany
   */
  export type clientsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clients.
     */
    data: XOR<clientsUpdateManyMutationInput, clientsUncheckedUpdateManyInput>
    /**
     * Filter which clients to update
     */
    where?: clientsWhereInput
    /**
     * Limit how many clients to update.
     */
    limit?: number
  }

  /**
   * clients upsert
   */
  export type clientsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * The filter to search for the clients to update in case it exists.
     */
    where: clientsWhereUniqueInput
    /**
     * In case the clients found by the `where` argument doesn't exist, create a new clients with this data.
     */
    create: XOR<clientsCreateInput, clientsUncheckedCreateInput>
    /**
     * In case the clients was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clientsUpdateInput, clientsUncheckedUpdateInput>
  }

  /**
   * clients delete
   */
  export type clientsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    /**
     * Filter which clients to delete.
     */
    where: clientsWhereUniqueInput
  }

  /**
   * clients deleteMany
   */
  export type clientsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clients to delete
     */
    where?: clientsWhereInput
    /**
     * Limit how many clients to delete.
     */
    limit?: number
  }

  /**
   * clients.bookings
   */
  export type clients$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    where?: bookingsWhereInput
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    cursor?: bookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * clients.branch
   */
  export type clients$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * clients.invoices
   */
  export type clients$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    where?: invoicesWhereInput
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    cursor?: invoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * clients.quotes
   */
  export type clients$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quotes
     */
    omit?: quotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quotesInclude<ExtArgs> | null
    where?: quotesWhereInput
    orderBy?: quotesOrderByWithRelationInput | quotesOrderByWithRelationInput[]
    cursor?: quotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[]
  }

  /**
   * clients without action
   */
  export type clientsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
  }


  /**
   * Model hotel_policies
   */

  export type AggregateHotel_policies = {
    _count: Hotel_policiesCountAggregateOutputType | null
    _avg: Hotel_policiesAvgAggregateOutputType | null
    _sum: Hotel_policiesSumAggregateOutputType | null
    _min: Hotel_policiesMinAggregateOutputType | null
    _max: Hotel_policiesMaxAggregateOutputType | null
  }

  export type Hotel_policiesAvgAggregateOutputType = {
    id: number | null
    hotel_id: number | null
  }

  export type Hotel_policiesSumAggregateOutputType = {
    id: number | null
    hotel_id: number | null
  }

  export type Hotel_policiesMinAggregateOutputType = {
    id: number | null
    cancellation: string | null
    payment_terms: string | null
    commission_terms: string | null
    hotel_id: number | null
    deleted_at: Date | null
    created_at: Date | null
    status: $Enums.shared_status | null
    updated_at: Date | null
  }

  export type Hotel_policiesMaxAggregateOutputType = {
    id: number | null
    cancellation: string | null
    payment_terms: string | null
    commission_terms: string | null
    hotel_id: number | null
    deleted_at: Date | null
    created_at: Date | null
    status: $Enums.shared_status | null
    updated_at: Date | null
  }

  export type Hotel_policiesCountAggregateOutputType = {
    id: number
    cancellation: number
    payment_terms: number
    commission_terms: number
    hotel_id: number
    deleted_at: number
    created_at: number
    status: number
    updated_at: number
    _all: number
  }


  export type Hotel_policiesAvgAggregateInputType = {
    id?: true
    hotel_id?: true
  }

  export type Hotel_policiesSumAggregateInputType = {
    id?: true
    hotel_id?: true
  }

  export type Hotel_policiesMinAggregateInputType = {
    id?: true
    cancellation?: true
    payment_terms?: true
    commission_terms?: true
    hotel_id?: true
    deleted_at?: true
    created_at?: true
    status?: true
    updated_at?: true
  }

  export type Hotel_policiesMaxAggregateInputType = {
    id?: true
    cancellation?: true
    payment_terms?: true
    commission_terms?: true
    hotel_id?: true
    deleted_at?: true
    created_at?: true
    status?: true
    updated_at?: true
  }

  export type Hotel_policiesCountAggregateInputType = {
    id?: true
    cancellation?: true
    payment_terms?: true
    commission_terms?: true
    hotel_id?: true
    deleted_at?: true
    created_at?: true
    status?: true
    updated_at?: true
    _all?: true
  }

  export type Hotel_policiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hotel_policies to aggregate.
     */
    where?: hotel_policiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotel_policies to fetch.
     */
    orderBy?: hotel_policiesOrderByWithRelationInput | hotel_policiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hotel_policiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotel_policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotel_policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hotel_policies
    **/
    _count?: true | Hotel_policiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Hotel_policiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Hotel_policiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Hotel_policiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Hotel_policiesMaxAggregateInputType
  }

  export type GetHotel_policiesAggregateType<T extends Hotel_policiesAggregateArgs> = {
        [P in keyof T & keyof AggregateHotel_policies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotel_policies[P]>
      : GetScalarType<T[P], AggregateHotel_policies[P]>
  }




  export type hotel_policiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hotel_policiesWhereInput
    orderBy?: hotel_policiesOrderByWithAggregationInput | hotel_policiesOrderByWithAggregationInput[]
    by: Hotel_policiesScalarFieldEnum[] | Hotel_policiesScalarFieldEnum
    having?: hotel_policiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Hotel_policiesCountAggregateInputType | true
    _avg?: Hotel_policiesAvgAggregateInputType
    _sum?: Hotel_policiesSumAggregateInputType
    _min?: Hotel_policiesMinAggregateInputType
    _max?: Hotel_policiesMaxAggregateInputType
  }

  export type Hotel_policiesGroupByOutputType = {
    id: number
    cancellation: string
    payment_terms: string
    commission_terms: string
    hotel_id: number
    deleted_at: Date | null
    created_at: Date
    status: $Enums.shared_status
    updated_at: Date | null
    _count: Hotel_policiesCountAggregateOutputType | null
    _avg: Hotel_policiesAvgAggregateOutputType | null
    _sum: Hotel_policiesSumAggregateOutputType | null
    _min: Hotel_policiesMinAggregateOutputType | null
    _max: Hotel_policiesMaxAggregateOutputType | null
  }

  type GetHotel_policiesGroupByPayload<T extends hotel_policiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Hotel_policiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Hotel_policiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Hotel_policiesGroupByOutputType[P]>
            : GetScalarType<T[P], Hotel_policiesGroupByOutputType[P]>
        }
      >
    >


  export type hotel_policiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cancellation?: boolean
    payment_terms?: boolean
    commission_terms?: boolean
    hotel_id?: boolean
    deleted_at?: boolean
    created_at?: boolean
    status?: boolean
    updated_at?: boolean
    hotel?: boolean | hotelsDefaultArgs<ExtArgs>
    seasons?: boolean | hotel_policies$seasonsArgs<ExtArgs>
    _count?: boolean | Hotel_policiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotel_policies"]>



  export type hotel_policiesSelectScalar = {
    id?: boolean
    cancellation?: boolean
    payment_terms?: boolean
    commission_terms?: boolean
    hotel_id?: boolean
    deleted_at?: boolean
    created_at?: boolean
    status?: boolean
    updated_at?: boolean
  }

  export type hotel_policiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "cancellation" | "payment_terms" | "commission_terms" | "hotel_id" | "deleted_at" | "created_at" | "status" | "updated_at", ExtArgs["result"]["hotel_policies"]>
  export type hotel_policiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | hotelsDefaultArgs<ExtArgs>
    seasons?: boolean | hotel_policies$seasonsArgs<ExtArgs>
    _count?: boolean | Hotel_policiesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $hotel_policiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hotel_policies"
    objects: {
      hotel: Prisma.$hotelsPayload<ExtArgs>
      seasons: Prisma.$seasonsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cancellation: string
      payment_terms: string
      commission_terms: string
      hotel_id: number
      deleted_at: Date | null
      created_at: Date
      status: $Enums.shared_status
      updated_at: Date | null
    }, ExtArgs["result"]["hotel_policies"]>
    composites: {}
  }

  type hotel_policiesGetPayload<S extends boolean | null | undefined | hotel_policiesDefaultArgs> = $Result.GetResult<Prisma.$hotel_policiesPayload, S>

  type hotel_policiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hotel_policiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Hotel_policiesCountAggregateInputType | true
    }

  export interface hotel_policiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hotel_policies'], meta: { name: 'hotel_policies' } }
    /**
     * Find zero or one Hotel_policies that matches the filter.
     * @param {hotel_policiesFindUniqueArgs} args - Arguments to find a Hotel_policies
     * @example
     * // Get one Hotel_policies
     * const hotel_policies = await prisma.hotel_policies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hotel_policiesFindUniqueArgs>(args: SelectSubset<T, hotel_policiesFindUniqueArgs<ExtArgs>>): Prisma__hotel_policiesClient<$Result.GetResult<Prisma.$hotel_policiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hotel_policies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hotel_policiesFindUniqueOrThrowArgs} args - Arguments to find a Hotel_policies
     * @example
     * // Get one Hotel_policies
     * const hotel_policies = await prisma.hotel_policies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hotel_policiesFindUniqueOrThrowArgs>(args: SelectSubset<T, hotel_policiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hotel_policiesClient<$Result.GetResult<Prisma.$hotel_policiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotel_policies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotel_policiesFindFirstArgs} args - Arguments to find a Hotel_policies
     * @example
     * // Get one Hotel_policies
     * const hotel_policies = await prisma.hotel_policies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hotel_policiesFindFirstArgs>(args?: SelectSubset<T, hotel_policiesFindFirstArgs<ExtArgs>>): Prisma__hotel_policiesClient<$Result.GetResult<Prisma.$hotel_policiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotel_policies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotel_policiesFindFirstOrThrowArgs} args - Arguments to find a Hotel_policies
     * @example
     * // Get one Hotel_policies
     * const hotel_policies = await prisma.hotel_policies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hotel_policiesFindFirstOrThrowArgs>(args?: SelectSubset<T, hotel_policiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__hotel_policiesClient<$Result.GetResult<Prisma.$hotel_policiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hotel_policies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotel_policiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hotel_policies
     * const hotel_policies = await prisma.hotel_policies.findMany()
     * 
     * // Get first 10 Hotel_policies
     * const hotel_policies = await prisma.hotel_policies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotel_policiesWithIdOnly = await prisma.hotel_policies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends hotel_policiesFindManyArgs>(args?: SelectSubset<T, hotel_policiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hotel_policiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hotel_policies.
     * @param {hotel_policiesCreateArgs} args - Arguments to create a Hotel_policies.
     * @example
     * // Create one Hotel_policies
     * const Hotel_policies = await prisma.hotel_policies.create({
     *   data: {
     *     // ... data to create a Hotel_policies
     *   }
     * })
     * 
     */
    create<T extends hotel_policiesCreateArgs>(args: SelectSubset<T, hotel_policiesCreateArgs<ExtArgs>>): Prisma__hotel_policiesClient<$Result.GetResult<Prisma.$hotel_policiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hotel_policies.
     * @param {hotel_policiesCreateManyArgs} args - Arguments to create many Hotel_policies.
     * @example
     * // Create many Hotel_policies
     * const hotel_policies = await prisma.hotel_policies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hotel_policiesCreateManyArgs>(args?: SelectSubset<T, hotel_policiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hotel_policies.
     * @param {hotel_policiesDeleteArgs} args - Arguments to delete one Hotel_policies.
     * @example
     * // Delete one Hotel_policies
     * const Hotel_policies = await prisma.hotel_policies.delete({
     *   where: {
     *     // ... filter to delete one Hotel_policies
     *   }
     * })
     * 
     */
    delete<T extends hotel_policiesDeleteArgs>(args: SelectSubset<T, hotel_policiesDeleteArgs<ExtArgs>>): Prisma__hotel_policiesClient<$Result.GetResult<Prisma.$hotel_policiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hotel_policies.
     * @param {hotel_policiesUpdateArgs} args - Arguments to update one Hotel_policies.
     * @example
     * // Update one Hotel_policies
     * const hotel_policies = await prisma.hotel_policies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hotel_policiesUpdateArgs>(args: SelectSubset<T, hotel_policiesUpdateArgs<ExtArgs>>): Prisma__hotel_policiesClient<$Result.GetResult<Prisma.$hotel_policiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hotel_policies.
     * @param {hotel_policiesDeleteManyArgs} args - Arguments to filter Hotel_policies to delete.
     * @example
     * // Delete a few Hotel_policies
     * const { count } = await prisma.hotel_policies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hotel_policiesDeleteManyArgs>(args?: SelectSubset<T, hotel_policiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotel_policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotel_policiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hotel_policies
     * const hotel_policies = await prisma.hotel_policies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hotel_policiesUpdateManyArgs>(args: SelectSubset<T, hotel_policiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hotel_policies.
     * @param {hotel_policiesUpsertArgs} args - Arguments to update or create a Hotel_policies.
     * @example
     * // Update or create a Hotel_policies
     * const hotel_policies = await prisma.hotel_policies.upsert({
     *   create: {
     *     // ... data to create a Hotel_policies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hotel_policies we want to update
     *   }
     * })
     */
    upsert<T extends hotel_policiesUpsertArgs>(args: SelectSubset<T, hotel_policiesUpsertArgs<ExtArgs>>): Prisma__hotel_policiesClient<$Result.GetResult<Prisma.$hotel_policiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hotel_policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotel_policiesCountArgs} args - Arguments to filter Hotel_policies to count.
     * @example
     * // Count the number of Hotel_policies
     * const count = await prisma.hotel_policies.count({
     *   where: {
     *     // ... the filter for the Hotel_policies we want to count
     *   }
     * })
    **/
    count<T extends hotel_policiesCountArgs>(
      args?: Subset<T, hotel_policiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Hotel_policiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hotel_policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Hotel_policiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Hotel_policiesAggregateArgs>(args: Subset<T, Hotel_policiesAggregateArgs>): Prisma.PrismaPromise<GetHotel_policiesAggregateType<T>>

    /**
     * Group by Hotel_policies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotel_policiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hotel_policiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hotel_policiesGroupByArgs['orderBy'] }
        : { orderBy?: hotel_policiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hotel_policiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotel_policiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hotel_policies model
   */
  readonly fields: hotel_policiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hotel_policies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hotel_policiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends hotelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, hotelsDefaultArgs<ExtArgs>>): Prisma__hotelsClient<$Result.GetResult<Prisma.$hotelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seasons<T extends hotel_policies$seasonsArgs<ExtArgs> = {}>(args?: Subset<T, hotel_policies$seasonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hotel_policies model
   */
  interface hotel_policiesFieldRefs {
    readonly id: FieldRef<"hotel_policies", 'Int'>
    readonly cancellation: FieldRef<"hotel_policies", 'String'>
    readonly payment_terms: FieldRef<"hotel_policies", 'String'>
    readonly commission_terms: FieldRef<"hotel_policies", 'String'>
    readonly hotel_id: FieldRef<"hotel_policies", 'Int'>
    readonly deleted_at: FieldRef<"hotel_policies", 'DateTime'>
    readonly created_at: FieldRef<"hotel_policies", 'DateTime'>
    readonly status: FieldRef<"hotel_policies", 'shared_status'>
    readonly updated_at: FieldRef<"hotel_policies", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * hotel_policies findUnique
   */
  export type hotel_policiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotel_policies
     */
    select?: hotel_policiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotel_policies
     */
    omit?: hotel_policiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotel_policiesInclude<ExtArgs> | null
    /**
     * Filter, which hotel_policies to fetch.
     */
    where: hotel_policiesWhereUniqueInput
  }

  /**
   * hotel_policies findUniqueOrThrow
   */
  export type hotel_policiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotel_policies
     */
    select?: hotel_policiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotel_policies
     */
    omit?: hotel_policiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotel_policiesInclude<ExtArgs> | null
    /**
     * Filter, which hotel_policies to fetch.
     */
    where: hotel_policiesWhereUniqueInput
  }

  /**
   * hotel_policies findFirst
   */
  export type hotel_policiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotel_policies
     */
    select?: hotel_policiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotel_policies
     */
    omit?: hotel_policiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotel_policiesInclude<ExtArgs> | null
    /**
     * Filter, which hotel_policies to fetch.
     */
    where?: hotel_policiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotel_policies to fetch.
     */
    orderBy?: hotel_policiesOrderByWithRelationInput | hotel_policiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hotel_policies.
     */
    cursor?: hotel_policiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotel_policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotel_policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hotel_policies.
     */
    distinct?: Hotel_policiesScalarFieldEnum | Hotel_policiesScalarFieldEnum[]
  }

  /**
   * hotel_policies findFirstOrThrow
   */
  export type hotel_policiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotel_policies
     */
    select?: hotel_policiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotel_policies
     */
    omit?: hotel_policiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotel_policiesInclude<ExtArgs> | null
    /**
     * Filter, which hotel_policies to fetch.
     */
    where?: hotel_policiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotel_policies to fetch.
     */
    orderBy?: hotel_policiesOrderByWithRelationInput | hotel_policiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hotel_policies.
     */
    cursor?: hotel_policiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotel_policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotel_policies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hotel_policies.
     */
    distinct?: Hotel_policiesScalarFieldEnum | Hotel_policiesScalarFieldEnum[]
  }

  /**
   * hotel_policies findMany
   */
  export type hotel_policiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotel_policies
     */
    select?: hotel_policiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotel_policies
     */
    omit?: hotel_policiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotel_policiesInclude<ExtArgs> | null
    /**
     * Filter, which hotel_policies to fetch.
     */
    where?: hotel_policiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotel_policies to fetch.
     */
    orderBy?: hotel_policiesOrderByWithRelationInput | hotel_policiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hotel_policies.
     */
    cursor?: hotel_policiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotel_policies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotel_policies.
     */
    skip?: number
    distinct?: Hotel_policiesScalarFieldEnum | Hotel_policiesScalarFieldEnum[]
  }

  /**
   * hotel_policies create
   */
  export type hotel_policiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotel_policies
     */
    select?: hotel_policiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotel_policies
     */
    omit?: hotel_policiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotel_policiesInclude<ExtArgs> | null
    /**
     * The data needed to create a hotel_policies.
     */
    data: XOR<hotel_policiesCreateInput, hotel_policiesUncheckedCreateInput>
  }

  /**
   * hotel_policies createMany
   */
  export type hotel_policiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hotel_policies.
     */
    data: hotel_policiesCreateManyInput | hotel_policiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hotel_policies update
   */
  export type hotel_policiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotel_policies
     */
    select?: hotel_policiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotel_policies
     */
    omit?: hotel_policiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotel_policiesInclude<ExtArgs> | null
    /**
     * The data needed to update a hotel_policies.
     */
    data: XOR<hotel_policiesUpdateInput, hotel_policiesUncheckedUpdateInput>
    /**
     * Choose, which hotel_policies to update.
     */
    where: hotel_policiesWhereUniqueInput
  }

  /**
   * hotel_policies updateMany
   */
  export type hotel_policiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hotel_policies.
     */
    data: XOR<hotel_policiesUpdateManyMutationInput, hotel_policiesUncheckedUpdateManyInput>
    /**
     * Filter which hotel_policies to update
     */
    where?: hotel_policiesWhereInput
    /**
     * Limit how many hotel_policies to update.
     */
    limit?: number
  }

  /**
   * hotel_policies upsert
   */
  export type hotel_policiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotel_policies
     */
    select?: hotel_policiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotel_policies
     */
    omit?: hotel_policiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotel_policiesInclude<ExtArgs> | null
    /**
     * The filter to search for the hotel_policies to update in case it exists.
     */
    where: hotel_policiesWhereUniqueInput
    /**
     * In case the hotel_policies found by the `where` argument doesn't exist, create a new hotel_policies with this data.
     */
    create: XOR<hotel_policiesCreateInput, hotel_policiesUncheckedCreateInput>
    /**
     * In case the hotel_policies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hotel_policiesUpdateInput, hotel_policiesUncheckedUpdateInput>
  }

  /**
   * hotel_policies delete
   */
  export type hotel_policiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotel_policies
     */
    select?: hotel_policiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotel_policies
     */
    omit?: hotel_policiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotel_policiesInclude<ExtArgs> | null
    /**
     * Filter which hotel_policies to delete.
     */
    where: hotel_policiesWhereUniqueInput
  }

  /**
   * hotel_policies deleteMany
   */
  export type hotel_policiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hotel_policies to delete
     */
    where?: hotel_policiesWhereInput
    /**
     * Limit how many hotel_policies to delete.
     */
    limit?: number
  }

  /**
   * hotel_policies.seasons
   */
  export type hotel_policies$seasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seasons
     */
    omit?: seasonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    where?: seasonsWhereInput
    orderBy?: seasonsOrderByWithRelationInput | seasonsOrderByWithRelationInput[]
    cursor?: seasonsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SeasonsScalarFieldEnum | SeasonsScalarFieldEnum[]
  }

  /**
   * hotel_policies without action
   */
  export type hotel_policiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotel_policies
     */
    select?: hotel_policiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotel_policies
     */
    omit?: hotel_policiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotel_policiesInclude<ExtArgs> | null
  }


  /**
   * Model hotels
   */

  export type AggregateHotels = {
    _count: HotelsCountAggregateOutputType | null
    _avg: HotelsAvgAggregateOutputType | null
    _sum: HotelsSumAggregateOutputType | null
    _min: HotelsMinAggregateOutputType | null
    _max: HotelsMaxAggregateOutputType | null
  }

  export type HotelsAvgAggregateOutputType = {
    id: number | null
    commission_rate: number | null
  }

  export type HotelsSumAggregateOutputType = {
    id: number | null
    commission_rate: number | null
  }

  export type HotelsMinAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    contact_email: string | null
    contact_phone: string | null
    commission_rate: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status | null
    enc_phone: string | null
  }

  export type HotelsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    contact_email: string | null
    contact_phone: string | null
    commission_rate: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status | null
    enc_phone: string | null
  }

  export type HotelsCountAggregateOutputType = {
    id: number
    name: number
    location: number
    contact_email: number
    contact_phone: number
    commission_rate: number
    created_at: number
    updated_at: number
    deleted_at: number
    status: number
    enc_phone: number
    _all: number
  }


  export type HotelsAvgAggregateInputType = {
    id?: true
    commission_rate?: true
  }

  export type HotelsSumAggregateInputType = {
    id?: true
    commission_rate?: true
  }

  export type HotelsMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    contact_email?: true
    contact_phone?: true
    commission_rate?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
    enc_phone?: true
  }

  export type HotelsMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    contact_email?: true
    contact_phone?: true
    commission_rate?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
    enc_phone?: true
  }

  export type HotelsCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    contact_email?: true
    contact_phone?: true
    commission_rate?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
    enc_phone?: true
    _all?: true
  }

  export type HotelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hotels to aggregate.
     */
    where?: hotelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotels to fetch.
     */
    orderBy?: hotelsOrderByWithRelationInput | hotelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hotelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hotels
    **/
    _count?: true | HotelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelsMaxAggregateInputType
  }

  export type GetHotelsAggregateType<T extends HotelsAggregateArgs> = {
        [P in keyof T & keyof AggregateHotels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotels[P]>
      : GetScalarType<T[P], AggregateHotels[P]>
  }




  export type hotelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hotelsWhereInput
    orderBy?: hotelsOrderByWithAggregationInput | hotelsOrderByWithAggregationInput[]
    by: HotelsScalarFieldEnum[] | HotelsScalarFieldEnum
    having?: hotelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelsCountAggregateInputType | true
    _avg?: HotelsAvgAggregateInputType
    _sum?: HotelsSumAggregateInputType
    _min?: HotelsMinAggregateInputType
    _max?: HotelsMaxAggregateInputType
  }

  export type HotelsGroupByOutputType = {
    id: number
    name: string
    location: string
    contact_email: string
    contact_phone: string
    commission_rate: number | null
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status
    enc_phone: string
    _count: HotelsCountAggregateOutputType | null
    _avg: HotelsAvgAggregateOutputType | null
    _sum: HotelsSumAggregateOutputType | null
    _min: HotelsMinAggregateOutputType | null
    _max: HotelsMaxAggregateOutputType | null
  }

  type GetHotelsGroupByPayload<T extends hotelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelsGroupByOutputType[P]>
            : GetScalarType<T[P], HotelsGroupByOutputType[P]>
        }
      >
    >


  export type hotelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    contact_email?: boolean
    contact_phone?: boolean
    commission_rate?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    status?: boolean
    enc_phone?: boolean
    bookings?: boolean | hotels$bookingsArgs<ExtArgs>
    hotel_policies?: boolean | hotels$hotel_policiesArgs<ExtArgs>
    rack_rates?: boolean | hotels$rack_ratesArgs<ExtArgs>
    rate_cards?: boolean | hotels$rate_cardsArgs<ExtArgs>
    _count?: boolean | HotelsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotels"]>



  export type hotelsSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    contact_email?: boolean
    contact_phone?: boolean
    commission_rate?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    status?: boolean
    enc_phone?: boolean
  }

  export type hotelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "contact_email" | "contact_phone" | "commission_rate" | "created_at" | "updated_at" | "deleted_at" | "status" | "enc_phone", ExtArgs["result"]["hotels"]>
  export type hotelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | hotels$bookingsArgs<ExtArgs>
    hotel_policies?: boolean | hotels$hotel_policiesArgs<ExtArgs>
    rack_rates?: boolean | hotels$rack_ratesArgs<ExtArgs>
    rate_cards?: boolean | hotels$rate_cardsArgs<ExtArgs>
    _count?: boolean | HotelsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $hotelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hotels"
    objects: {
      bookings: Prisma.$bookingsPayload<ExtArgs>[]
      hotel_policies: Prisma.$hotel_policiesPayload<ExtArgs>[]
      rack_rates: Prisma.$rack_ratesPayload<ExtArgs>[]
      rate_cards: Prisma.$rate_cardsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      location: string
      contact_email: string
      contact_phone: string
      commission_rate: number | null
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
      status: $Enums.shared_status
      enc_phone: string
    }, ExtArgs["result"]["hotels"]>
    composites: {}
  }

  type hotelsGetPayload<S extends boolean | null | undefined | hotelsDefaultArgs> = $Result.GetResult<Prisma.$hotelsPayload, S>

  type hotelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<hotelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HotelsCountAggregateInputType | true
    }

  export interface hotelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hotels'], meta: { name: 'hotels' } }
    /**
     * Find zero or one Hotels that matches the filter.
     * @param {hotelsFindUniqueArgs} args - Arguments to find a Hotels
     * @example
     * // Get one Hotels
     * const hotels = await prisma.hotels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends hotelsFindUniqueArgs>(args: SelectSubset<T, hotelsFindUniqueArgs<ExtArgs>>): Prisma__hotelsClient<$Result.GetResult<Prisma.$hotelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Hotels that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {hotelsFindUniqueOrThrowArgs} args - Arguments to find a Hotels
     * @example
     * // Get one Hotels
     * const hotels = await prisma.hotels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends hotelsFindUniqueOrThrowArgs>(args: SelectSubset<T, hotelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__hotelsClient<$Result.GetResult<Prisma.$hotelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotelsFindFirstArgs} args - Arguments to find a Hotels
     * @example
     * // Get one Hotels
     * const hotels = await prisma.hotels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends hotelsFindFirstArgs>(args?: SelectSubset<T, hotelsFindFirstArgs<ExtArgs>>): Prisma__hotelsClient<$Result.GetResult<Prisma.$hotelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Hotels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotelsFindFirstOrThrowArgs} args - Arguments to find a Hotels
     * @example
     * // Get one Hotels
     * const hotels = await prisma.hotels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends hotelsFindFirstOrThrowArgs>(args?: SelectSubset<T, hotelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__hotelsClient<$Result.GetResult<Prisma.$hotelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Hotels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hotels
     * const hotels = await prisma.hotels.findMany()
     * 
     * // Get first 10 Hotels
     * const hotels = await prisma.hotels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelsWithIdOnly = await prisma.hotels.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends hotelsFindManyArgs>(args?: SelectSubset<T, hotelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hotelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Hotels.
     * @param {hotelsCreateArgs} args - Arguments to create a Hotels.
     * @example
     * // Create one Hotels
     * const Hotels = await prisma.hotels.create({
     *   data: {
     *     // ... data to create a Hotels
     *   }
     * })
     * 
     */
    create<T extends hotelsCreateArgs>(args: SelectSubset<T, hotelsCreateArgs<ExtArgs>>): Prisma__hotelsClient<$Result.GetResult<Prisma.$hotelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Hotels.
     * @param {hotelsCreateManyArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotels = await prisma.hotels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends hotelsCreateManyArgs>(args?: SelectSubset<T, hotelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hotels.
     * @param {hotelsDeleteArgs} args - Arguments to delete one Hotels.
     * @example
     * // Delete one Hotels
     * const Hotels = await prisma.hotels.delete({
     *   where: {
     *     // ... filter to delete one Hotels
     *   }
     * })
     * 
     */
    delete<T extends hotelsDeleteArgs>(args: SelectSubset<T, hotelsDeleteArgs<ExtArgs>>): Prisma__hotelsClient<$Result.GetResult<Prisma.$hotelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Hotels.
     * @param {hotelsUpdateArgs} args - Arguments to update one Hotels.
     * @example
     * // Update one Hotels
     * const hotels = await prisma.hotels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends hotelsUpdateArgs>(args: SelectSubset<T, hotelsUpdateArgs<ExtArgs>>): Prisma__hotelsClient<$Result.GetResult<Prisma.$hotelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Hotels.
     * @param {hotelsDeleteManyArgs} args - Arguments to filter Hotels to delete.
     * @example
     * // Delete a few Hotels
     * const { count } = await prisma.hotels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends hotelsDeleteManyArgs>(args?: SelectSubset<T, hotelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hotels
     * const hotels = await prisma.hotels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends hotelsUpdateManyArgs>(args: SelectSubset<T, hotelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hotels.
     * @param {hotelsUpsertArgs} args - Arguments to update or create a Hotels.
     * @example
     * // Update or create a Hotels
     * const hotels = await prisma.hotels.upsert({
     *   create: {
     *     // ... data to create a Hotels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hotels we want to update
     *   }
     * })
     */
    upsert<T extends hotelsUpsertArgs>(args: SelectSubset<T, hotelsUpsertArgs<ExtArgs>>): Prisma__hotelsClient<$Result.GetResult<Prisma.$hotelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotelsCountArgs} args - Arguments to filter Hotels to count.
     * @example
     * // Count the number of Hotels
     * const count = await prisma.hotels.count({
     *   where: {
     *     // ... the filter for the Hotels we want to count
     *   }
     * })
    **/
    count<T extends hotelsCountArgs>(
      args?: Subset<T, hotelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelsAggregateArgs>(args: Subset<T, HotelsAggregateArgs>): Prisma.PrismaPromise<GetHotelsAggregateType<T>>

    /**
     * Group by Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hotelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hotelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hotelsGroupByArgs['orderBy'] }
        : { orderBy?: hotelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hotelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hotels model
   */
  readonly fields: hotelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hotels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hotelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends hotels$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, hotels$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    hotel_policies<T extends hotels$hotel_policiesArgs<ExtArgs> = {}>(args?: Subset<T, hotels$hotel_policiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hotel_policiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rack_rates<T extends hotels$rack_ratesArgs<ExtArgs> = {}>(args?: Subset<T, hotels$rack_ratesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rack_ratesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rate_cards<T extends hotels$rate_cardsArgs<ExtArgs> = {}>(args?: Subset<T, hotels$rate_cardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rate_cardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the hotels model
   */
  interface hotelsFieldRefs {
    readonly id: FieldRef<"hotels", 'Int'>
    readonly name: FieldRef<"hotels", 'String'>
    readonly location: FieldRef<"hotels", 'String'>
    readonly contact_email: FieldRef<"hotels", 'String'>
    readonly contact_phone: FieldRef<"hotels", 'String'>
    readonly commission_rate: FieldRef<"hotels", 'Float'>
    readonly created_at: FieldRef<"hotels", 'DateTime'>
    readonly updated_at: FieldRef<"hotels", 'DateTime'>
    readonly deleted_at: FieldRef<"hotels", 'DateTime'>
    readonly status: FieldRef<"hotels", 'shared_status'>
    readonly enc_phone: FieldRef<"hotels", 'String'>
  }
    

  // Custom InputTypes
  /**
   * hotels findUnique
   */
  export type hotelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotels
     */
    select?: hotelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotels
     */
    omit?: hotelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotelsInclude<ExtArgs> | null
    /**
     * Filter, which hotels to fetch.
     */
    where: hotelsWhereUniqueInput
  }

  /**
   * hotels findUniqueOrThrow
   */
  export type hotelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotels
     */
    select?: hotelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotels
     */
    omit?: hotelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotelsInclude<ExtArgs> | null
    /**
     * Filter, which hotels to fetch.
     */
    where: hotelsWhereUniqueInput
  }

  /**
   * hotels findFirst
   */
  export type hotelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotels
     */
    select?: hotelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotels
     */
    omit?: hotelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotelsInclude<ExtArgs> | null
    /**
     * Filter, which hotels to fetch.
     */
    where?: hotelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotels to fetch.
     */
    orderBy?: hotelsOrderByWithRelationInput | hotelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hotels.
     */
    cursor?: hotelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hotels.
     */
    distinct?: HotelsScalarFieldEnum | HotelsScalarFieldEnum[]
  }

  /**
   * hotels findFirstOrThrow
   */
  export type hotelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotels
     */
    select?: hotelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotels
     */
    omit?: hotelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotelsInclude<ExtArgs> | null
    /**
     * Filter, which hotels to fetch.
     */
    where?: hotelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotels to fetch.
     */
    orderBy?: hotelsOrderByWithRelationInput | hotelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hotels.
     */
    cursor?: hotelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hotels.
     */
    distinct?: HotelsScalarFieldEnum | HotelsScalarFieldEnum[]
  }

  /**
   * hotels findMany
   */
  export type hotelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotels
     */
    select?: hotelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotels
     */
    omit?: hotelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotelsInclude<ExtArgs> | null
    /**
     * Filter, which hotels to fetch.
     */
    where?: hotelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hotels to fetch.
     */
    orderBy?: hotelsOrderByWithRelationInput | hotelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hotels.
     */
    cursor?: hotelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hotels.
     */
    skip?: number
    distinct?: HotelsScalarFieldEnum | HotelsScalarFieldEnum[]
  }

  /**
   * hotels create
   */
  export type hotelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotels
     */
    select?: hotelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotels
     */
    omit?: hotelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotelsInclude<ExtArgs> | null
    /**
     * The data needed to create a hotels.
     */
    data: XOR<hotelsCreateInput, hotelsUncheckedCreateInput>
  }

  /**
   * hotels createMany
   */
  export type hotelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hotels.
     */
    data: hotelsCreateManyInput | hotelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * hotels update
   */
  export type hotelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotels
     */
    select?: hotelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotels
     */
    omit?: hotelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotelsInclude<ExtArgs> | null
    /**
     * The data needed to update a hotels.
     */
    data: XOR<hotelsUpdateInput, hotelsUncheckedUpdateInput>
    /**
     * Choose, which hotels to update.
     */
    where: hotelsWhereUniqueInput
  }

  /**
   * hotels updateMany
   */
  export type hotelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hotels.
     */
    data: XOR<hotelsUpdateManyMutationInput, hotelsUncheckedUpdateManyInput>
    /**
     * Filter which hotels to update
     */
    where?: hotelsWhereInput
    /**
     * Limit how many hotels to update.
     */
    limit?: number
  }

  /**
   * hotels upsert
   */
  export type hotelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotels
     */
    select?: hotelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotels
     */
    omit?: hotelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotelsInclude<ExtArgs> | null
    /**
     * The filter to search for the hotels to update in case it exists.
     */
    where: hotelsWhereUniqueInput
    /**
     * In case the hotels found by the `where` argument doesn't exist, create a new hotels with this data.
     */
    create: XOR<hotelsCreateInput, hotelsUncheckedCreateInput>
    /**
     * In case the hotels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hotelsUpdateInput, hotelsUncheckedUpdateInput>
  }

  /**
   * hotels delete
   */
  export type hotelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotels
     */
    select?: hotelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotels
     */
    omit?: hotelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotelsInclude<ExtArgs> | null
    /**
     * Filter which hotels to delete.
     */
    where: hotelsWhereUniqueInput
  }

  /**
   * hotels deleteMany
   */
  export type hotelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hotels to delete
     */
    where?: hotelsWhereInput
    /**
     * Limit how many hotels to delete.
     */
    limit?: number
  }

  /**
   * hotels.bookings
   */
  export type hotels$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    where?: bookingsWhereInput
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    cursor?: bookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * hotels.hotel_policies
   */
  export type hotels$hotel_policiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotel_policies
     */
    select?: hotel_policiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotel_policies
     */
    omit?: hotel_policiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotel_policiesInclude<ExtArgs> | null
    where?: hotel_policiesWhereInput
    orderBy?: hotel_policiesOrderByWithRelationInput | hotel_policiesOrderByWithRelationInput[]
    cursor?: hotel_policiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Hotel_policiesScalarFieldEnum | Hotel_policiesScalarFieldEnum[]
  }

  /**
   * hotels.rack_rates
   */
  export type hotels$rack_ratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rack_rates
     */
    select?: rack_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rack_rates
     */
    omit?: rack_ratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rack_ratesInclude<ExtArgs> | null
    where?: rack_ratesWhereInput
    orderBy?: rack_ratesOrderByWithRelationInput | rack_ratesOrderByWithRelationInput[]
    cursor?: rack_ratesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Rack_ratesScalarFieldEnum | Rack_ratesScalarFieldEnum[]
  }

  /**
   * hotels.rate_cards
   */
  export type hotels$rate_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate_cards
     */
    select?: rate_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate_cards
     */
    omit?: rate_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rate_cardsInclude<ExtArgs> | null
    where?: rate_cardsWhereInput
    orderBy?: rate_cardsOrderByWithRelationInput | rate_cardsOrderByWithRelationInput[]
    cursor?: rate_cardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Rate_cardsScalarFieldEnum | Rate_cardsScalarFieldEnum[]
  }

  /**
   * hotels without action
   */
  export type hotelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hotels
     */
    select?: hotelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the hotels
     */
    omit?: hotelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: hotelsInclude<ExtArgs> | null
  }


  /**
   * Model invoices
   */

  export type AggregateInvoices = {
    _count: InvoicesCountAggregateOutputType | null
    _avg: InvoicesAvgAggregateOutputType | null
    _sum: InvoicesSumAggregateOutputType | null
    _min: InvoicesMinAggregateOutputType | null
    _max: InvoicesMaxAggregateOutputType | null
  }

  export type InvoicesAvgAggregateOutputType = {
    id: number | null
    quote_id: number | null
    client_id: number | null
    amount: number | null
    tax_amount: number | null
    total_amount: number | null
  }

  export type InvoicesSumAggregateOutputType = {
    id: number | null
    quote_id: number | null
    client_id: number | null
    amount: number | null
    tax_amount: number | null
    total_amount: number | null
  }

  export type InvoicesMinAggregateOutputType = {
    id: number | null
    invoice_number: string | null
    quote_id: number | null
    client_id: number | null
    amount: number | null
    tax_amount: number | null
    total_amount: number | null
    due_date: Date | null
    status: $Enums.invoices_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string | null
  }

  export type InvoicesMaxAggregateOutputType = {
    id: number | null
    invoice_number: string | null
    quote_id: number | null
    client_id: number | null
    amount: number | null
    tax_amount: number | null
    total_amount: number | null
    due_date: Date | null
    status: $Enums.invoices_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string | null
  }

  export type InvoicesCountAggregateOutputType = {
    id: number
    invoice_number: number
    quote_id: number
    client_id: number
    amount: number
    tax_amount: number
    total_amount: number
    due_date: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    public_id: number
    _all: number
  }


  export type InvoicesAvgAggregateInputType = {
    id?: true
    quote_id?: true
    client_id?: true
    amount?: true
    tax_amount?: true
    total_amount?: true
  }

  export type InvoicesSumAggregateInputType = {
    id?: true
    quote_id?: true
    client_id?: true
    amount?: true
    tax_amount?: true
    total_amount?: true
  }

  export type InvoicesMinAggregateInputType = {
    id?: true
    invoice_number?: true
    quote_id?: true
    client_id?: true
    amount?: true
    tax_amount?: true
    total_amount?: true
    due_date?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
  }

  export type InvoicesMaxAggregateInputType = {
    id?: true
    invoice_number?: true
    quote_id?: true
    client_id?: true
    amount?: true
    tax_amount?: true
    total_amount?: true
    due_date?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
  }

  export type InvoicesCountAggregateInputType = {
    id?: true
    invoice_number?: true
    quote_id?: true
    client_id?: true
    amount?: true
    tax_amount?: true
    total_amount?: true
    due_date?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
    _all?: true
  }

  export type InvoicesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoices to aggregate.
     */
    where?: invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invoices
    **/
    _count?: true | InvoicesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoicesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoicesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoicesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoicesMaxAggregateInputType
  }

  export type GetInvoicesAggregateType<T extends InvoicesAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoices[P]>
      : GetScalarType<T[P], AggregateInvoices[P]>
  }




  export type invoicesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invoicesWhereInput
    orderBy?: invoicesOrderByWithAggregationInput | invoicesOrderByWithAggregationInput[]
    by: InvoicesScalarFieldEnum[] | InvoicesScalarFieldEnum
    having?: invoicesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoicesCountAggregateInputType | true
    _avg?: InvoicesAvgAggregateInputType
    _sum?: InvoicesSumAggregateInputType
    _min?: InvoicesMinAggregateInputType
    _max?: InvoicesMaxAggregateInputType
  }

  export type InvoicesGroupByOutputType = {
    id: number
    invoice_number: string
    quote_id: number
    client_id: number
    amount: number
    tax_amount: number
    total_amount: number
    due_date: Date
    status: $Enums.invoices_status
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string
    _count: InvoicesCountAggregateOutputType | null
    _avg: InvoicesAvgAggregateOutputType | null
    _sum: InvoicesSumAggregateOutputType | null
    _min: InvoicesMinAggregateOutputType | null
    _max: InvoicesMaxAggregateOutputType | null
  }

  type GetInvoicesGroupByPayload<T extends invoicesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoicesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoicesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
            : GetScalarType<T[P], InvoicesGroupByOutputType[P]>
        }
      >
    >


  export type invoicesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_number?: boolean
    quote_id?: boolean
    client_id?: boolean
    amount?: boolean
    tax_amount?: boolean
    total_amount?: boolean
    due_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    public_id?: boolean
    booking?: boolean | invoices$bookingArgs<ExtArgs>
    client?: boolean | clientsDefaultArgs<ExtArgs>
    quote?: boolean | quotesDefaultArgs<ExtArgs>
    payments?: boolean | invoices$paymentsArgs<ExtArgs>
    reminders?: boolean | invoices$remindersArgs<ExtArgs>
    users?: boolean | invoices$usersArgs<ExtArgs>
    _count?: boolean | InvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoices"]>



  export type invoicesSelectScalar = {
    id?: boolean
    invoice_number?: boolean
    quote_id?: boolean
    client_id?: boolean
    amount?: boolean
    tax_amount?: boolean
    total_amount?: boolean
    due_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    public_id?: boolean
  }

  export type invoicesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_number" | "quote_id" | "client_id" | "amount" | "tax_amount" | "total_amount" | "due_date" | "status" | "created_at" | "updated_at" | "deleted_at" | "public_id", ExtArgs["result"]["invoices"]>
  export type invoicesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | invoices$bookingArgs<ExtArgs>
    client?: boolean | clientsDefaultArgs<ExtArgs>
    quote?: boolean | quotesDefaultArgs<ExtArgs>
    payments?: boolean | invoices$paymentsArgs<ExtArgs>
    reminders?: boolean | invoices$remindersArgs<ExtArgs>
    users?: boolean | invoices$usersArgs<ExtArgs>
    _count?: boolean | InvoicesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $invoicesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invoices"
    objects: {
      booking: Prisma.$bookingsPayload<ExtArgs> | null
      client: Prisma.$clientsPayload<ExtArgs>
      quote: Prisma.$quotesPayload<ExtArgs>
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      reminders: Prisma.$remindersPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoice_number: string
      quote_id: number
      client_id: number
      amount: number
      tax_amount: number
      total_amount: number
      due_date: Date
      status: $Enums.invoices_status
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
      public_id: string
    }, ExtArgs["result"]["invoices"]>
    composites: {}
  }

  type invoicesGetPayload<S extends boolean | null | undefined | invoicesDefaultArgs> = $Result.GetResult<Prisma.$invoicesPayload, S>

  type invoicesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<invoicesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoicesCountAggregateInputType | true
    }

  export interface invoicesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invoices'], meta: { name: 'invoices' } }
    /**
     * Find zero or one Invoices that matches the filter.
     * @param {invoicesFindUniqueArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invoicesFindUniqueArgs>(args: SelectSubset<T, invoicesFindUniqueArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {invoicesFindUniqueOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invoicesFindUniqueOrThrowArgs>(args: SelectSubset<T, invoicesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesFindFirstArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invoicesFindFirstArgs>(args?: SelectSubset<T, invoicesFindFirstArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesFindFirstOrThrowArgs} args - Arguments to find a Invoices
     * @example
     * // Get one Invoices
     * const invoices = await prisma.invoices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invoicesFindFirstOrThrowArgs>(args?: SelectSubset<T, invoicesFindFirstOrThrowArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoices.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoicesWithIdOnly = await prisma.invoices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invoicesFindManyArgs>(args?: SelectSubset<T, invoicesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoices.
     * @param {invoicesCreateArgs} args - Arguments to create a Invoices.
     * @example
     * // Create one Invoices
     * const Invoices = await prisma.invoices.create({
     *   data: {
     *     // ... data to create a Invoices
     *   }
     * })
     * 
     */
    create<T extends invoicesCreateArgs>(args: SelectSubset<T, invoicesCreateArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {invoicesCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoices = await prisma.invoices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invoicesCreateManyArgs>(args?: SelectSubset<T, invoicesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoices.
     * @param {invoicesDeleteArgs} args - Arguments to delete one Invoices.
     * @example
     * // Delete one Invoices
     * const Invoices = await prisma.invoices.delete({
     *   where: {
     *     // ... filter to delete one Invoices
     *   }
     * })
     * 
     */
    delete<T extends invoicesDeleteArgs>(args: SelectSubset<T, invoicesDeleteArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoices.
     * @param {invoicesUpdateArgs} args - Arguments to update one Invoices.
     * @example
     * // Update one Invoices
     * const invoices = await prisma.invoices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invoicesUpdateArgs>(args: SelectSubset<T, invoicesUpdateArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {invoicesDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invoicesDeleteManyArgs>(args?: SelectSubset<T, invoicesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoices = await prisma.invoices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invoicesUpdateManyArgs>(args: SelectSubset<T, invoicesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoices.
     * @param {invoicesUpsertArgs} args - Arguments to update or create a Invoices.
     * @example
     * // Update or create a Invoices
     * const invoices = await prisma.invoices.upsert({
     *   create: {
     *     // ... data to create a Invoices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoices we want to update
     *   }
     * })
     */
    upsert<T extends invoicesUpsertArgs>(args: SelectSubset<T, invoicesUpsertArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoices.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends invoicesCountArgs>(
      args?: Subset<T, invoicesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoicesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoicesAggregateArgs>(args: Subset<T, InvoicesAggregateArgs>): Prisma.PrismaPromise<GetInvoicesAggregateType<T>>

    /**
     * Group by Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invoicesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invoicesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invoicesGroupByArgs['orderBy'] }
        : { orderBy?: invoicesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invoicesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoicesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invoices model
   */
  readonly fields: invoicesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invoices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invoicesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends invoices$bookingArgs<ExtArgs> = {}>(args?: Subset<T, invoices$bookingArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends clientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clientsDefaultArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quote<T extends quotesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, quotesDefaultArgs<ExtArgs>>): Prisma__quotesClient<$Result.GetResult<Prisma.$quotesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends invoices$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, invoices$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reminders<T extends invoices$remindersArgs<ExtArgs> = {}>(args?: Subset<T, invoices$remindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$remindersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends invoices$usersArgs<ExtArgs> = {}>(args?: Subset<T, invoices$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invoices model
   */
  interface invoicesFieldRefs {
    readonly id: FieldRef<"invoices", 'Int'>
    readonly invoice_number: FieldRef<"invoices", 'String'>
    readonly quote_id: FieldRef<"invoices", 'Int'>
    readonly client_id: FieldRef<"invoices", 'Int'>
    readonly amount: FieldRef<"invoices", 'Float'>
    readonly tax_amount: FieldRef<"invoices", 'Float'>
    readonly total_amount: FieldRef<"invoices", 'Float'>
    readonly due_date: FieldRef<"invoices", 'DateTime'>
    readonly status: FieldRef<"invoices", 'invoices_status'>
    readonly created_at: FieldRef<"invoices", 'DateTime'>
    readonly updated_at: FieldRef<"invoices", 'DateTime'>
    readonly deleted_at: FieldRef<"invoices", 'DateTime'>
    readonly public_id: FieldRef<"invoices", 'String'>
  }
    

  // Custom InputTypes
  /**
   * invoices findUnique
   */
  export type invoicesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where: invoicesWhereUniqueInput
  }

  /**
   * invoices findUniqueOrThrow
   */
  export type invoicesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where: invoicesWhereUniqueInput
  }

  /**
   * invoices findFirst
   */
  export type invoicesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where?: invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoices.
     */
    cursor?: invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoices.
     */
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * invoices findFirstOrThrow
   */
  export type invoicesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where?: invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invoices.
     */
    cursor?: invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invoices.
     */
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * invoices findMany
   */
  export type invoicesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter, which invoices to fetch.
     */
    where?: invoicesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invoices to fetch.
     */
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invoices.
     */
    cursor?: invoicesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invoices.
     */
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * invoices create
   */
  export type invoicesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * The data needed to create a invoices.
     */
    data: XOR<invoicesCreateInput, invoicesUncheckedCreateInput>
  }

  /**
   * invoices createMany
   */
  export type invoicesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invoices.
     */
    data: invoicesCreateManyInput | invoicesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invoices update
   */
  export type invoicesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * The data needed to update a invoices.
     */
    data: XOR<invoicesUpdateInput, invoicesUncheckedUpdateInput>
    /**
     * Choose, which invoices to update.
     */
    where: invoicesWhereUniqueInput
  }

  /**
   * invoices updateMany
   */
  export type invoicesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invoices.
     */
    data: XOR<invoicesUpdateManyMutationInput, invoicesUncheckedUpdateManyInput>
    /**
     * Filter which invoices to update
     */
    where?: invoicesWhereInput
    /**
     * Limit how many invoices to update.
     */
    limit?: number
  }

  /**
   * invoices upsert
   */
  export type invoicesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * The filter to search for the invoices to update in case it exists.
     */
    where: invoicesWhereUniqueInput
    /**
     * In case the invoices found by the `where` argument doesn't exist, create a new invoices with this data.
     */
    create: XOR<invoicesCreateInput, invoicesUncheckedCreateInput>
    /**
     * In case the invoices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invoicesUpdateInput, invoicesUncheckedUpdateInput>
  }

  /**
   * invoices delete
   */
  export type invoicesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    /**
     * Filter which invoices to delete.
     */
    where: invoicesWhereUniqueInput
  }

  /**
   * invoices deleteMany
   */
  export type invoicesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invoices to delete
     */
    where?: invoicesWhereInput
    /**
     * Limit how many invoices to delete.
     */
    limit?: number
  }

  /**
   * invoices.booking
   */
  export type invoices$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    where?: bookingsWhereInput
  }

  /**
   * invoices.payments
   */
  export type invoices$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * invoices.reminders
   */
  export type invoices$remindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reminders
     */
    omit?: remindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: remindersInclude<ExtArgs> | null
    where?: remindersWhereInput
    orderBy?: remindersOrderByWithRelationInput | remindersOrderByWithRelationInput[]
    cursor?: remindersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RemindersScalarFieldEnum | RemindersScalarFieldEnum[]
  }

  /**
   * invoices.users
   */
  export type invoices$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * invoices without action
   */
  export type invoicesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    reference_id: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    reference_id: number | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    title: string | null
    message: string | null
    is_read: boolean | null
    read_at: Date | null
    type: $Enums.notifications_type | null
    reference_id: number | null
    reference_type: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    title: string | null
    message: string | null
    is_read: boolean | null
    read_at: Date | null
    type: $Enums.notifications_type | null
    reference_id: number | null
    reference_type: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    user_id: number
    title: number
    message: number
    is_read: number
    read_at: number
    type: number
    reference_id: number
    reference_type: number
    created_at: number
    updated_at: number
    deleted_at: number
    status: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    id?: true
    user_id?: true
    reference_id?: true
  }

  export type NotificationsSumAggregateInputType = {
    id?: true
    user_id?: true
    reference_id?: true
  }

  export type NotificationsMinAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    message?: true
    is_read?: true
    read_at?: true
    type?: true
    reference_id?: true
    reference_type?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    message?: true
    is_read?: true
    read_at?: true
    type?: true
    reference_id?: true
    reference_type?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    message?: true
    is_read?: true
    read_at?: true
    type?: true
    reference_id?: true
    reference_type?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: number
    user_id: number
    title: string
    message: string
    is_read: boolean
    read_at: Date | null
    type: $Enums.notifications_type
    reference_id: number | null
    reference_type: string | null
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    message?: boolean
    is_read?: boolean
    read_at?: boolean
    type?: boolean
    reference_id?: boolean
    reference_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    status?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>



  export type notificationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    title?: boolean
    message?: boolean
    is_read?: boolean
    read_at?: boolean
    type?: boolean
    reference_id?: boolean
    reference_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    status?: boolean
  }

  export type notificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "title" | "message" | "is_read" | "read_at" | "type" | "reference_id" | "reference_type" | "created_at" | "updated_at" | "deleted_at" | "status", ExtArgs["result"]["notifications"]>
  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      title: string
      message: string
      is_read: boolean
      read_at: Date | null
      type: $Enums.notifications_type
      reference_id: number | null
      reference_type: string | null
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
      status: $Enums.shared_status
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'Int'>
    readonly user_id: FieldRef<"notifications", 'Int'>
    readonly title: FieldRef<"notifications", 'String'>
    readonly message: FieldRef<"notifications", 'String'>
    readonly is_read: FieldRef<"notifications", 'Boolean'>
    readonly read_at: FieldRef<"notifications", 'DateTime'>
    readonly type: FieldRef<"notifications", 'notifications_type'>
    readonly reference_id: FieldRef<"notifications", 'Int'>
    readonly reference_type: FieldRef<"notifications", 'String'>
    readonly created_at: FieldRef<"notifications", 'DateTime'>
    readonly updated_at: FieldRef<"notifications", 'DateTime'>
    readonly deleted_at: FieldRef<"notifications", 'DateTime'>
    readonly status: FieldRef<"notifications", 'shared_status'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    id: number | null
    invoice_id: number | null
    amount: number | null
  }

  export type PaymentsSumAggregateOutputType = {
    id: number | null
    invoice_id: number | null
    amount: number | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: number | null
    invoice_id: number | null
    amount: number | null
    payment_date: Date | null
    payment_method: $Enums.payments_payment_method | null
    transaction_id: string | null
    receipt_url: string | null
    is_confirmed: boolean | null
    confirmed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string | null
    status: $Enums.shared_status | null
    enc_phone: string | null
    phone: string | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: number | null
    invoice_id: number | null
    amount: number | null
    payment_date: Date | null
    payment_method: $Enums.payments_payment_method | null
    transaction_id: string | null
    receipt_url: string | null
    is_confirmed: boolean | null
    confirmed_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string | null
    status: $Enums.shared_status | null
    enc_phone: string | null
    phone: string | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    invoice_id: number
    amount: number
    payment_date: number
    payment_method: number
    transaction_id: number
    receipt_url: number
    is_confirmed: number
    confirmed_at: number
    created_at: number
    updated_at: number
    deleted_at: number
    public_id: number
    status: number
    enc_phone: number
    phone: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    id?: true
    invoice_id?: true
    amount?: true
  }

  export type PaymentsSumAggregateInputType = {
    id?: true
    invoice_id?: true
    amount?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    invoice_id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    transaction_id?: true
    receipt_url?: true
    is_confirmed?: true
    confirmed_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
    status?: true
    enc_phone?: true
    phone?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    invoice_id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    transaction_id?: true
    receipt_url?: true
    is_confirmed?: true
    confirmed_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
    status?: true
    enc_phone?: true
    phone?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    invoice_id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    transaction_id?: true
    receipt_url?: true
    is_confirmed?: true
    confirmed_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
    status?: true
    enc_phone?: true
    phone?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: number
    invoice_id: number
    amount: number
    payment_date: Date
    payment_method: $Enums.payments_payment_method
    transaction_id: string | null
    receipt_url: string | null
    is_confirmed: boolean
    confirmed_at: Date | null
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string
    status: $Enums.shared_status
    enc_phone: string | null
    phone: string | null
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    receipt_url?: boolean
    is_confirmed?: boolean
    confirmed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    public_id?: boolean
    status?: boolean
    enc_phone?: boolean
    phone?: boolean
    invoice?: boolean | invoicesDefaultArgs<ExtArgs>
    bookings?: boolean | payments$bookingsArgs<ExtArgs>
    _count?: boolean | PaymentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>



  export type paymentsSelectScalar = {
    id?: boolean
    invoice_id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    receipt_url?: boolean
    is_confirmed?: boolean
    confirmed_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    public_id?: boolean
    status?: boolean
    enc_phone?: boolean
    phone?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_id" | "amount" | "payment_date" | "payment_method" | "transaction_id" | "receipt_url" | "is_confirmed" | "confirmed_at" | "created_at" | "updated_at" | "deleted_at" | "public_id" | "status" | "enc_phone" | "phone", ExtArgs["result"]["payments"]>
  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | invoicesDefaultArgs<ExtArgs>
    bookings?: boolean | payments$bookingsArgs<ExtArgs>
    _count?: boolean | PaymentsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      invoice: Prisma.$invoicesPayload<ExtArgs>
      bookings: Prisma.$bookingsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoice_id: number
      amount: number
      payment_date: Date
      payment_method: $Enums.payments_payment_method
      transaction_id: string | null
      receipt_url: string | null
      is_confirmed: boolean
      confirmed_at: Date | null
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
      public_id: string
      status: $Enums.shared_status
      enc_phone: string | null
      phone: string | null
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends invoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, invoicesDefaultArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends payments$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, payments$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'Int'>
    readonly invoice_id: FieldRef<"payments", 'Int'>
    readonly amount: FieldRef<"payments", 'Float'>
    readonly payment_date: FieldRef<"payments", 'DateTime'>
    readonly payment_method: FieldRef<"payments", 'payments_payment_method'>
    readonly transaction_id: FieldRef<"payments", 'String'>
    readonly receipt_url: FieldRef<"payments", 'String'>
    readonly is_confirmed: FieldRef<"payments", 'Boolean'>
    readonly confirmed_at: FieldRef<"payments", 'DateTime'>
    readonly created_at: FieldRef<"payments", 'DateTime'>
    readonly updated_at: FieldRef<"payments", 'DateTime'>
    readonly deleted_at: FieldRef<"payments", 'DateTime'>
    readonly public_id: FieldRef<"payments", 'String'>
    readonly status: FieldRef<"payments", 'shared_status'>
    readonly enc_phone: FieldRef<"payments", 'String'>
    readonly phone: FieldRef<"payments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments.bookings
   */
  export type payments$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    where?: bookingsWhereInput
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    cursor?: bookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model permissions
   */

  export type AggregatePermissions = {
    _count: PermissionsCountAggregateOutputType | null
    _avg: PermissionsAvgAggregateOutputType | null
    _sum: PermissionsSumAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  export type PermissionsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    rec: number | null
    general: number | null
    create: number | null
    read: number | null
    update: number | null
    delete: number | null
    added_by: number | null
  }

  export type PermissionsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    rec: number | null
    general: number | null
    create: number | null
    read: number | null
    update: number | null
    delete: number | null
    added_by: number | null
  }

  export type PermissionsMinAggregateOutputType = {
    id: number | null
    role: $Enums.users_role | null
    user_id: number | null
    tbl: string | null
    rec: number | null
    general: number | null
    create: number | null
    read: number | null
    update: number | null
    delete: number | null
    custom_action: string | null
    added_by: number | null
    created_at: Date | null
    updated_at: Date | null
    status: $Enums.shared_status | null
    deleted_at: Date | null
  }

  export type PermissionsMaxAggregateOutputType = {
    id: number | null
    role: $Enums.users_role | null
    user_id: number | null
    tbl: string | null
    rec: number | null
    general: number | null
    create: number | null
    read: number | null
    update: number | null
    delete: number | null
    custom_action: string | null
    added_by: number | null
    created_at: Date | null
    updated_at: Date | null
    status: $Enums.shared_status | null
    deleted_at: Date | null
  }

  export type PermissionsCountAggregateOutputType = {
    id: number
    role: number
    user_id: number
    tbl: number
    rec: number
    general: number
    create: number
    read: number
    update: number
    delete: number
    custom_action: number
    added_by: number
    created_at: number
    updated_at: number
    status: number
    deleted_at: number
    _all: number
  }


  export type PermissionsAvgAggregateInputType = {
    id?: true
    user_id?: true
    rec?: true
    general?: true
    create?: true
    read?: true
    update?: true
    delete?: true
    added_by?: true
  }

  export type PermissionsSumAggregateInputType = {
    id?: true
    user_id?: true
    rec?: true
    general?: true
    create?: true
    read?: true
    update?: true
    delete?: true
    added_by?: true
  }

  export type PermissionsMinAggregateInputType = {
    id?: true
    role?: true
    user_id?: true
    tbl?: true
    rec?: true
    general?: true
    create?: true
    read?: true
    update?: true
    delete?: true
    custom_action?: true
    added_by?: true
    created_at?: true
    updated_at?: true
    status?: true
    deleted_at?: true
  }

  export type PermissionsMaxAggregateInputType = {
    id?: true
    role?: true
    user_id?: true
    tbl?: true
    rec?: true
    general?: true
    create?: true
    read?: true
    update?: true
    delete?: true
    custom_action?: true
    added_by?: true
    created_at?: true
    updated_at?: true
    status?: true
    deleted_at?: true
  }

  export type PermissionsCountAggregateInputType = {
    id?: true
    role?: true
    user_id?: true
    tbl?: true
    rec?: true
    general?: true
    create?: true
    read?: true
    update?: true
    delete?: true
    custom_action?: true
    added_by?: true
    created_at?: true
    updated_at?: true
    status?: true
    deleted_at?: true
    _all?: true
  }

  export type PermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to aggregate.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissions
    **/
    _count?: true | PermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionsMaxAggregateInputType
  }

  export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissions[P]>
      : GetScalarType<T[P], AggregatePermissions[P]>
  }




  export type permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissionsWhereInput
    orderBy?: permissionsOrderByWithAggregationInput | permissionsOrderByWithAggregationInput[]
    by: PermissionsScalarFieldEnum[] | PermissionsScalarFieldEnum
    having?: permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionsCountAggregateInputType | true
    _avg?: PermissionsAvgAggregateInputType
    _sum?: PermissionsSumAggregateInputType
    _min?: PermissionsMinAggregateInputType
    _max?: PermissionsMaxAggregateInputType
  }

  export type PermissionsGroupByOutputType = {
    id: number
    role: $Enums.users_role
    user_id: number
    tbl: string
    rec: number
    general: number
    create: number
    read: number
    update: number
    delete: number
    custom_action: string | null
    added_by: number
    created_at: Date
    updated_at: Date | null
    status: $Enums.shared_status
    deleted_at: Date | null
    _count: PermissionsCountAggregateOutputType | null
    _avg: PermissionsAvgAggregateOutputType | null
    _sum: PermissionsSumAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  type GetPermissionsGroupByPayload<T extends permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
        }
      >
    >


  export type permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    user_id?: boolean
    tbl?: boolean
    rec?: boolean
    general?: boolean
    create?: boolean
    read?: boolean
    update?: boolean
    delete?: boolean
    custom_action?: boolean
    added_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    deleted_at?: boolean
  }, ExtArgs["result"]["permissions"]>



  export type permissionsSelectScalar = {
    id?: boolean
    role?: boolean
    user_id?: boolean
    tbl?: boolean
    rec?: boolean
    general?: boolean
    create?: boolean
    read?: boolean
    update?: boolean
    delete?: boolean
    custom_action?: boolean
    added_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    deleted_at?: boolean
  }

  export type permissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role" | "user_id" | "tbl" | "rec" | "general" | "create" | "read" | "update" | "delete" | "custom_action" | "added_by" | "created_at" | "updated_at" | "status" | "deleted_at", ExtArgs["result"]["permissions"]>

  export type $permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permissions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      role: $Enums.users_role
      user_id: number
      tbl: string
      rec: number
      general: number
      create: number
      read: number
      update: number
      delete: number
      custom_action: string | null
      added_by: number
      created_at: Date
      updated_at: Date | null
      status: $Enums.shared_status
      deleted_at: Date | null
    }, ExtArgs["result"]["permissions"]>
    composites: {}
  }

  type permissionsGetPayload<S extends boolean | null | undefined | permissionsDefaultArgs> = $Result.GetResult<Prisma.$permissionsPayload, S>

  type permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<permissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionsCountAggregateInputType | true
    }

  export interface permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permissions'], meta: { name: 'permissions' } }
    /**
     * Find zero or one Permissions that matches the filter.
     * @param {permissionsFindUniqueArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissionsFindUniqueArgs>(args: SelectSubset<T, permissionsFindUniqueArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {permissionsFindUniqueOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindFirstArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissionsFindFirstArgs>(args?: SelectSubset<T, permissionsFindFirstArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindFirstOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permissions.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionsWithIdOnly = await prisma.permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends permissionsFindManyArgs>(args?: SelectSubset<T, permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permissions.
     * @param {permissionsCreateArgs} args - Arguments to create a Permissions.
     * @example
     * // Create one Permissions
     * const Permissions = await prisma.permissions.create({
     *   data: {
     *     // ... data to create a Permissions
     *   }
     * })
     * 
     */
    create<T extends permissionsCreateArgs>(args: SelectSubset<T, permissionsCreateArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {permissionsCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permissionsCreateManyArgs>(args?: SelectSubset<T, permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permissions.
     * @param {permissionsDeleteArgs} args - Arguments to delete one Permissions.
     * @example
     * // Delete one Permissions
     * const Permissions = await prisma.permissions.delete({
     *   where: {
     *     // ... filter to delete one Permissions
     *   }
     * })
     * 
     */
    delete<T extends permissionsDeleteArgs>(args: SelectSubset<T, permissionsDeleteArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permissions.
     * @param {permissionsUpdateArgs} args - Arguments to update one Permissions.
     * @example
     * // Update one Permissions
     * const permissions = await prisma.permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permissionsUpdateArgs>(args: SelectSubset<T, permissionsUpdateArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {permissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permissionsDeleteManyArgs>(args?: SelectSubset<T, permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permissionsUpdateManyArgs>(args: SelectSubset<T, permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permissions.
     * @param {permissionsUpsertArgs} args - Arguments to update or create a Permissions.
     * @example
     * // Update or create a Permissions
     * const permissions = await prisma.permissions.upsert({
     *   create: {
     *     // ... data to create a Permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissions we want to update
     *   }
     * })
     */
    upsert<T extends permissionsUpsertArgs>(args: SelectSubset<T, permissionsUpsertArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permissions.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends permissionsCountArgs>(
      args?: Subset<T, permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionsAggregateArgs>(args: Subset<T, PermissionsAggregateArgs>): Prisma.PrismaPromise<GetPermissionsAggregateType<T>>

    /**
     * Group by Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissionsGroupByArgs['orderBy'] }
        : { orderBy?: permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permissions model
   */
  readonly fields: permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permissions model
   */
  interface permissionsFieldRefs {
    readonly id: FieldRef<"permissions", 'Int'>
    readonly role: FieldRef<"permissions", 'users_role'>
    readonly user_id: FieldRef<"permissions", 'Int'>
    readonly tbl: FieldRef<"permissions", 'String'>
    readonly rec: FieldRef<"permissions", 'Int'>
    readonly general: FieldRef<"permissions", 'Int'>
    readonly create: FieldRef<"permissions", 'Int'>
    readonly read: FieldRef<"permissions", 'Int'>
    readonly update: FieldRef<"permissions", 'Int'>
    readonly delete: FieldRef<"permissions", 'Int'>
    readonly custom_action: FieldRef<"permissions", 'String'>
    readonly added_by: FieldRef<"permissions", 'Int'>
    readonly created_at: FieldRef<"permissions", 'DateTime'>
    readonly updated_at: FieldRef<"permissions", 'DateTime'>
    readonly status: FieldRef<"permissions", 'shared_status'>
    readonly deleted_at: FieldRef<"permissions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * permissions findUnique
   */
  export type permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions findUniqueOrThrow
   */
  export type permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions findFirst
   */
  export type permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions findFirstOrThrow
   */
  export type permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions findMany
   */
  export type permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions create
   */
  export type permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * The data needed to create a permissions.
     */
    data: XOR<permissionsCreateInput, permissionsUncheckedCreateInput>
  }

  /**
   * permissions createMany
   */
  export type permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissions.
     */
    data: permissionsCreateManyInput | permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permissions update
   */
  export type permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * The data needed to update a permissions.
     */
    data: XOR<permissionsUpdateInput, permissionsUncheckedUpdateInput>
    /**
     * Choose, which permissions to update.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions updateMany
   */
  export type permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionsUpdateManyMutationInput, permissionsUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionsWhereInput
    /**
     * Limit how many permissions to update.
     */
    limit?: number
  }

  /**
   * permissions upsert
   */
  export type permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * The filter to search for the permissions to update in case it exists.
     */
    where: permissionsWhereUniqueInput
    /**
     * In case the permissions found by the `where` argument doesn't exist, create a new permissions with this data.
     */
    create: XOR<permissionsCreateInput, permissionsUncheckedCreateInput>
    /**
     * In case the permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionsUpdateInput, permissionsUncheckedUpdateInput>
  }

  /**
   * permissions delete
   */
  export type permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Filter which permissions to delete.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions deleteMany
   */
  export type permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionsWhereInput
    /**
     * Limit how many permissions to delete.
     */
    limit?: number
  }

  /**
   * permissions without action
   */
  export type permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
  }


  /**
   * Model quotes
   */

  export type AggregateQuotes = {
    _count: QuotesCountAggregateOutputType | null
    _avg: QuotesAvgAggregateOutputType | null
    _sum: QuotesSumAggregateOutputType | null
    _min: QuotesMinAggregateOutputType | null
    _max: QuotesMaxAggregateOutputType | null
  }

  export type QuotesAvgAggregateOutputType = {
    id: number | null
    rate_card_id: number | null
    client_id: number | null
  }

  export type QuotesSumAggregateOutputType = {
    id: number | null
    rate_card_id: number | null
    client_id: number | null
  }

  export type QuotesMinAggregateOutputType = {
    id: number | null
    rate_card_id: number | null
    client_id: number | null
    status: $Enums.quotes_status | null
    expiration_date: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string | null
  }

  export type QuotesMaxAggregateOutputType = {
    id: number | null
    rate_card_id: number | null
    client_id: number | null
    status: $Enums.quotes_status | null
    expiration_date: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string | null
  }

  export type QuotesCountAggregateOutputType = {
    id: number
    rate_card_id: number
    client_id: number
    status: number
    expiration_date: number
    created_at: number
    updated_at: number
    deleted_at: number
    public_id: number
    _all: number
  }


  export type QuotesAvgAggregateInputType = {
    id?: true
    rate_card_id?: true
    client_id?: true
  }

  export type QuotesSumAggregateInputType = {
    id?: true
    rate_card_id?: true
    client_id?: true
  }

  export type QuotesMinAggregateInputType = {
    id?: true
    rate_card_id?: true
    client_id?: true
    status?: true
    expiration_date?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
  }

  export type QuotesMaxAggregateInputType = {
    id?: true
    rate_card_id?: true
    client_id?: true
    status?: true
    expiration_date?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
  }

  export type QuotesCountAggregateInputType = {
    id?: true
    rate_card_id?: true
    client_id?: true
    status?: true
    expiration_date?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
    _all?: true
  }

  export type QuotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quotes to aggregate.
     */
    where?: quotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quotes to fetch.
     */
    orderBy?: quotesOrderByWithRelationInput | quotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quotes
    **/
    _count?: true | QuotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuotesMaxAggregateInputType
  }

  export type GetQuotesAggregateType<T extends QuotesAggregateArgs> = {
        [P in keyof T & keyof AggregateQuotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuotes[P]>
      : GetScalarType<T[P], AggregateQuotes[P]>
  }




  export type quotesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quotesWhereInput
    orderBy?: quotesOrderByWithAggregationInput | quotesOrderByWithAggregationInput[]
    by: QuotesScalarFieldEnum[] | QuotesScalarFieldEnum
    having?: quotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuotesCountAggregateInputType | true
    _avg?: QuotesAvgAggregateInputType
    _sum?: QuotesSumAggregateInputType
    _min?: QuotesMinAggregateInputType
    _max?: QuotesMaxAggregateInputType
  }

  export type QuotesGroupByOutputType = {
    id: number
    rate_card_id: number
    client_id: number
    status: $Enums.quotes_status
    expiration_date: Date
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string
    _count: QuotesCountAggregateOutputType | null
    _avg: QuotesAvgAggregateOutputType | null
    _sum: QuotesSumAggregateOutputType | null
    _min: QuotesMinAggregateOutputType | null
    _max: QuotesMaxAggregateOutputType | null
  }

  type GetQuotesGroupByPayload<T extends quotesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuotesGroupByOutputType[P]>
            : GetScalarType<T[P], QuotesGroupByOutputType[P]>
        }
      >
    >


  export type quotesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rate_card_id?: boolean
    client_id?: boolean
    status?: boolean
    expiration_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    public_id?: boolean
    booking?: boolean | quotes$bookingArgs<ExtArgs>
    invoice?: boolean | quotes$invoiceArgs<ExtArgs>
    client?: boolean | clientsDefaultArgs<ExtArgs>
    rate_card?: boolean | rate_cardsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quotes"]>



  export type quotesSelectScalar = {
    id?: boolean
    rate_card_id?: boolean
    client_id?: boolean
    status?: boolean
    expiration_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    public_id?: boolean
  }

  export type quotesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rate_card_id" | "client_id" | "status" | "expiration_date" | "created_at" | "updated_at" | "deleted_at" | "public_id", ExtArgs["result"]["quotes"]>
  export type quotesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | quotes$bookingArgs<ExtArgs>
    invoice?: boolean | quotes$invoiceArgs<ExtArgs>
    client?: boolean | clientsDefaultArgs<ExtArgs>
    rate_card?: boolean | rate_cardsDefaultArgs<ExtArgs>
  }

  export type $quotesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quotes"
    objects: {
      booking: Prisma.$bookingsPayload<ExtArgs> | null
      invoice: Prisma.$invoicesPayload<ExtArgs> | null
      client: Prisma.$clientsPayload<ExtArgs>
      rate_card: Prisma.$rate_cardsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rate_card_id: number
      client_id: number
      status: $Enums.quotes_status
      expiration_date: Date
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
      public_id: string
    }, ExtArgs["result"]["quotes"]>
    composites: {}
  }

  type quotesGetPayload<S extends boolean | null | undefined | quotesDefaultArgs> = $Result.GetResult<Prisma.$quotesPayload, S>

  type quotesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<quotesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuotesCountAggregateInputType | true
    }

  export interface quotesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quotes'], meta: { name: 'quotes' } }
    /**
     * Find zero or one Quotes that matches the filter.
     * @param {quotesFindUniqueArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends quotesFindUniqueArgs>(args: SelectSubset<T, quotesFindUniqueArgs<ExtArgs>>): Prisma__quotesClient<$Result.GetResult<Prisma.$quotesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quotes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {quotesFindUniqueOrThrowArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends quotesFindUniqueOrThrowArgs>(args: SelectSubset<T, quotesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__quotesClient<$Result.GetResult<Prisma.$quotesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quotesFindFirstArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends quotesFindFirstArgs>(args?: SelectSubset<T, quotesFindFirstArgs<ExtArgs>>): Prisma__quotesClient<$Result.GetResult<Prisma.$quotesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quotes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quotesFindFirstOrThrowArgs} args - Arguments to find a Quotes
     * @example
     * // Get one Quotes
     * const quotes = await prisma.quotes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends quotesFindFirstOrThrowArgs>(args?: SelectSubset<T, quotesFindFirstOrThrowArgs<ExtArgs>>): Prisma__quotesClient<$Result.GetResult<Prisma.$quotesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quotesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quotes
     * const quotes = await prisma.quotes.findMany()
     * 
     * // Get first 10 Quotes
     * const quotes = await prisma.quotes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quotesWithIdOnly = await prisma.quotes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends quotesFindManyArgs>(args?: SelectSubset<T, quotesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quotes.
     * @param {quotesCreateArgs} args - Arguments to create a Quotes.
     * @example
     * // Create one Quotes
     * const Quotes = await prisma.quotes.create({
     *   data: {
     *     // ... data to create a Quotes
     *   }
     * })
     * 
     */
    create<T extends quotesCreateArgs>(args: SelectSubset<T, quotesCreateArgs<ExtArgs>>): Prisma__quotesClient<$Result.GetResult<Prisma.$quotesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quotes.
     * @param {quotesCreateManyArgs} args - Arguments to create many Quotes.
     * @example
     * // Create many Quotes
     * const quotes = await prisma.quotes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends quotesCreateManyArgs>(args?: SelectSubset<T, quotesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Quotes.
     * @param {quotesDeleteArgs} args - Arguments to delete one Quotes.
     * @example
     * // Delete one Quotes
     * const Quotes = await prisma.quotes.delete({
     *   where: {
     *     // ... filter to delete one Quotes
     *   }
     * })
     * 
     */
    delete<T extends quotesDeleteArgs>(args: SelectSubset<T, quotesDeleteArgs<ExtArgs>>): Prisma__quotesClient<$Result.GetResult<Prisma.$quotesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quotes.
     * @param {quotesUpdateArgs} args - Arguments to update one Quotes.
     * @example
     * // Update one Quotes
     * const quotes = await prisma.quotes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends quotesUpdateArgs>(args: SelectSubset<T, quotesUpdateArgs<ExtArgs>>): Prisma__quotesClient<$Result.GetResult<Prisma.$quotesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quotes.
     * @param {quotesDeleteManyArgs} args - Arguments to filter Quotes to delete.
     * @example
     * // Delete a few Quotes
     * const { count } = await prisma.quotes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends quotesDeleteManyArgs>(args?: SelectSubset<T, quotesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quotes
     * const quotes = await prisma.quotes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends quotesUpdateManyArgs>(args: SelectSubset<T, quotesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Quotes.
     * @param {quotesUpsertArgs} args - Arguments to update or create a Quotes.
     * @example
     * // Update or create a Quotes
     * const quotes = await prisma.quotes.upsert({
     *   create: {
     *     // ... data to create a Quotes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quotes we want to update
     *   }
     * })
     */
    upsert<T extends quotesUpsertArgs>(args: SelectSubset<T, quotesUpsertArgs<ExtArgs>>): Prisma__quotesClient<$Result.GetResult<Prisma.$quotesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quotesCountArgs} args - Arguments to filter Quotes to count.
     * @example
     * // Count the number of Quotes
     * const count = await prisma.quotes.count({
     *   where: {
     *     // ... the filter for the Quotes we want to count
     *   }
     * })
    **/
    count<T extends quotesCountArgs>(
      args?: Subset<T, quotesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuotesAggregateArgs>(args: Subset<T, QuotesAggregateArgs>): Prisma.PrismaPromise<GetQuotesAggregateType<T>>

    /**
     * Group by Quotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends quotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: quotesGroupByArgs['orderBy'] }
        : { orderBy?: quotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, quotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quotes model
   */
  readonly fields: quotesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quotes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__quotesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends quotes$bookingArgs<ExtArgs> = {}>(args?: Subset<T, quotes$bookingArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invoice<T extends quotes$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, quotes$invoiceArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends clientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clientsDefaultArgs<ExtArgs>>): Prisma__clientsClient<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rate_card<T extends rate_cardsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rate_cardsDefaultArgs<ExtArgs>>): Prisma__rate_cardsClient<$Result.GetResult<Prisma.$rate_cardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quotes model
   */
  interface quotesFieldRefs {
    readonly id: FieldRef<"quotes", 'Int'>
    readonly rate_card_id: FieldRef<"quotes", 'Int'>
    readonly client_id: FieldRef<"quotes", 'Int'>
    readonly status: FieldRef<"quotes", 'quotes_status'>
    readonly expiration_date: FieldRef<"quotes", 'DateTime'>
    readonly created_at: FieldRef<"quotes", 'DateTime'>
    readonly updated_at: FieldRef<"quotes", 'DateTime'>
    readonly deleted_at: FieldRef<"quotes", 'DateTime'>
    readonly public_id: FieldRef<"quotes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * quotes findUnique
   */
  export type quotesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quotes
     */
    omit?: quotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quotesInclude<ExtArgs> | null
    /**
     * Filter, which quotes to fetch.
     */
    where: quotesWhereUniqueInput
  }

  /**
   * quotes findUniqueOrThrow
   */
  export type quotesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quotes
     */
    omit?: quotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quotesInclude<ExtArgs> | null
    /**
     * Filter, which quotes to fetch.
     */
    where: quotesWhereUniqueInput
  }

  /**
   * quotes findFirst
   */
  export type quotesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quotes
     */
    omit?: quotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quotesInclude<ExtArgs> | null
    /**
     * Filter, which quotes to fetch.
     */
    where?: quotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quotes to fetch.
     */
    orderBy?: quotesOrderByWithRelationInput | quotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quotes.
     */
    cursor?: quotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quotes.
     */
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[]
  }

  /**
   * quotes findFirstOrThrow
   */
  export type quotesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quotes
     */
    omit?: quotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quotesInclude<ExtArgs> | null
    /**
     * Filter, which quotes to fetch.
     */
    where?: quotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quotes to fetch.
     */
    orderBy?: quotesOrderByWithRelationInput | quotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quotes.
     */
    cursor?: quotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quotes.
     */
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[]
  }

  /**
   * quotes findMany
   */
  export type quotesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quotes
     */
    omit?: quotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quotesInclude<ExtArgs> | null
    /**
     * Filter, which quotes to fetch.
     */
    where?: quotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quotes to fetch.
     */
    orderBy?: quotesOrderByWithRelationInput | quotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quotes.
     */
    cursor?: quotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quotes.
     */
    skip?: number
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[]
  }

  /**
   * quotes create
   */
  export type quotesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quotes
     */
    omit?: quotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quotesInclude<ExtArgs> | null
    /**
     * The data needed to create a quotes.
     */
    data: XOR<quotesCreateInput, quotesUncheckedCreateInput>
  }

  /**
   * quotes createMany
   */
  export type quotesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quotes.
     */
    data: quotesCreateManyInput | quotesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quotes update
   */
  export type quotesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quotes
     */
    omit?: quotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quotesInclude<ExtArgs> | null
    /**
     * The data needed to update a quotes.
     */
    data: XOR<quotesUpdateInput, quotesUncheckedUpdateInput>
    /**
     * Choose, which quotes to update.
     */
    where: quotesWhereUniqueInput
  }

  /**
   * quotes updateMany
   */
  export type quotesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quotes.
     */
    data: XOR<quotesUpdateManyMutationInput, quotesUncheckedUpdateManyInput>
    /**
     * Filter which quotes to update
     */
    where?: quotesWhereInput
    /**
     * Limit how many quotes to update.
     */
    limit?: number
  }

  /**
   * quotes upsert
   */
  export type quotesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quotes
     */
    omit?: quotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quotesInclude<ExtArgs> | null
    /**
     * The filter to search for the quotes to update in case it exists.
     */
    where: quotesWhereUniqueInput
    /**
     * In case the quotes found by the `where` argument doesn't exist, create a new quotes with this data.
     */
    create: XOR<quotesCreateInput, quotesUncheckedCreateInput>
    /**
     * In case the quotes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quotesUpdateInput, quotesUncheckedUpdateInput>
  }

  /**
   * quotes delete
   */
  export type quotesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quotes
     */
    omit?: quotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quotesInclude<ExtArgs> | null
    /**
     * Filter which quotes to delete.
     */
    where: quotesWhereUniqueInput
  }

  /**
   * quotes deleteMany
   */
  export type quotesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quotes to delete
     */
    where?: quotesWhereInput
    /**
     * Limit how many quotes to delete.
     */
    limit?: number
  }

  /**
   * quotes.booking
   */
  export type quotes$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    where?: bookingsWhereInput
  }

  /**
   * quotes.invoice
   */
  export type quotes$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    where?: invoicesWhereInput
  }

  /**
   * quotes without action
   */
  export type quotesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quotes
     */
    omit?: quotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quotesInclude<ExtArgs> | null
  }


  /**
   * Model rack_rates
   */

  export type AggregateRack_rates = {
    _count: Rack_ratesCountAggregateOutputType | null
    _avg: Rack_ratesAvgAggregateOutputType | null
    _sum: Rack_ratesSumAggregateOutputType | null
    _min: Rack_ratesMinAggregateOutputType | null
    _max: Rack_ratesMaxAggregateOutputType | null
  }

  export type Rack_ratesAvgAggregateOutputType = {
    id: number | null
    rate: number | null
    hotel_id: number | null
  }

  export type Rack_ratesSumAggregateOutputType = {
    id: number | null
    rate: number | null
    hotel_id: number | null
  }

  export type Rack_ratesMinAggregateOutputType = {
    id: number | null
    rate: number | null
    currency: string | null
    travel_period: $Enums.rack_rates_travel_period | null
    meal_plan: $Enums.rack_rates_meal_plan | null
    room_category: $Enums.rack_rates_room_category | null
    pdf_url: string | null
    isProcessed: boolean | null
    processed_date: Date | null
    hotel_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string | null
    status: $Enums.shared_status | null
  }

  export type Rack_ratesMaxAggregateOutputType = {
    id: number | null
    rate: number | null
    currency: string | null
    travel_period: $Enums.rack_rates_travel_period | null
    meal_plan: $Enums.rack_rates_meal_plan | null
    room_category: $Enums.rack_rates_room_category | null
    pdf_url: string | null
    isProcessed: boolean | null
    processed_date: Date | null
    hotel_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string | null
    status: $Enums.shared_status | null
  }

  export type Rack_ratesCountAggregateOutputType = {
    id: number
    rate: number
    currency: number
    travel_period: number
    meal_plan: number
    room_category: number
    pdf_url: number
    isProcessed: number
    processed_date: number
    hotel_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    public_id: number
    status: number
    _all: number
  }


  export type Rack_ratesAvgAggregateInputType = {
    id?: true
    rate?: true
    hotel_id?: true
  }

  export type Rack_ratesSumAggregateInputType = {
    id?: true
    rate?: true
    hotel_id?: true
  }

  export type Rack_ratesMinAggregateInputType = {
    id?: true
    rate?: true
    currency?: true
    travel_period?: true
    meal_plan?: true
    room_category?: true
    pdf_url?: true
    isProcessed?: true
    processed_date?: true
    hotel_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
    status?: true
  }

  export type Rack_ratesMaxAggregateInputType = {
    id?: true
    rate?: true
    currency?: true
    travel_period?: true
    meal_plan?: true
    room_category?: true
    pdf_url?: true
    isProcessed?: true
    processed_date?: true
    hotel_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
    status?: true
  }

  export type Rack_ratesCountAggregateInputType = {
    id?: true
    rate?: true
    currency?: true
    travel_period?: true
    meal_plan?: true
    room_category?: true
    pdf_url?: true
    isProcessed?: true
    processed_date?: true
    hotel_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    public_id?: true
    status?: true
    _all?: true
  }

  export type Rack_ratesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rack_rates to aggregate.
     */
    where?: rack_ratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rack_rates to fetch.
     */
    orderBy?: rack_ratesOrderByWithRelationInput | rack_ratesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rack_ratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rack_rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rack_rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rack_rates
    **/
    _count?: true | Rack_ratesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Rack_ratesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Rack_ratesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rack_ratesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rack_ratesMaxAggregateInputType
  }

  export type GetRack_ratesAggregateType<T extends Rack_ratesAggregateArgs> = {
        [P in keyof T & keyof AggregateRack_rates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRack_rates[P]>
      : GetScalarType<T[P], AggregateRack_rates[P]>
  }




  export type rack_ratesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rack_ratesWhereInput
    orderBy?: rack_ratesOrderByWithAggregationInput | rack_ratesOrderByWithAggregationInput[]
    by: Rack_ratesScalarFieldEnum[] | Rack_ratesScalarFieldEnum
    having?: rack_ratesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rack_ratesCountAggregateInputType | true
    _avg?: Rack_ratesAvgAggregateInputType
    _sum?: Rack_ratesSumAggregateInputType
    _min?: Rack_ratesMinAggregateInputType
    _max?: Rack_ratesMaxAggregateInputType
  }

  export type Rack_ratesGroupByOutputType = {
    id: number
    rate: number
    currency: string
    travel_period: $Enums.rack_rates_travel_period
    meal_plan: $Enums.rack_rates_meal_plan
    room_category: $Enums.rack_rates_room_category
    pdf_url: string | null
    isProcessed: boolean
    processed_date: Date | null
    hotel_id: number
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    public_id: string
    status: $Enums.shared_status
    _count: Rack_ratesCountAggregateOutputType | null
    _avg: Rack_ratesAvgAggregateOutputType | null
    _sum: Rack_ratesSumAggregateOutputType | null
    _min: Rack_ratesMinAggregateOutputType | null
    _max: Rack_ratesMaxAggregateOutputType | null
  }

  type GetRack_ratesGroupByPayload<T extends rack_ratesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rack_ratesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rack_ratesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rack_ratesGroupByOutputType[P]>
            : GetScalarType<T[P], Rack_ratesGroupByOutputType[P]>
        }
      >
    >


  export type rack_ratesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rate?: boolean
    currency?: boolean
    travel_period?: boolean
    meal_plan?: boolean
    room_category?: boolean
    pdf_url?: boolean
    isProcessed?: boolean
    processed_date?: boolean
    hotel_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    public_id?: boolean
    status?: boolean
    hotel?: boolean | hotelsDefaultArgs<ExtArgs>
    rate_cards?: boolean | rack_rates$rate_cardsArgs<ExtArgs>
    _count?: boolean | Rack_ratesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rack_rates"]>



  export type rack_ratesSelectScalar = {
    id?: boolean
    rate?: boolean
    currency?: boolean
    travel_period?: boolean
    meal_plan?: boolean
    room_category?: boolean
    pdf_url?: boolean
    isProcessed?: boolean
    processed_date?: boolean
    hotel_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    public_id?: boolean
    status?: boolean
  }

  export type rack_ratesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rate" | "currency" | "travel_period" | "meal_plan" | "room_category" | "pdf_url" | "isProcessed" | "processed_date" | "hotel_id" | "created_at" | "updated_at" | "deleted_at" | "public_id" | "status", ExtArgs["result"]["rack_rates"]>
  export type rack_ratesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel?: boolean | hotelsDefaultArgs<ExtArgs>
    rate_cards?: boolean | rack_rates$rate_cardsArgs<ExtArgs>
    _count?: boolean | Rack_ratesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rack_ratesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rack_rates"
    objects: {
      hotel: Prisma.$hotelsPayload<ExtArgs>
      rate_cards: Prisma.$rate_cardsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rate: number
      currency: string
      travel_period: $Enums.rack_rates_travel_period
      meal_plan: $Enums.rack_rates_meal_plan
      room_category: $Enums.rack_rates_room_category
      pdf_url: string | null
      isProcessed: boolean
      processed_date: Date | null
      hotel_id: number
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
      public_id: string
      status: $Enums.shared_status
    }, ExtArgs["result"]["rack_rates"]>
    composites: {}
  }

  type rack_ratesGetPayload<S extends boolean | null | undefined | rack_ratesDefaultArgs> = $Result.GetResult<Prisma.$rack_ratesPayload, S>

  type rack_ratesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rack_ratesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Rack_ratesCountAggregateInputType | true
    }

  export interface rack_ratesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rack_rates'], meta: { name: 'rack_rates' } }
    /**
     * Find zero or one Rack_rates that matches the filter.
     * @param {rack_ratesFindUniqueArgs} args - Arguments to find a Rack_rates
     * @example
     * // Get one Rack_rates
     * const rack_rates = await prisma.rack_rates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rack_ratesFindUniqueArgs>(args: SelectSubset<T, rack_ratesFindUniqueArgs<ExtArgs>>): Prisma__rack_ratesClient<$Result.GetResult<Prisma.$rack_ratesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rack_rates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rack_ratesFindUniqueOrThrowArgs} args - Arguments to find a Rack_rates
     * @example
     * // Get one Rack_rates
     * const rack_rates = await prisma.rack_rates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rack_ratesFindUniqueOrThrowArgs>(args: SelectSubset<T, rack_ratesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rack_ratesClient<$Result.GetResult<Prisma.$rack_ratesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rack_rates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rack_ratesFindFirstArgs} args - Arguments to find a Rack_rates
     * @example
     * // Get one Rack_rates
     * const rack_rates = await prisma.rack_rates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rack_ratesFindFirstArgs>(args?: SelectSubset<T, rack_ratesFindFirstArgs<ExtArgs>>): Prisma__rack_ratesClient<$Result.GetResult<Prisma.$rack_ratesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rack_rates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rack_ratesFindFirstOrThrowArgs} args - Arguments to find a Rack_rates
     * @example
     * // Get one Rack_rates
     * const rack_rates = await prisma.rack_rates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rack_ratesFindFirstOrThrowArgs>(args?: SelectSubset<T, rack_ratesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rack_ratesClient<$Result.GetResult<Prisma.$rack_ratesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rack_rates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rack_ratesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rack_rates
     * const rack_rates = await prisma.rack_rates.findMany()
     * 
     * // Get first 10 Rack_rates
     * const rack_rates = await prisma.rack_rates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rack_ratesWithIdOnly = await prisma.rack_rates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rack_ratesFindManyArgs>(args?: SelectSubset<T, rack_ratesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rack_ratesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rack_rates.
     * @param {rack_ratesCreateArgs} args - Arguments to create a Rack_rates.
     * @example
     * // Create one Rack_rates
     * const Rack_rates = await prisma.rack_rates.create({
     *   data: {
     *     // ... data to create a Rack_rates
     *   }
     * })
     * 
     */
    create<T extends rack_ratesCreateArgs>(args: SelectSubset<T, rack_ratesCreateArgs<ExtArgs>>): Prisma__rack_ratesClient<$Result.GetResult<Prisma.$rack_ratesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rack_rates.
     * @param {rack_ratesCreateManyArgs} args - Arguments to create many Rack_rates.
     * @example
     * // Create many Rack_rates
     * const rack_rates = await prisma.rack_rates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rack_ratesCreateManyArgs>(args?: SelectSubset<T, rack_ratesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rack_rates.
     * @param {rack_ratesDeleteArgs} args - Arguments to delete one Rack_rates.
     * @example
     * // Delete one Rack_rates
     * const Rack_rates = await prisma.rack_rates.delete({
     *   where: {
     *     // ... filter to delete one Rack_rates
     *   }
     * })
     * 
     */
    delete<T extends rack_ratesDeleteArgs>(args: SelectSubset<T, rack_ratesDeleteArgs<ExtArgs>>): Prisma__rack_ratesClient<$Result.GetResult<Prisma.$rack_ratesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rack_rates.
     * @param {rack_ratesUpdateArgs} args - Arguments to update one Rack_rates.
     * @example
     * // Update one Rack_rates
     * const rack_rates = await prisma.rack_rates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rack_ratesUpdateArgs>(args: SelectSubset<T, rack_ratesUpdateArgs<ExtArgs>>): Prisma__rack_ratesClient<$Result.GetResult<Prisma.$rack_ratesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rack_rates.
     * @param {rack_ratesDeleteManyArgs} args - Arguments to filter Rack_rates to delete.
     * @example
     * // Delete a few Rack_rates
     * const { count } = await prisma.rack_rates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rack_ratesDeleteManyArgs>(args?: SelectSubset<T, rack_ratesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rack_rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rack_ratesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rack_rates
     * const rack_rates = await prisma.rack_rates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rack_ratesUpdateManyArgs>(args: SelectSubset<T, rack_ratesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rack_rates.
     * @param {rack_ratesUpsertArgs} args - Arguments to update or create a Rack_rates.
     * @example
     * // Update or create a Rack_rates
     * const rack_rates = await prisma.rack_rates.upsert({
     *   create: {
     *     // ... data to create a Rack_rates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rack_rates we want to update
     *   }
     * })
     */
    upsert<T extends rack_ratesUpsertArgs>(args: SelectSubset<T, rack_ratesUpsertArgs<ExtArgs>>): Prisma__rack_ratesClient<$Result.GetResult<Prisma.$rack_ratesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rack_rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rack_ratesCountArgs} args - Arguments to filter Rack_rates to count.
     * @example
     * // Count the number of Rack_rates
     * const count = await prisma.rack_rates.count({
     *   where: {
     *     // ... the filter for the Rack_rates we want to count
     *   }
     * })
    **/
    count<T extends rack_ratesCountArgs>(
      args?: Subset<T, rack_ratesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rack_ratesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rack_rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rack_ratesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rack_ratesAggregateArgs>(args: Subset<T, Rack_ratesAggregateArgs>): Prisma.PrismaPromise<GetRack_ratesAggregateType<T>>

    /**
     * Group by Rack_rates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rack_ratesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rack_ratesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rack_ratesGroupByArgs['orderBy'] }
        : { orderBy?: rack_ratesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rack_ratesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRack_ratesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rack_rates model
   */
  readonly fields: rack_ratesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rack_rates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rack_ratesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel<T extends hotelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, hotelsDefaultArgs<ExtArgs>>): Prisma__hotelsClient<$Result.GetResult<Prisma.$hotelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rate_cards<T extends rack_rates$rate_cardsArgs<ExtArgs> = {}>(args?: Subset<T, rack_rates$rate_cardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rate_cardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rack_rates model
   */
  interface rack_ratesFieldRefs {
    readonly id: FieldRef<"rack_rates", 'Int'>
    readonly rate: FieldRef<"rack_rates", 'Float'>
    readonly currency: FieldRef<"rack_rates", 'String'>
    readonly travel_period: FieldRef<"rack_rates", 'rack_rates_travel_period'>
    readonly meal_plan: FieldRef<"rack_rates", 'rack_rates_meal_plan'>
    readonly room_category: FieldRef<"rack_rates", 'rack_rates_room_category'>
    readonly pdf_url: FieldRef<"rack_rates", 'String'>
    readonly isProcessed: FieldRef<"rack_rates", 'Boolean'>
    readonly processed_date: FieldRef<"rack_rates", 'DateTime'>
    readonly hotel_id: FieldRef<"rack_rates", 'Int'>
    readonly created_at: FieldRef<"rack_rates", 'DateTime'>
    readonly updated_at: FieldRef<"rack_rates", 'DateTime'>
    readonly deleted_at: FieldRef<"rack_rates", 'DateTime'>
    readonly public_id: FieldRef<"rack_rates", 'String'>
    readonly status: FieldRef<"rack_rates", 'shared_status'>
  }
    

  // Custom InputTypes
  /**
   * rack_rates findUnique
   */
  export type rack_ratesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rack_rates
     */
    select?: rack_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rack_rates
     */
    omit?: rack_ratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rack_ratesInclude<ExtArgs> | null
    /**
     * Filter, which rack_rates to fetch.
     */
    where: rack_ratesWhereUniqueInput
  }

  /**
   * rack_rates findUniqueOrThrow
   */
  export type rack_ratesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rack_rates
     */
    select?: rack_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rack_rates
     */
    omit?: rack_ratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rack_ratesInclude<ExtArgs> | null
    /**
     * Filter, which rack_rates to fetch.
     */
    where: rack_ratesWhereUniqueInput
  }

  /**
   * rack_rates findFirst
   */
  export type rack_ratesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rack_rates
     */
    select?: rack_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rack_rates
     */
    omit?: rack_ratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rack_ratesInclude<ExtArgs> | null
    /**
     * Filter, which rack_rates to fetch.
     */
    where?: rack_ratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rack_rates to fetch.
     */
    orderBy?: rack_ratesOrderByWithRelationInput | rack_ratesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rack_rates.
     */
    cursor?: rack_ratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rack_rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rack_rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rack_rates.
     */
    distinct?: Rack_ratesScalarFieldEnum | Rack_ratesScalarFieldEnum[]
  }

  /**
   * rack_rates findFirstOrThrow
   */
  export type rack_ratesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rack_rates
     */
    select?: rack_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rack_rates
     */
    omit?: rack_ratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rack_ratesInclude<ExtArgs> | null
    /**
     * Filter, which rack_rates to fetch.
     */
    where?: rack_ratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rack_rates to fetch.
     */
    orderBy?: rack_ratesOrderByWithRelationInput | rack_ratesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rack_rates.
     */
    cursor?: rack_ratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rack_rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rack_rates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rack_rates.
     */
    distinct?: Rack_ratesScalarFieldEnum | Rack_ratesScalarFieldEnum[]
  }

  /**
   * rack_rates findMany
   */
  export type rack_ratesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rack_rates
     */
    select?: rack_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rack_rates
     */
    omit?: rack_ratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rack_ratesInclude<ExtArgs> | null
    /**
     * Filter, which rack_rates to fetch.
     */
    where?: rack_ratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rack_rates to fetch.
     */
    orderBy?: rack_ratesOrderByWithRelationInput | rack_ratesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rack_rates.
     */
    cursor?: rack_ratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rack_rates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rack_rates.
     */
    skip?: number
    distinct?: Rack_ratesScalarFieldEnum | Rack_ratesScalarFieldEnum[]
  }

  /**
   * rack_rates create
   */
  export type rack_ratesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rack_rates
     */
    select?: rack_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rack_rates
     */
    omit?: rack_ratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rack_ratesInclude<ExtArgs> | null
    /**
     * The data needed to create a rack_rates.
     */
    data: XOR<rack_ratesCreateInput, rack_ratesUncheckedCreateInput>
  }

  /**
   * rack_rates createMany
   */
  export type rack_ratesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rack_rates.
     */
    data: rack_ratesCreateManyInput | rack_ratesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rack_rates update
   */
  export type rack_ratesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rack_rates
     */
    select?: rack_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rack_rates
     */
    omit?: rack_ratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rack_ratesInclude<ExtArgs> | null
    /**
     * The data needed to update a rack_rates.
     */
    data: XOR<rack_ratesUpdateInput, rack_ratesUncheckedUpdateInput>
    /**
     * Choose, which rack_rates to update.
     */
    where: rack_ratesWhereUniqueInput
  }

  /**
   * rack_rates updateMany
   */
  export type rack_ratesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rack_rates.
     */
    data: XOR<rack_ratesUpdateManyMutationInput, rack_ratesUncheckedUpdateManyInput>
    /**
     * Filter which rack_rates to update
     */
    where?: rack_ratesWhereInput
    /**
     * Limit how many rack_rates to update.
     */
    limit?: number
  }

  /**
   * rack_rates upsert
   */
  export type rack_ratesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rack_rates
     */
    select?: rack_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rack_rates
     */
    omit?: rack_ratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rack_ratesInclude<ExtArgs> | null
    /**
     * The filter to search for the rack_rates to update in case it exists.
     */
    where: rack_ratesWhereUniqueInput
    /**
     * In case the rack_rates found by the `where` argument doesn't exist, create a new rack_rates with this data.
     */
    create: XOR<rack_ratesCreateInput, rack_ratesUncheckedCreateInput>
    /**
     * In case the rack_rates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rack_ratesUpdateInput, rack_ratesUncheckedUpdateInput>
  }

  /**
   * rack_rates delete
   */
  export type rack_ratesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rack_rates
     */
    select?: rack_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rack_rates
     */
    omit?: rack_ratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rack_ratesInclude<ExtArgs> | null
    /**
     * Filter which rack_rates to delete.
     */
    where: rack_ratesWhereUniqueInput
  }

  /**
   * rack_rates deleteMany
   */
  export type rack_ratesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rack_rates to delete
     */
    where?: rack_ratesWhereInput
    /**
     * Limit how many rack_rates to delete.
     */
    limit?: number
  }

  /**
   * rack_rates.rate_cards
   */
  export type rack_rates$rate_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate_cards
     */
    select?: rate_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate_cards
     */
    omit?: rate_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rate_cardsInclude<ExtArgs> | null
    where?: rate_cardsWhereInput
    orderBy?: rate_cardsOrderByWithRelationInput | rate_cardsOrderByWithRelationInput[]
    cursor?: rate_cardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Rate_cardsScalarFieldEnum | Rate_cardsScalarFieldEnum[]
  }

  /**
   * rack_rates without action
   */
  export type rack_ratesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rack_rates
     */
    select?: rack_ratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rack_rates
     */
    omit?: rack_ratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rack_ratesInclude<ExtArgs> | null
  }


  /**
   * Model rate_cards
   */

  export type AggregateRate_cards = {
    _count: Rate_cardsCountAggregateOutputType | null
    _avg: Rate_cardsAvgAggregateOutputType | null
    _sum: Rate_cardsSumAggregateOutputType | null
    _min: Rate_cardsMinAggregateOutputType | null
    _max: Rate_cardsMaxAggregateOutputType | null
  }

  export type Rate_cardsAvgAggregateOutputType = {
    id: number | null
    base_rate: number | null
    commission_rate: number | null
    markup_rate: number | null
    discount_amount: number | null
    discount_percent: number | null
    final_rate: number | null
    commission: number | null
    rack_rate_id: number | null
    hotel_id: number | null
    created_by: number | null
  }

  export type Rate_cardsSumAggregateOutputType = {
    id: number | null
    base_rate: number | null
    commission_rate: number | null
    markup_rate: number | null
    discount_amount: number | null
    discount_percent: number | null
    final_rate: number | null
    commission: number | null
    rack_rate_id: number | null
    hotel_id: number | null
    created_by: number | null
  }

  export type Rate_cardsMinAggregateOutputType = {
    id: number | null
    name: string | null
    base_rate: number | null
    commission_rate: number | null
    markup_rate: number | null
    discount_amount: number | null
    discount_percent: number | null
    final_rate: number | null
    currency: string | null
    travel_period: $Enums.rate_cards_travel_period | null
    meal_plan: $Enums.rate_cards_meal_plan | null
    room_category: $Enums.rate_cards_room_category | null
    commission: number | null
    is_active: boolean | null
    rack_rate_id: number | null
    hotel_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    created_by: number | null
    public_id: string | null
    status: $Enums.shared_status | null
  }

  export type Rate_cardsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    base_rate: number | null
    commission_rate: number | null
    markup_rate: number | null
    discount_amount: number | null
    discount_percent: number | null
    final_rate: number | null
    currency: string | null
    travel_period: $Enums.rate_cards_travel_period | null
    meal_plan: $Enums.rate_cards_meal_plan | null
    room_category: $Enums.rate_cards_room_category | null
    commission: number | null
    is_active: boolean | null
    rack_rate_id: number | null
    hotel_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    created_by: number | null
    public_id: string | null
    status: $Enums.shared_status | null
  }

  export type Rate_cardsCountAggregateOutputType = {
    id: number
    name: number
    base_rate: number
    commission_rate: number
    markup_rate: number
    discount_amount: number
    discount_percent: number
    final_rate: number
    currency: number
    travel_period: number
    meal_plan: number
    room_category: number
    commission: number
    is_active: number
    rack_rate_id: number
    hotel_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    created_by: number
    public_id: number
    status: number
    _all: number
  }


  export type Rate_cardsAvgAggregateInputType = {
    id?: true
    base_rate?: true
    commission_rate?: true
    markup_rate?: true
    discount_amount?: true
    discount_percent?: true
    final_rate?: true
    commission?: true
    rack_rate_id?: true
    hotel_id?: true
    created_by?: true
  }

  export type Rate_cardsSumAggregateInputType = {
    id?: true
    base_rate?: true
    commission_rate?: true
    markup_rate?: true
    discount_amount?: true
    discount_percent?: true
    final_rate?: true
    commission?: true
    rack_rate_id?: true
    hotel_id?: true
    created_by?: true
  }

  export type Rate_cardsMinAggregateInputType = {
    id?: true
    name?: true
    base_rate?: true
    commission_rate?: true
    markup_rate?: true
    discount_amount?: true
    discount_percent?: true
    final_rate?: true
    currency?: true
    travel_period?: true
    meal_plan?: true
    room_category?: true
    commission?: true
    is_active?: true
    rack_rate_id?: true
    hotel_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    created_by?: true
    public_id?: true
    status?: true
  }

  export type Rate_cardsMaxAggregateInputType = {
    id?: true
    name?: true
    base_rate?: true
    commission_rate?: true
    markup_rate?: true
    discount_amount?: true
    discount_percent?: true
    final_rate?: true
    currency?: true
    travel_period?: true
    meal_plan?: true
    room_category?: true
    commission?: true
    is_active?: true
    rack_rate_id?: true
    hotel_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    created_by?: true
    public_id?: true
    status?: true
  }

  export type Rate_cardsCountAggregateInputType = {
    id?: true
    name?: true
    base_rate?: true
    commission_rate?: true
    markup_rate?: true
    discount_amount?: true
    discount_percent?: true
    final_rate?: true
    currency?: true
    travel_period?: true
    meal_plan?: true
    room_category?: true
    commission?: true
    is_active?: true
    rack_rate_id?: true
    hotel_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    created_by?: true
    public_id?: true
    status?: true
    _all?: true
  }

  export type Rate_cardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rate_cards to aggregate.
     */
    where?: rate_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rate_cards to fetch.
     */
    orderBy?: rate_cardsOrderByWithRelationInput | rate_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rate_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rate_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rate_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rate_cards
    **/
    _count?: true | Rate_cardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Rate_cardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Rate_cardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Rate_cardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Rate_cardsMaxAggregateInputType
  }

  export type GetRate_cardsAggregateType<T extends Rate_cardsAggregateArgs> = {
        [P in keyof T & keyof AggregateRate_cards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRate_cards[P]>
      : GetScalarType<T[P], AggregateRate_cards[P]>
  }




  export type rate_cardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rate_cardsWhereInput
    orderBy?: rate_cardsOrderByWithAggregationInput | rate_cardsOrderByWithAggregationInput[]
    by: Rate_cardsScalarFieldEnum[] | Rate_cardsScalarFieldEnum
    having?: rate_cardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Rate_cardsCountAggregateInputType | true
    _avg?: Rate_cardsAvgAggregateInputType
    _sum?: Rate_cardsSumAggregateInputType
    _min?: Rate_cardsMinAggregateInputType
    _max?: Rate_cardsMaxAggregateInputType
  }

  export type Rate_cardsGroupByOutputType = {
    id: number
    name: string
    base_rate: number
    commission_rate: number | null
    markup_rate: number | null
    discount_amount: number | null
    discount_percent: number | null
    final_rate: number
    currency: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission: number | null
    is_active: boolean
    rack_rate_id: number
    hotel_id: number
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    created_by: number
    public_id: string
    status: $Enums.shared_status
    _count: Rate_cardsCountAggregateOutputType | null
    _avg: Rate_cardsAvgAggregateOutputType | null
    _sum: Rate_cardsSumAggregateOutputType | null
    _min: Rate_cardsMinAggregateOutputType | null
    _max: Rate_cardsMaxAggregateOutputType | null
  }

  type GetRate_cardsGroupByPayload<T extends rate_cardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Rate_cardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Rate_cardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Rate_cardsGroupByOutputType[P]>
            : GetScalarType<T[P], Rate_cardsGroupByOutputType[P]>
        }
      >
    >


  export type rate_cardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    base_rate?: boolean
    commission_rate?: boolean
    markup_rate?: boolean
    discount_amount?: boolean
    discount_percent?: boolean
    final_rate?: boolean
    currency?: boolean
    travel_period?: boolean
    meal_plan?: boolean
    room_category?: boolean
    commission?: boolean
    is_active?: boolean
    rack_rate_id?: boolean
    hotel_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    created_by?: boolean
    public_id?: boolean
    status?: boolean
    quotes?: boolean | rate_cards$quotesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    hotels?: boolean | hotelsDefaultArgs<ExtArgs>
    rack_rates?: boolean | rack_ratesDefaultArgs<ExtArgs>
    _count?: boolean | Rate_cardsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rate_cards"]>



  export type rate_cardsSelectScalar = {
    id?: boolean
    name?: boolean
    base_rate?: boolean
    commission_rate?: boolean
    markup_rate?: boolean
    discount_amount?: boolean
    discount_percent?: boolean
    final_rate?: boolean
    currency?: boolean
    travel_period?: boolean
    meal_plan?: boolean
    room_category?: boolean
    commission?: boolean
    is_active?: boolean
    rack_rate_id?: boolean
    hotel_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    created_by?: boolean
    public_id?: boolean
    status?: boolean
  }

  export type rate_cardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "base_rate" | "commission_rate" | "markup_rate" | "discount_amount" | "discount_percent" | "final_rate" | "currency" | "travel_period" | "meal_plan" | "room_category" | "commission" | "is_active" | "rack_rate_id" | "hotel_id" | "created_at" | "updated_at" | "deleted_at" | "created_by" | "public_id" | "status", ExtArgs["result"]["rate_cards"]>
  export type rate_cardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quotes?: boolean | rate_cards$quotesArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    hotels?: boolean | hotelsDefaultArgs<ExtArgs>
    rack_rates?: boolean | rack_ratesDefaultArgs<ExtArgs>
    _count?: boolean | Rate_cardsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rate_cardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rate_cards"
    objects: {
      quotes: Prisma.$quotesPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
      hotels: Prisma.$hotelsPayload<ExtArgs>
      rack_rates: Prisma.$rack_ratesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      base_rate: number
      commission_rate: number | null
      markup_rate: number | null
      discount_amount: number | null
      discount_percent: number | null
      final_rate: number
      currency: string
      travel_period: $Enums.rate_cards_travel_period
      meal_plan: $Enums.rate_cards_meal_plan
      room_category: $Enums.rate_cards_room_category
      commission: number | null
      is_active: boolean
      rack_rate_id: number
      hotel_id: number
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
      created_by: number
      public_id: string
      status: $Enums.shared_status
    }, ExtArgs["result"]["rate_cards"]>
    composites: {}
  }

  type rate_cardsGetPayload<S extends boolean | null | undefined | rate_cardsDefaultArgs> = $Result.GetResult<Prisma.$rate_cardsPayload, S>

  type rate_cardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rate_cardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Rate_cardsCountAggregateInputType | true
    }

  export interface rate_cardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rate_cards'], meta: { name: 'rate_cards' } }
    /**
     * Find zero or one Rate_cards that matches the filter.
     * @param {rate_cardsFindUniqueArgs} args - Arguments to find a Rate_cards
     * @example
     * // Get one Rate_cards
     * const rate_cards = await prisma.rate_cards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rate_cardsFindUniqueArgs>(args: SelectSubset<T, rate_cardsFindUniqueArgs<ExtArgs>>): Prisma__rate_cardsClient<$Result.GetResult<Prisma.$rate_cardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rate_cards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rate_cardsFindUniqueOrThrowArgs} args - Arguments to find a Rate_cards
     * @example
     * // Get one Rate_cards
     * const rate_cards = await prisma.rate_cards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rate_cardsFindUniqueOrThrowArgs>(args: SelectSubset<T, rate_cardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rate_cardsClient<$Result.GetResult<Prisma.$rate_cardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rate_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rate_cardsFindFirstArgs} args - Arguments to find a Rate_cards
     * @example
     * // Get one Rate_cards
     * const rate_cards = await prisma.rate_cards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rate_cardsFindFirstArgs>(args?: SelectSubset<T, rate_cardsFindFirstArgs<ExtArgs>>): Prisma__rate_cardsClient<$Result.GetResult<Prisma.$rate_cardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rate_cards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rate_cardsFindFirstOrThrowArgs} args - Arguments to find a Rate_cards
     * @example
     * // Get one Rate_cards
     * const rate_cards = await prisma.rate_cards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rate_cardsFindFirstOrThrowArgs>(args?: SelectSubset<T, rate_cardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__rate_cardsClient<$Result.GetResult<Prisma.$rate_cardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rate_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rate_cardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rate_cards
     * const rate_cards = await prisma.rate_cards.findMany()
     * 
     * // Get first 10 Rate_cards
     * const rate_cards = await prisma.rate_cards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rate_cardsWithIdOnly = await prisma.rate_cards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rate_cardsFindManyArgs>(args?: SelectSubset<T, rate_cardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rate_cardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rate_cards.
     * @param {rate_cardsCreateArgs} args - Arguments to create a Rate_cards.
     * @example
     * // Create one Rate_cards
     * const Rate_cards = await prisma.rate_cards.create({
     *   data: {
     *     // ... data to create a Rate_cards
     *   }
     * })
     * 
     */
    create<T extends rate_cardsCreateArgs>(args: SelectSubset<T, rate_cardsCreateArgs<ExtArgs>>): Prisma__rate_cardsClient<$Result.GetResult<Prisma.$rate_cardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rate_cards.
     * @param {rate_cardsCreateManyArgs} args - Arguments to create many Rate_cards.
     * @example
     * // Create many Rate_cards
     * const rate_cards = await prisma.rate_cards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rate_cardsCreateManyArgs>(args?: SelectSubset<T, rate_cardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rate_cards.
     * @param {rate_cardsDeleteArgs} args - Arguments to delete one Rate_cards.
     * @example
     * // Delete one Rate_cards
     * const Rate_cards = await prisma.rate_cards.delete({
     *   where: {
     *     // ... filter to delete one Rate_cards
     *   }
     * })
     * 
     */
    delete<T extends rate_cardsDeleteArgs>(args: SelectSubset<T, rate_cardsDeleteArgs<ExtArgs>>): Prisma__rate_cardsClient<$Result.GetResult<Prisma.$rate_cardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rate_cards.
     * @param {rate_cardsUpdateArgs} args - Arguments to update one Rate_cards.
     * @example
     * // Update one Rate_cards
     * const rate_cards = await prisma.rate_cards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rate_cardsUpdateArgs>(args: SelectSubset<T, rate_cardsUpdateArgs<ExtArgs>>): Prisma__rate_cardsClient<$Result.GetResult<Prisma.$rate_cardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rate_cards.
     * @param {rate_cardsDeleteManyArgs} args - Arguments to filter Rate_cards to delete.
     * @example
     * // Delete a few Rate_cards
     * const { count } = await prisma.rate_cards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rate_cardsDeleteManyArgs>(args?: SelectSubset<T, rate_cardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rate_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rate_cardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rate_cards
     * const rate_cards = await prisma.rate_cards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rate_cardsUpdateManyArgs>(args: SelectSubset<T, rate_cardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rate_cards.
     * @param {rate_cardsUpsertArgs} args - Arguments to update or create a Rate_cards.
     * @example
     * // Update or create a Rate_cards
     * const rate_cards = await prisma.rate_cards.upsert({
     *   create: {
     *     // ... data to create a Rate_cards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rate_cards we want to update
     *   }
     * })
     */
    upsert<T extends rate_cardsUpsertArgs>(args: SelectSubset<T, rate_cardsUpsertArgs<ExtArgs>>): Prisma__rate_cardsClient<$Result.GetResult<Prisma.$rate_cardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rate_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rate_cardsCountArgs} args - Arguments to filter Rate_cards to count.
     * @example
     * // Count the number of Rate_cards
     * const count = await prisma.rate_cards.count({
     *   where: {
     *     // ... the filter for the Rate_cards we want to count
     *   }
     * })
    **/
    count<T extends rate_cardsCountArgs>(
      args?: Subset<T, rate_cardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Rate_cardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rate_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Rate_cardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Rate_cardsAggregateArgs>(args: Subset<T, Rate_cardsAggregateArgs>): Prisma.PrismaPromise<GetRate_cardsAggregateType<T>>

    /**
     * Group by Rate_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rate_cardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rate_cardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rate_cardsGroupByArgs['orderBy'] }
        : { orderBy?: rate_cardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rate_cardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRate_cardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rate_cards model
   */
  readonly fields: rate_cardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rate_cards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rate_cardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quotes<T extends rate_cards$quotesArgs<ExtArgs> = {}>(args?: Subset<T, rate_cards$quotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quotesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    hotels<T extends hotelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, hotelsDefaultArgs<ExtArgs>>): Prisma__hotelsClient<$Result.GetResult<Prisma.$hotelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rack_rates<T extends rack_ratesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rack_ratesDefaultArgs<ExtArgs>>): Prisma__rack_ratesClient<$Result.GetResult<Prisma.$rack_ratesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rate_cards model
   */
  interface rate_cardsFieldRefs {
    readonly id: FieldRef<"rate_cards", 'Int'>
    readonly name: FieldRef<"rate_cards", 'String'>
    readonly base_rate: FieldRef<"rate_cards", 'Float'>
    readonly commission_rate: FieldRef<"rate_cards", 'Float'>
    readonly markup_rate: FieldRef<"rate_cards", 'Float'>
    readonly discount_amount: FieldRef<"rate_cards", 'Float'>
    readonly discount_percent: FieldRef<"rate_cards", 'Float'>
    readonly final_rate: FieldRef<"rate_cards", 'Float'>
    readonly currency: FieldRef<"rate_cards", 'String'>
    readonly travel_period: FieldRef<"rate_cards", 'rate_cards_travel_period'>
    readonly meal_plan: FieldRef<"rate_cards", 'rate_cards_meal_plan'>
    readonly room_category: FieldRef<"rate_cards", 'rate_cards_room_category'>
    readonly commission: FieldRef<"rate_cards", 'Float'>
    readonly is_active: FieldRef<"rate_cards", 'Boolean'>
    readonly rack_rate_id: FieldRef<"rate_cards", 'Int'>
    readonly hotel_id: FieldRef<"rate_cards", 'Int'>
    readonly created_at: FieldRef<"rate_cards", 'DateTime'>
    readonly updated_at: FieldRef<"rate_cards", 'DateTime'>
    readonly deleted_at: FieldRef<"rate_cards", 'DateTime'>
    readonly created_by: FieldRef<"rate_cards", 'Int'>
    readonly public_id: FieldRef<"rate_cards", 'String'>
    readonly status: FieldRef<"rate_cards", 'shared_status'>
  }
    

  // Custom InputTypes
  /**
   * rate_cards findUnique
   */
  export type rate_cardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate_cards
     */
    select?: rate_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate_cards
     */
    omit?: rate_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rate_cardsInclude<ExtArgs> | null
    /**
     * Filter, which rate_cards to fetch.
     */
    where: rate_cardsWhereUniqueInput
  }

  /**
   * rate_cards findUniqueOrThrow
   */
  export type rate_cardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate_cards
     */
    select?: rate_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate_cards
     */
    omit?: rate_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rate_cardsInclude<ExtArgs> | null
    /**
     * Filter, which rate_cards to fetch.
     */
    where: rate_cardsWhereUniqueInput
  }

  /**
   * rate_cards findFirst
   */
  export type rate_cardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate_cards
     */
    select?: rate_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate_cards
     */
    omit?: rate_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rate_cardsInclude<ExtArgs> | null
    /**
     * Filter, which rate_cards to fetch.
     */
    where?: rate_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rate_cards to fetch.
     */
    orderBy?: rate_cardsOrderByWithRelationInput | rate_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rate_cards.
     */
    cursor?: rate_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rate_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rate_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rate_cards.
     */
    distinct?: Rate_cardsScalarFieldEnum | Rate_cardsScalarFieldEnum[]
  }

  /**
   * rate_cards findFirstOrThrow
   */
  export type rate_cardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate_cards
     */
    select?: rate_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate_cards
     */
    omit?: rate_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rate_cardsInclude<ExtArgs> | null
    /**
     * Filter, which rate_cards to fetch.
     */
    where?: rate_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rate_cards to fetch.
     */
    orderBy?: rate_cardsOrderByWithRelationInput | rate_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rate_cards.
     */
    cursor?: rate_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rate_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rate_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rate_cards.
     */
    distinct?: Rate_cardsScalarFieldEnum | Rate_cardsScalarFieldEnum[]
  }

  /**
   * rate_cards findMany
   */
  export type rate_cardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate_cards
     */
    select?: rate_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate_cards
     */
    omit?: rate_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rate_cardsInclude<ExtArgs> | null
    /**
     * Filter, which rate_cards to fetch.
     */
    where?: rate_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rate_cards to fetch.
     */
    orderBy?: rate_cardsOrderByWithRelationInput | rate_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rate_cards.
     */
    cursor?: rate_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rate_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rate_cards.
     */
    skip?: number
    distinct?: Rate_cardsScalarFieldEnum | Rate_cardsScalarFieldEnum[]
  }

  /**
   * rate_cards create
   */
  export type rate_cardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate_cards
     */
    select?: rate_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate_cards
     */
    omit?: rate_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rate_cardsInclude<ExtArgs> | null
    /**
     * The data needed to create a rate_cards.
     */
    data: XOR<rate_cardsCreateInput, rate_cardsUncheckedCreateInput>
  }

  /**
   * rate_cards createMany
   */
  export type rate_cardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rate_cards.
     */
    data: rate_cardsCreateManyInput | rate_cardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rate_cards update
   */
  export type rate_cardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate_cards
     */
    select?: rate_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate_cards
     */
    omit?: rate_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rate_cardsInclude<ExtArgs> | null
    /**
     * The data needed to update a rate_cards.
     */
    data: XOR<rate_cardsUpdateInput, rate_cardsUncheckedUpdateInput>
    /**
     * Choose, which rate_cards to update.
     */
    where: rate_cardsWhereUniqueInput
  }

  /**
   * rate_cards updateMany
   */
  export type rate_cardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rate_cards.
     */
    data: XOR<rate_cardsUpdateManyMutationInput, rate_cardsUncheckedUpdateManyInput>
    /**
     * Filter which rate_cards to update
     */
    where?: rate_cardsWhereInput
    /**
     * Limit how many rate_cards to update.
     */
    limit?: number
  }

  /**
   * rate_cards upsert
   */
  export type rate_cardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate_cards
     */
    select?: rate_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate_cards
     */
    omit?: rate_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rate_cardsInclude<ExtArgs> | null
    /**
     * The filter to search for the rate_cards to update in case it exists.
     */
    where: rate_cardsWhereUniqueInput
    /**
     * In case the rate_cards found by the `where` argument doesn't exist, create a new rate_cards with this data.
     */
    create: XOR<rate_cardsCreateInput, rate_cardsUncheckedCreateInput>
    /**
     * In case the rate_cards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rate_cardsUpdateInput, rate_cardsUncheckedUpdateInput>
  }

  /**
   * rate_cards delete
   */
  export type rate_cardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate_cards
     */
    select?: rate_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate_cards
     */
    omit?: rate_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rate_cardsInclude<ExtArgs> | null
    /**
     * Filter which rate_cards to delete.
     */
    where: rate_cardsWhereUniqueInput
  }

  /**
   * rate_cards deleteMany
   */
  export type rate_cardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rate_cards to delete
     */
    where?: rate_cardsWhereInput
    /**
     * Limit how many rate_cards to delete.
     */
    limit?: number
  }

  /**
   * rate_cards.quotes
   */
  export type rate_cards$quotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quotes
     */
    select?: quotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quotes
     */
    omit?: quotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quotesInclude<ExtArgs> | null
    where?: quotesWhereInput
    orderBy?: quotesOrderByWithRelationInput | quotesOrderByWithRelationInput[]
    cursor?: quotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuotesScalarFieldEnum | QuotesScalarFieldEnum[]
  }

  /**
   * rate_cards without action
   */
  export type rate_cardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate_cards
     */
    select?: rate_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate_cards
     */
    omit?: rate_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rate_cardsInclude<ExtArgs> | null
  }


  /**
   * Model reminders
   */

  export type AggregateReminders = {
    _count: RemindersCountAggregateOutputType | null
    _avg: RemindersAvgAggregateOutputType | null
    _sum: RemindersSumAggregateOutputType | null
    _min: RemindersMinAggregateOutputType | null
    _max: RemindersMaxAggregateOutputType | null
  }

  export type RemindersAvgAggregateOutputType = {
    id: number | null
    invoice_id: number | null
  }

  export type RemindersSumAggregateOutputType = {
    id: number | null
    invoice_id: number | null
  }

  export type RemindersMinAggregateOutputType = {
    id: number | null
    invoice_id: number | null
    reminder_date: Date | null
    message: string | null
    is_sent: boolean | null
    sent_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status | null
  }

  export type RemindersMaxAggregateOutputType = {
    id: number | null
    invoice_id: number | null
    reminder_date: Date | null
    message: string | null
    is_sent: boolean | null
    sent_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status | null
  }

  export type RemindersCountAggregateOutputType = {
    id: number
    invoice_id: number
    reminder_date: number
    message: number
    is_sent: number
    sent_at: number
    created_at: number
    updated_at: number
    deleted_at: number
    status: number
    _all: number
  }


  export type RemindersAvgAggregateInputType = {
    id?: true
    invoice_id?: true
  }

  export type RemindersSumAggregateInputType = {
    id?: true
    invoice_id?: true
  }

  export type RemindersMinAggregateInputType = {
    id?: true
    invoice_id?: true
    reminder_date?: true
    message?: true
    is_sent?: true
    sent_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
  }

  export type RemindersMaxAggregateInputType = {
    id?: true
    invoice_id?: true
    reminder_date?: true
    message?: true
    is_sent?: true
    sent_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
  }

  export type RemindersCountAggregateInputType = {
    id?: true
    invoice_id?: true
    reminder_date?: true
    message?: true
    is_sent?: true
    sent_at?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
    _all?: true
  }

  export type RemindersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reminders to aggregate.
     */
    where?: remindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reminders to fetch.
     */
    orderBy?: remindersOrderByWithRelationInput | remindersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: remindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reminders
    **/
    _count?: true | RemindersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RemindersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RemindersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RemindersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RemindersMaxAggregateInputType
  }

  export type GetRemindersAggregateType<T extends RemindersAggregateArgs> = {
        [P in keyof T & keyof AggregateReminders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReminders[P]>
      : GetScalarType<T[P], AggregateReminders[P]>
  }




  export type remindersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: remindersWhereInput
    orderBy?: remindersOrderByWithAggregationInput | remindersOrderByWithAggregationInput[]
    by: RemindersScalarFieldEnum[] | RemindersScalarFieldEnum
    having?: remindersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RemindersCountAggregateInputType | true
    _avg?: RemindersAvgAggregateInputType
    _sum?: RemindersSumAggregateInputType
    _min?: RemindersMinAggregateInputType
    _max?: RemindersMaxAggregateInputType
  }

  export type RemindersGroupByOutputType = {
    id: number
    invoice_id: number
    reminder_date: Date
    message: string
    is_sent: boolean
    sent_at: Date | null
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status
    _count: RemindersCountAggregateOutputType | null
    _avg: RemindersAvgAggregateOutputType | null
    _sum: RemindersSumAggregateOutputType | null
    _min: RemindersMinAggregateOutputType | null
    _max: RemindersMaxAggregateOutputType | null
  }

  type GetRemindersGroupByPayload<T extends remindersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RemindersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RemindersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RemindersGroupByOutputType[P]>
            : GetScalarType<T[P], RemindersGroupByOutputType[P]>
        }
      >
    >


  export type remindersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    reminder_date?: boolean
    message?: boolean
    is_sent?: boolean
    sent_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    status?: boolean
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reminders"]>



  export type remindersSelectScalar = {
    id?: boolean
    invoice_id?: boolean
    reminder_date?: boolean
    message?: boolean
    is_sent?: boolean
    sent_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    status?: boolean
  }

  export type remindersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_id" | "reminder_date" | "message" | "is_sent" | "sent_at" | "created_at" | "updated_at" | "deleted_at" | "status", ExtArgs["result"]["reminders"]>
  export type remindersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | invoicesDefaultArgs<ExtArgs>
  }

  export type $remindersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reminders"
    objects: {
      invoices: Prisma.$invoicesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      invoice_id: number
      reminder_date: Date
      message: string
      is_sent: boolean
      sent_at: Date | null
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
      status: $Enums.shared_status
    }, ExtArgs["result"]["reminders"]>
    composites: {}
  }

  type remindersGetPayload<S extends boolean | null | undefined | remindersDefaultArgs> = $Result.GetResult<Prisma.$remindersPayload, S>

  type remindersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<remindersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RemindersCountAggregateInputType | true
    }

  export interface remindersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reminders'], meta: { name: 'reminders' } }
    /**
     * Find zero or one Reminders that matches the filter.
     * @param {remindersFindUniqueArgs} args - Arguments to find a Reminders
     * @example
     * // Get one Reminders
     * const reminders = await prisma.reminders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends remindersFindUniqueArgs>(args: SelectSubset<T, remindersFindUniqueArgs<ExtArgs>>): Prisma__remindersClient<$Result.GetResult<Prisma.$remindersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reminders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {remindersFindUniqueOrThrowArgs} args - Arguments to find a Reminders
     * @example
     * // Get one Reminders
     * const reminders = await prisma.reminders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends remindersFindUniqueOrThrowArgs>(args: SelectSubset<T, remindersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__remindersClient<$Result.GetResult<Prisma.$remindersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {remindersFindFirstArgs} args - Arguments to find a Reminders
     * @example
     * // Get one Reminders
     * const reminders = await prisma.reminders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends remindersFindFirstArgs>(args?: SelectSubset<T, remindersFindFirstArgs<ExtArgs>>): Prisma__remindersClient<$Result.GetResult<Prisma.$remindersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reminders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {remindersFindFirstOrThrowArgs} args - Arguments to find a Reminders
     * @example
     * // Get one Reminders
     * const reminders = await prisma.reminders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends remindersFindFirstOrThrowArgs>(args?: SelectSubset<T, remindersFindFirstOrThrowArgs<ExtArgs>>): Prisma__remindersClient<$Result.GetResult<Prisma.$remindersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {remindersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reminders
     * const reminders = await prisma.reminders.findMany()
     * 
     * // Get first 10 Reminders
     * const reminders = await prisma.reminders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const remindersWithIdOnly = await prisma.reminders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends remindersFindManyArgs>(args?: SelectSubset<T, remindersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$remindersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reminders.
     * @param {remindersCreateArgs} args - Arguments to create a Reminders.
     * @example
     * // Create one Reminders
     * const Reminders = await prisma.reminders.create({
     *   data: {
     *     // ... data to create a Reminders
     *   }
     * })
     * 
     */
    create<T extends remindersCreateArgs>(args: SelectSubset<T, remindersCreateArgs<ExtArgs>>): Prisma__remindersClient<$Result.GetResult<Prisma.$remindersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reminders.
     * @param {remindersCreateManyArgs} args - Arguments to create many Reminders.
     * @example
     * // Create many Reminders
     * const reminders = await prisma.reminders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends remindersCreateManyArgs>(args?: SelectSubset<T, remindersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reminders.
     * @param {remindersDeleteArgs} args - Arguments to delete one Reminders.
     * @example
     * // Delete one Reminders
     * const Reminders = await prisma.reminders.delete({
     *   where: {
     *     // ... filter to delete one Reminders
     *   }
     * })
     * 
     */
    delete<T extends remindersDeleteArgs>(args: SelectSubset<T, remindersDeleteArgs<ExtArgs>>): Prisma__remindersClient<$Result.GetResult<Prisma.$remindersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reminders.
     * @param {remindersUpdateArgs} args - Arguments to update one Reminders.
     * @example
     * // Update one Reminders
     * const reminders = await prisma.reminders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends remindersUpdateArgs>(args: SelectSubset<T, remindersUpdateArgs<ExtArgs>>): Prisma__remindersClient<$Result.GetResult<Prisma.$remindersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reminders.
     * @param {remindersDeleteManyArgs} args - Arguments to filter Reminders to delete.
     * @example
     * // Delete a few Reminders
     * const { count } = await prisma.reminders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends remindersDeleteManyArgs>(args?: SelectSubset<T, remindersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {remindersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reminders
     * const reminders = await prisma.reminders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends remindersUpdateManyArgs>(args: SelectSubset<T, remindersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reminders.
     * @param {remindersUpsertArgs} args - Arguments to update or create a Reminders.
     * @example
     * // Update or create a Reminders
     * const reminders = await prisma.reminders.upsert({
     *   create: {
     *     // ... data to create a Reminders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reminders we want to update
     *   }
     * })
     */
    upsert<T extends remindersUpsertArgs>(args: SelectSubset<T, remindersUpsertArgs<ExtArgs>>): Prisma__remindersClient<$Result.GetResult<Prisma.$remindersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {remindersCountArgs} args - Arguments to filter Reminders to count.
     * @example
     * // Count the number of Reminders
     * const count = await prisma.reminders.count({
     *   where: {
     *     // ... the filter for the Reminders we want to count
     *   }
     * })
    **/
    count<T extends remindersCountArgs>(
      args?: Subset<T, remindersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RemindersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RemindersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RemindersAggregateArgs>(args: Subset<T, RemindersAggregateArgs>): Prisma.PrismaPromise<GetRemindersAggregateType<T>>

    /**
     * Group by Reminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {remindersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends remindersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: remindersGroupByArgs['orderBy'] }
        : { orderBy?: remindersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, remindersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRemindersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reminders model
   */
  readonly fields: remindersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reminders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__remindersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoices<T extends invoicesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, invoicesDefaultArgs<ExtArgs>>): Prisma__invoicesClient<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reminders model
   */
  interface remindersFieldRefs {
    readonly id: FieldRef<"reminders", 'Int'>
    readonly invoice_id: FieldRef<"reminders", 'Int'>
    readonly reminder_date: FieldRef<"reminders", 'DateTime'>
    readonly message: FieldRef<"reminders", 'String'>
    readonly is_sent: FieldRef<"reminders", 'Boolean'>
    readonly sent_at: FieldRef<"reminders", 'DateTime'>
    readonly created_at: FieldRef<"reminders", 'DateTime'>
    readonly updated_at: FieldRef<"reminders", 'DateTime'>
    readonly deleted_at: FieldRef<"reminders", 'DateTime'>
    readonly status: FieldRef<"reminders", 'shared_status'>
  }
    

  // Custom InputTypes
  /**
   * reminders findUnique
   */
  export type remindersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reminders
     */
    omit?: remindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: remindersInclude<ExtArgs> | null
    /**
     * Filter, which reminders to fetch.
     */
    where: remindersWhereUniqueInput
  }

  /**
   * reminders findUniqueOrThrow
   */
  export type remindersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reminders
     */
    omit?: remindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: remindersInclude<ExtArgs> | null
    /**
     * Filter, which reminders to fetch.
     */
    where: remindersWhereUniqueInput
  }

  /**
   * reminders findFirst
   */
  export type remindersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reminders
     */
    omit?: remindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: remindersInclude<ExtArgs> | null
    /**
     * Filter, which reminders to fetch.
     */
    where?: remindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reminders to fetch.
     */
    orderBy?: remindersOrderByWithRelationInput | remindersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reminders.
     */
    cursor?: remindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reminders.
     */
    distinct?: RemindersScalarFieldEnum | RemindersScalarFieldEnum[]
  }

  /**
   * reminders findFirstOrThrow
   */
  export type remindersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reminders
     */
    omit?: remindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: remindersInclude<ExtArgs> | null
    /**
     * Filter, which reminders to fetch.
     */
    where?: remindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reminders to fetch.
     */
    orderBy?: remindersOrderByWithRelationInput | remindersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reminders.
     */
    cursor?: remindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reminders.
     */
    distinct?: RemindersScalarFieldEnum | RemindersScalarFieldEnum[]
  }

  /**
   * reminders findMany
   */
  export type remindersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reminders
     */
    omit?: remindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: remindersInclude<ExtArgs> | null
    /**
     * Filter, which reminders to fetch.
     */
    where?: remindersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reminders to fetch.
     */
    orderBy?: remindersOrderByWithRelationInput | remindersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reminders.
     */
    cursor?: remindersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reminders.
     */
    skip?: number
    distinct?: RemindersScalarFieldEnum | RemindersScalarFieldEnum[]
  }

  /**
   * reminders create
   */
  export type remindersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reminders
     */
    omit?: remindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: remindersInclude<ExtArgs> | null
    /**
     * The data needed to create a reminders.
     */
    data: XOR<remindersCreateInput, remindersUncheckedCreateInput>
  }

  /**
   * reminders createMany
   */
  export type remindersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reminders.
     */
    data: remindersCreateManyInput | remindersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reminders update
   */
  export type remindersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reminders
     */
    omit?: remindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: remindersInclude<ExtArgs> | null
    /**
     * The data needed to update a reminders.
     */
    data: XOR<remindersUpdateInput, remindersUncheckedUpdateInput>
    /**
     * Choose, which reminders to update.
     */
    where: remindersWhereUniqueInput
  }

  /**
   * reminders updateMany
   */
  export type remindersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reminders.
     */
    data: XOR<remindersUpdateManyMutationInput, remindersUncheckedUpdateManyInput>
    /**
     * Filter which reminders to update
     */
    where?: remindersWhereInput
    /**
     * Limit how many reminders to update.
     */
    limit?: number
  }

  /**
   * reminders upsert
   */
  export type remindersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reminders
     */
    omit?: remindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: remindersInclude<ExtArgs> | null
    /**
     * The filter to search for the reminders to update in case it exists.
     */
    where: remindersWhereUniqueInput
    /**
     * In case the reminders found by the `where` argument doesn't exist, create a new reminders with this data.
     */
    create: XOR<remindersCreateInput, remindersUncheckedCreateInput>
    /**
     * In case the reminders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<remindersUpdateInput, remindersUncheckedUpdateInput>
  }

  /**
   * reminders delete
   */
  export type remindersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reminders
     */
    omit?: remindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: remindersInclude<ExtArgs> | null
    /**
     * Filter which reminders to delete.
     */
    where: remindersWhereUniqueInput
  }

  /**
   * reminders deleteMany
   */
  export type remindersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reminders to delete
     */
    where?: remindersWhereInput
    /**
     * Limit how many reminders to delete.
     */
    limit?: number
  }

  /**
   * reminders without action
   */
  export type remindersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reminders
     */
    select?: remindersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reminders
     */
    omit?: remindersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: remindersInclude<ExtArgs> | null
  }


  /**
   * Model seasons
   */

  export type AggregateSeasons = {
    _count: SeasonsCountAggregateOutputType | null
    _avg: SeasonsAvgAggregateOutputType | null
    _sum: SeasonsSumAggregateOutputType | null
    _min: SeasonsMinAggregateOutputType | null
    _max: SeasonsMaxAggregateOutputType | null
  }

  export type SeasonsAvgAggregateOutputType = {
    id: number | null
    hotel_policy_id: number | null
  }

  export type SeasonsSumAggregateOutputType = {
    id: number | null
    hotel_policy_id: number | null
  }

  export type SeasonsMinAggregateOutputType = {
    id: number | null
    name: string | null
    period_type: $Enums.seasons_period_type | null
    start_date: Date | null
    end_date: Date | null
    hotel_policy_id: number | null
    created_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status | null
    updated_at: Date | null
  }

  export type SeasonsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    period_type: $Enums.seasons_period_type | null
    start_date: Date | null
    end_date: Date | null
    hotel_policy_id: number | null
    created_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status | null
    updated_at: Date | null
  }

  export type SeasonsCountAggregateOutputType = {
    id: number
    name: number
    period_type: number
    start_date: number
    end_date: number
    hotel_policy_id: number
    created_at: number
    deleted_at: number
    status: number
    updated_at: number
    _all: number
  }


  export type SeasonsAvgAggregateInputType = {
    id?: true
    hotel_policy_id?: true
  }

  export type SeasonsSumAggregateInputType = {
    id?: true
    hotel_policy_id?: true
  }

  export type SeasonsMinAggregateInputType = {
    id?: true
    name?: true
    period_type?: true
    start_date?: true
    end_date?: true
    hotel_policy_id?: true
    created_at?: true
    deleted_at?: true
    status?: true
    updated_at?: true
  }

  export type SeasonsMaxAggregateInputType = {
    id?: true
    name?: true
    period_type?: true
    start_date?: true
    end_date?: true
    hotel_policy_id?: true
    created_at?: true
    deleted_at?: true
    status?: true
    updated_at?: true
  }

  export type SeasonsCountAggregateInputType = {
    id?: true
    name?: true
    period_type?: true
    start_date?: true
    end_date?: true
    hotel_policy_id?: true
    created_at?: true
    deleted_at?: true
    status?: true
    updated_at?: true
    _all?: true
  }

  export type SeasonsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which seasons to aggregate.
     */
    where?: seasonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: seasonsOrderByWithRelationInput | seasonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: seasonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned seasons
    **/
    _count?: true | SeasonsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeasonsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeasonsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonsMaxAggregateInputType
  }

  export type GetSeasonsAggregateType<T extends SeasonsAggregateArgs> = {
        [P in keyof T & keyof AggregateSeasons]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeasons[P]>
      : GetScalarType<T[P], AggregateSeasons[P]>
  }




  export type seasonsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: seasonsWhereInput
    orderBy?: seasonsOrderByWithAggregationInput | seasonsOrderByWithAggregationInput[]
    by: SeasonsScalarFieldEnum[] | SeasonsScalarFieldEnum
    having?: seasonsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonsCountAggregateInputType | true
    _avg?: SeasonsAvgAggregateInputType
    _sum?: SeasonsSumAggregateInputType
    _min?: SeasonsMinAggregateInputType
    _max?: SeasonsMaxAggregateInputType
  }

  export type SeasonsGroupByOutputType = {
    id: number
    name: string
    period_type: $Enums.seasons_period_type
    start_date: Date
    end_date: Date
    hotel_policy_id: number
    created_at: Date
    deleted_at: Date | null
    status: $Enums.shared_status
    updated_at: Date | null
    _count: SeasonsCountAggregateOutputType | null
    _avg: SeasonsAvgAggregateOutputType | null
    _sum: SeasonsSumAggregateOutputType | null
    _min: SeasonsMinAggregateOutputType | null
    _max: SeasonsMaxAggregateOutputType | null
  }

  type GetSeasonsGroupByPayload<T extends seasonsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeasonsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonsGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonsGroupByOutputType[P]>
        }
      >
    >


  export type seasonsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    period_type?: boolean
    start_date?: boolean
    end_date?: boolean
    hotel_policy_id?: boolean
    created_at?: boolean
    deleted_at?: boolean
    status?: boolean
    updated_at?: boolean
    hotel_policies?: boolean | hotel_policiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seasons"]>



  export type seasonsSelectScalar = {
    id?: boolean
    name?: boolean
    period_type?: boolean
    start_date?: boolean
    end_date?: boolean
    hotel_policy_id?: boolean
    created_at?: boolean
    deleted_at?: boolean
    status?: boolean
    updated_at?: boolean
  }

  export type seasonsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "period_type" | "start_date" | "end_date" | "hotel_policy_id" | "created_at" | "deleted_at" | "status" | "updated_at", ExtArgs["result"]["seasons"]>
  export type seasonsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    hotel_policies?: boolean | hotel_policiesDefaultArgs<ExtArgs>
  }

  export type $seasonsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "seasons"
    objects: {
      hotel_policies: Prisma.$hotel_policiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      period_type: $Enums.seasons_period_type
      start_date: Date
      end_date: Date
      hotel_policy_id: number
      created_at: Date
      deleted_at: Date | null
      status: $Enums.shared_status
      updated_at: Date | null
    }, ExtArgs["result"]["seasons"]>
    composites: {}
  }

  type seasonsGetPayload<S extends boolean | null | undefined | seasonsDefaultArgs> = $Result.GetResult<Prisma.$seasonsPayload, S>

  type seasonsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<seasonsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeasonsCountAggregateInputType | true
    }

  export interface seasonsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['seasons'], meta: { name: 'seasons' } }
    /**
     * Find zero or one Seasons that matches the filter.
     * @param {seasonsFindUniqueArgs} args - Arguments to find a Seasons
     * @example
     * // Get one Seasons
     * const seasons = await prisma.seasons.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends seasonsFindUniqueArgs>(args: SelectSubset<T, seasonsFindUniqueArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Seasons that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {seasonsFindUniqueOrThrowArgs} args - Arguments to find a Seasons
     * @example
     * // Get one Seasons
     * const seasons = await prisma.seasons.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends seasonsFindUniqueOrThrowArgs>(args: SelectSubset<T, seasonsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsFindFirstArgs} args - Arguments to find a Seasons
     * @example
     * // Get one Seasons
     * const seasons = await prisma.seasons.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends seasonsFindFirstArgs>(args?: SelectSubset<T, seasonsFindFirstArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seasons that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsFindFirstOrThrowArgs} args - Arguments to find a Seasons
     * @example
     * // Get one Seasons
     * const seasons = await prisma.seasons.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends seasonsFindFirstOrThrowArgs>(args?: SelectSubset<T, seasonsFindFirstOrThrowArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seasons
     * const seasons = await prisma.seasons.findMany()
     * 
     * // Get first 10 Seasons
     * const seasons = await prisma.seasons.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonsWithIdOnly = await prisma.seasons.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends seasonsFindManyArgs>(args?: SelectSubset<T, seasonsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Seasons.
     * @param {seasonsCreateArgs} args - Arguments to create a Seasons.
     * @example
     * // Create one Seasons
     * const Seasons = await prisma.seasons.create({
     *   data: {
     *     // ... data to create a Seasons
     *   }
     * })
     * 
     */
    create<T extends seasonsCreateArgs>(args: SelectSubset<T, seasonsCreateArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Seasons.
     * @param {seasonsCreateManyArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const seasons = await prisma.seasons.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends seasonsCreateManyArgs>(args?: SelectSubset<T, seasonsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Seasons.
     * @param {seasonsDeleteArgs} args - Arguments to delete one Seasons.
     * @example
     * // Delete one Seasons
     * const Seasons = await prisma.seasons.delete({
     *   where: {
     *     // ... filter to delete one Seasons
     *   }
     * })
     * 
     */
    delete<T extends seasonsDeleteArgs>(args: SelectSubset<T, seasonsDeleteArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Seasons.
     * @param {seasonsUpdateArgs} args - Arguments to update one Seasons.
     * @example
     * // Update one Seasons
     * const seasons = await prisma.seasons.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends seasonsUpdateArgs>(args: SelectSubset<T, seasonsUpdateArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Seasons.
     * @param {seasonsDeleteManyArgs} args - Arguments to filter Seasons to delete.
     * @example
     * // Delete a few Seasons
     * const { count } = await prisma.seasons.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends seasonsDeleteManyArgs>(args?: SelectSubset<T, seasonsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seasons
     * const seasons = await prisma.seasons.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends seasonsUpdateManyArgs>(args: SelectSubset<T, seasonsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seasons.
     * @param {seasonsUpsertArgs} args - Arguments to update or create a Seasons.
     * @example
     * // Update or create a Seasons
     * const seasons = await prisma.seasons.upsert({
     *   create: {
     *     // ... data to create a Seasons
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seasons we want to update
     *   }
     * })
     */
    upsert<T extends seasonsUpsertArgs>(args: SelectSubset<T, seasonsUpsertArgs<ExtArgs>>): Prisma__seasonsClient<$Result.GetResult<Prisma.$seasonsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsCountArgs} args - Arguments to filter Seasons to count.
     * @example
     * // Count the number of Seasons
     * const count = await prisma.seasons.count({
     *   where: {
     *     // ... the filter for the Seasons we want to count
     *   }
     * })
    **/
    count<T extends seasonsCountArgs>(
      args?: Subset<T, seasonsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonsAggregateArgs>(args: Subset<T, SeasonsAggregateArgs>): Prisma.PrismaPromise<GetSeasonsAggregateType<T>>

    /**
     * Group by Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends seasonsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: seasonsGroupByArgs['orderBy'] }
        : { orderBy?: seasonsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, seasonsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the seasons model
   */
  readonly fields: seasonsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for seasons.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__seasonsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    hotel_policies<T extends hotel_policiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, hotel_policiesDefaultArgs<ExtArgs>>): Prisma__hotel_policiesClient<$Result.GetResult<Prisma.$hotel_policiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the seasons model
   */
  interface seasonsFieldRefs {
    readonly id: FieldRef<"seasons", 'Int'>
    readonly name: FieldRef<"seasons", 'String'>
    readonly period_type: FieldRef<"seasons", 'seasons_period_type'>
    readonly start_date: FieldRef<"seasons", 'DateTime'>
    readonly end_date: FieldRef<"seasons", 'DateTime'>
    readonly hotel_policy_id: FieldRef<"seasons", 'Int'>
    readonly created_at: FieldRef<"seasons", 'DateTime'>
    readonly deleted_at: FieldRef<"seasons", 'DateTime'>
    readonly status: FieldRef<"seasons", 'shared_status'>
    readonly updated_at: FieldRef<"seasons", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * seasons findUnique
   */
  export type seasonsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seasons
     */
    omit?: seasonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where: seasonsWhereUniqueInput
  }

  /**
   * seasons findUniqueOrThrow
   */
  export type seasonsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seasons
     */
    omit?: seasonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where: seasonsWhereUniqueInput
  }

  /**
   * seasons findFirst
   */
  export type seasonsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seasons
     */
    omit?: seasonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where?: seasonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: seasonsOrderByWithRelationInput | seasonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seasons.
     */
    cursor?: seasonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seasons.
     */
    distinct?: SeasonsScalarFieldEnum | SeasonsScalarFieldEnum[]
  }

  /**
   * seasons findFirstOrThrow
   */
  export type seasonsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seasons
     */
    omit?: seasonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where?: seasonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: seasonsOrderByWithRelationInput | seasonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seasons.
     */
    cursor?: seasonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seasons.
     */
    distinct?: SeasonsScalarFieldEnum | SeasonsScalarFieldEnum[]
  }

  /**
   * seasons findMany
   */
  export type seasonsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seasons
     */
    omit?: seasonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * Filter, which seasons to fetch.
     */
    where?: seasonsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: seasonsOrderByWithRelationInput | seasonsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing seasons.
     */
    cursor?: seasonsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    distinct?: SeasonsScalarFieldEnum | SeasonsScalarFieldEnum[]
  }

  /**
   * seasons create
   */
  export type seasonsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seasons
     */
    omit?: seasonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * The data needed to create a seasons.
     */
    data: XOR<seasonsCreateInput, seasonsUncheckedCreateInput>
  }

  /**
   * seasons createMany
   */
  export type seasonsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many seasons.
     */
    data: seasonsCreateManyInput | seasonsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * seasons update
   */
  export type seasonsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seasons
     */
    omit?: seasonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * The data needed to update a seasons.
     */
    data: XOR<seasonsUpdateInput, seasonsUncheckedUpdateInput>
    /**
     * Choose, which seasons to update.
     */
    where: seasonsWhereUniqueInput
  }

  /**
   * seasons updateMany
   */
  export type seasonsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update seasons.
     */
    data: XOR<seasonsUpdateManyMutationInput, seasonsUncheckedUpdateManyInput>
    /**
     * Filter which seasons to update
     */
    where?: seasonsWhereInput
    /**
     * Limit how many seasons to update.
     */
    limit?: number
  }

  /**
   * seasons upsert
   */
  export type seasonsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seasons
     */
    omit?: seasonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * The filter to search for the seasons to update in case it exists.
     */
    where: seasonsWhereUniqueInput
    /**
     * In case the seasons found by the `where` argument doesn't exist, create a new seasons with this data.
     */
    create: XOR<seasonsCreateInput, seasonsUncheckedCreateInput>
    /**
     * In case the seasons was found with the provided `where` argument, update it with this data.
     */
    update: XOR<seasonsUpdateInput, seasonsUncheckedUpdateInput>
  }

  /**
   * seasons delete
   */
  export type seasonsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seasons
     */
    omit?: seasonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
    /**
     * Filter which seasons to delete.
     */
    where: seasonsWhereUniqueInput
  }

  /**
   * seasons deleteMany
   */
  export type seasonsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which seasons to delete
     */
    where?: seasonsWhereInput
    /**
     * Limit how many seasons to delete.
     */
    limit?: number
  }

  /**
   * seasons without action
   */
  export type seasonsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the seasons
     */
    select?: seasonsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the seasons
     */
    omit?: seasonsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seasonsInclude<ExtArgs> | null
  }


  /**
   * Model sessions
   */

  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type SessionsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type SessionsMinAggregateOutputType = {
    id: number | null
    session_token: string | null
    user_id: number | null
    created_at: Date | null
    updated_at: Date | null
    status: $Enums.shared_status | null
    deleted_at: Date | null
    expires_at: Date | null
  }

  export type SessionsMaxAggregateOutputType = {
    id: number | null
    session_token: string | null
    user_id: number | null
    created_at: Date | null
    updated_at: Date | null
    status: $Enums.shared_status | null
    deleted_at: Date | null
    expires_at: Date | null
  }

  export type SessionsCountAggregateOutputType = {
    id: number
    session_token: number
    user_id: number
    created_at: number
    updated_at: number
    status: number
    deleted_at: number
    expires_at: number
    _all: number
  }


  export type SessionsAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type SessionsSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type SessionsMinAggregateInputType = {
    id?: true
    session_token?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    status?: true
    deleted_at?: true
    expires_at?: true
  }

  export type SessionsMaxAggregateInputType = {
    id?: true
    session_token?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    status?: true
    deleted_at?: true
    expires_at?: true
  }

  export type SessionsCountAggregateInputType = {
    id?: true
    session_token?: true
    user_id?: true
    created_at?: true
    updated_at?: true
    status?: true
    deleted_at?: true
    expires_at?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithAggregationInput | sessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _avg?: SessionsAvgAggregateInputType
    _sum?: SessionsSumAggregateInputType
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }

  export type SessionsGroupByOutputType = {
    id: number
    session_token: string
    user_id: number
    created_at: Date
    updated_at: Date | null
    status: $Enums.shared_status
    deleted_at: Date | null
    expires_at: Date
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    session_token?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    deleted_at?: boolean
    expires_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>



  export type sessionsSelectScalar = {
    id?: boolean
    session_token?: boolean
    user_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    deleted_at?: boolean
    expires_at?: boolean
  }

  export type sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "session_token" | "user_id" | "created_at" | "updated_at" | "status" | "deleted_at" | "expires_at", ExtArgs["result"]["sessions"]>
  export type sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      session_token: string
      user_id: number
      created_at: Date
      updated_at: Date | null
      status: $Enums.shared_status
      deleted_at: Date | null
      expires_at: Date
    }, ExtArgs["result"]["sessions"]>
    composites: {}
  }

  type sessionsGetPayload<S extends boolean | null | undefined | sessionsDefaultArgs> = $Result.GetResult<Prisma.$sessionsPayload, S>

  type sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions'], meta: { name: 'sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionsFindUniqueArgs>(args: SelectSubset<T, sessionsFindUniqueArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionsFindFirstArgs>(args?: SelectSubset<T, sessionsFindFirstArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionsFindManyArgs>(args?: SelectSubset<T, sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
     */
    create<T extends sessionsCreateArgs>(args: SelectSubset<T, sessionsCreateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionsCreateManyArgs>(args?: SelectSubset<T, sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
     */
    delete<T extends sessionsDeleteArgs>(args: SelectSubset<T, sessionsDeleteArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionsUpdateArgs>(args: SelectSubset<T, sessionsUpdateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionsDeleteManyArgs>(args?: SelectSubset<T, sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionsUpdateManyArgs>(args: SelectSubset<T, sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
     */
    upsert<T extends sessionsUpsertArgs>(args: SelectSubset<T, sessionsUpsertArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionsGroupByArgs['orderBy'] }
        : { orderBy?: sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions model
   */
  readonly fields: sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions model
   */
  interface sessionsFieldRefs {
    readonly id: FieldRef<"sessions", 'Int'>
    readonly session_token: FieldRef<"sessions", 'String'>
    readonly user_id: FieldRef<"sessions", 'Int'>
    readonly created_at: FieldRef<"sessions", 'DateTime'>
    readonly updated_at: FieldRef<"sessions", 'DateTime'>
    readonly status: FieldRef<"sessions", 'shared_status'>
    readonly deleted_at: FieldRef<"sessions", 'DateTime'>
    readonly expires_at: FieldRef<"sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions create
   */
  export type sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a sessions.
     */
    data: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }

  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessions update
   */
  export type sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }

  /**
   * sessions delete
   */
  export type sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * sessions without action
   */
  export type sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
  }


  /**
   * Model transportation
   */

  export type AggregateTransportation = {
    _count: TransportationCountAggregateOutputType | null
    _avg: TransportationAvgAggregateOutputType | null
    _sum: TransportationSumAggregateOutputType | null
    _min: TransportationMinAggregateOutputType | null
    _max: TransportationMaxAggregateOutputType | null
  }

  export type TransportationAvgAggregateOutputType = {
    id: number | null
    cost: number | null
    booking_id: number | null
  }

  export type TransportationSumAggregateOutputType = {
    id: number | null
    cost: number | null
    booking_id: number | null
  }

  export type TransportationMinAggregateOutputType = {
    id: number | null
    type: $Enums.transportation_type | null
    provider: string | null
    booking_ref: string | null
    departure_date: Date | null
    return_date: Date | null
    departure_point: string | null
    arrival_point: string | null
    cost: number | null
    booking_id: number | null
    status: $Enums.transportation_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type TransportationMaxAggregateOutputType = {
    id: number | null
    type: $Enums.transportation_type | null
    provider: string | null
    booking_ref: string | null
    departure_date: Date | null
    return_date: Date | null
    departure_point: string | null
    arrival_point: string | null
    cost: number | null
    booking_id: number | null
    status: $Enums.transportation_status | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
  }

  export type TransportationCountAggregateOutputType = {
    id: number
    type: number
    provider: number
    booking_ref: number
    departure_date: number
    return_date: number
    departure_point: number
    arrival_point: number
    cost: number
    booking_id: number
    status: number
    created_at: number
    updated_at: number
    deleted_at: number
    _all: number
  }


  export type TransportationAvgAggregateInputType = {
    id?: true
    cost?: true
    booking_id?: true
  }

  export type TransportationSumAggregateInputType = {
    id?: true
    cost?: true
    booking_id?: true
  }

  export type TransportationMinAggregateInputType = {
    id?: true
    type?: true
    provider?: true
    booking_ref?: true
    departure_date?: true
    return_date?: true
    departure_point?: true
    arrival_point?: true
    cost?: true
    booking_id?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type TransportationMaxAggregateInputType = {
    id?: true
    type?: true
    provider?: true
    booking_ref?: true
    departure_date?: true
    return_date?: true
    departure_point?: true
    arrival_point?: true
    cost?: true
    booking_id?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
  }

  export type TransportationCountAggregateInputType = {
    id?: true
    type?: true
    provider?: true
    booking_ref?: true
    departure_date?: true
    return_date?: true
    departure_point?: true
    arrival_point?: true
    cost?: true
    booking_id?: true
    status?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    _all?: true
  }

  export type TransportationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transportation to aggregate.
     */
    where?: transportationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transportation to fetch.
     */
    orderBy?: transportationOrderByWithRelationInput | transportationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transportationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transportation from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transportation.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transportation
    **/
    _count?: true | TransportationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransportationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransportationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransportationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransportationMaxAggregateInputType
  }

  export type GetTransportationAggregateType<T extends TransportationAggregateArgs> = {
        [P in keyof T & keyof AggregateTransportation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransportation[P]>
      : GetScalarType<T[P], AggregateTransportation[P]>
  }




  export type transportationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transportationWhereInput
    orderBy?: transportationOrderByWithAggregationInput | transportationOrderByWithAggregationInput[]
    by: TransportationScalarFieldEnum[] | TransportationScalarFieldEnum
    having?: transportationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransportationCountAggregateInputType | true
    _avg?: TransportationAvgAggregateInputType
    _sum?: TransportationSumAggregateInputType
    _min?: TransportationMinAggregateInputType
    _max?: TransportationMaxAggregateInputType
  }

  export type TransportationGroupByOutputType = {
    id: number
    type: $Enums.transportation_type
    provider: string
    booking_ref: string | null
    departure_date: Date
    return_date: Date | null
    departure_point: string
    arrival_point: string
    cost: number
    booking_id: number
    status: $Enums.transportation_status
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    _count: TransportationCountAggregateOutputType | null
    _avg: TransportationAvgAggregateOutputType | null
    _sum: TransportationSumAggregateOutputType | null
    _min: TransportationMinAggregateOutputType | null
    _max: TransportationMaxAggregateOutputType | null
  }

  type GetTransportationGroupByPayload<T extends transportationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransportationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransportationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransportationGroupByOutputType[P]>
            : GetScalarType<T[P], TransportationGroupByOutputType[P]>
        }
      >
    >


  export type transportationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    provider?: boolean
    booking_ref?: boolean
    departure_date?: boolean
    return_date?: boolean
    departure_point?: boolean
    arrival_point?: boolean
    cost?: boolean
    booking_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transportation"]>



  export type transportationSelectScalar = {
    id?: boolean
    type?: boolean
    provider?: boolean
    booking_ref?: boolean
    departure_date?: boolean
    return_date?: boolean
    departure_point?: boolean
    arrival_point?: boolean
    cost?: boolean
    booking_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
  }

  export type transportationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "provider" | "booking_ref" | "departure_date" | "return_date" | "departure_point" | "arrival_point" | "cost" | "booking_id" | "status" | "created_at" | "updated_at" | "deleted_at", ExtArgs["result"]["transportation"]>
  export type transportationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | bookingsDefaultArgs<ExtArgs>
  }

  export type $transportationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transportation"
    objects: {
      bookings: Prisma.$bookingsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.transportation_type
      provider: string
      booking_ref: string | null
      departure_date: Date
      return_date: Date | null
      departure_point: string
      arrival_point: string
      cost: number
      booking_id: number
      status: $Enums.transportation_status
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
    }, ExtArgs["result"]["transportation"]>
    composites: {}
  }

  type transportationGetPayload<S extends boolean | null | undefined | transportationDefaultArgs> = $Result.GetResult<Prisma.$transportationPayload, S>

  type transportationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transportationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransportationCountAggregateInputType | true
    }

  export interface transportationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transportation'], meta: { name: 'transportation' } }
    /**
     * Find zero or one Transportation that matches the filter.
     * @param {transportationFindUniqueArgs} args - Arguments to find a Transportation
     * @example
     * // Get one Transportation
     * const transportation = await prisma.transportation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transportationFindUniqueArgs>(args: SelectSubset<T, transportationFindUniqueArgs<ExtArgs>>): Prisma__transportationClient<$Result.GetResult<Prisma.$transportationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transportation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transportationFindUniqueOrThrowArgs} args - Arguments to find a Transportation
     * @example
     * // Get one Transportation
     * const transportation = await prisma.transportation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transportationFindUniqueOrThrowArgs>(args: SelectSubset<T, transportationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transportationClient<$Result.GetResult<Prisma.$transportationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transportation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transportationFindFirstArgs} args - Arguments to find a Transportation
     * @example
     * // Get one Transportation
     * const transportation = await prisma.transportation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transportationFindFirstArgs>(args?: SelectSubset<T, transportationFindFirstArgs<ExtArgs>>): Prisma__transportationClient<$Result.GetResult<Prisma.$transportationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transportation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transportationFindFirstOrThrowArgs} args - Arguments to find a Transportation
     * @example
     * // Get one Transportation
     * const transportation = await prisma.transportation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transportationFindFirstOrThrowArgs>(args?: SelectSubset<T, transportationFindFirstOrThrowArgs<ExtArgs>>): Prisma__transportationClient<$Result.GetResult<Prisma.$transportationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transportation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transportationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transportation
     * const transportation = await prisma.transportation.findMany()
     * 
     * // Get first 10 Transportation
     * const transportation = await prisma.transportation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transportationWithIdOnly = await prisma.transportation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends transportationFindManyArgs>(args?: SelectSubset<T, transportationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transportationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transportation.
     * @param {transportationCreateArgs} args - Arguments to create a Transportation.
     * @example
     * // Create one Transportation
     * const Transportation = await prisma.transportation.create({
     *   data: {
     *     // ... data to create a Transportation
     *   }
     * })
     * 
     */
    create<T extends transportationCreateArgs>(args: SelectSubset<T, transportationCreateArgs<ExtArgs>>): Prisma__transportationClient<$Result.GetResult<Prisma.$transportationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transportation.
     * @param {transportationCreateManyArgs} args - Arguments to create many Transportation.
     * @example
     * // Create many Transportation
     * const transportation = await prisma.transportation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transportationCreateManyArgs>(args?: SelectSubset<T, transportationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transportation.
     * @param {transportationDeleteArgs} args - Arguments to delete one Transportation.
     * @example
     * // Delete one Transportation
     * const Transportation = await prisma.transportation.delete({
     *   where: {
     *     // ... filter to delete one Transportation
     *   }
     * })
     * 
     */
    delete<T extends transportationDeleteArgs>(args: SelectSubset<T, transportationDeleteArgs<ExtArgs>>): Prisma__transportationClient<$Result.GetResult<Prisma.$transportationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transportation.
     * @param {transportationUpdateArgs} args - Arguments to update one Transportation.
     * @example
     * // Update one Transportation
     * const transportation = await prisma.transportation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transportationUpdateArgs>(args: SelectSubset<T, transportationUpdateArgs<ExtArgs>>): Prisma__transportationClient<$Result.GetResult<Prisma.$transportationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transportation.
     * @param {transportationDeleteManyArgs} args - Arguments to filter Transportation to delete.
     * @example
     * // Delete a few Transportation
     * const { count } = await prisma.transportation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transportationDeleteManyArgs>(args?: SelectSubset<T, transportationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transportation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transportationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transportation
     * const transportation = await prisma.transportation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transportationUpdateManyArgs>(args: SelectSubset<T, transportationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transportation.
     * @param {transportationUpsertArgs} args - Arguments to update or create a Transportation.
     * @example
     * // Update or create a Transportation
     * const transportation = await prisma.transportation.upsert({
     *   create: {
     *     // ... data to create a Transportation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transportation we want to update
     *   }
     * })
     */
    upsert<T extends transportationUpsertArgs>(args: SelectSubset<T, transportationUpsertArgs<ExtArgs>>): Prisma__transportationClient<$Result.GetResult<Prisma.$transportationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transportation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transportationCountArgs} args - Arguments to filter Transportation to count.
     * @example
     * // Count the number of Transportation
     * const count = await prisma.transportation.count({
     *   where: {
     *     // ... the filter for the Transportation we want to count
     *   }
     * })
    **/
    count<T extends transportationCountArgs>(
      args?: Subset<T, transportationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransportationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transportation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransportationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransportationAggregateArgs>(args: Subset<T, TransportationAggregateArgs>): Prisma.PrismaPromise<GetTransportationAggregateType<T>>

    /**
     * Group by Transportation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transportationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transportationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transportationGroupByArgs['orderBy'] }
        : { orderBy?: transportationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transportationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransportationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transportation model
   */
  readonly fields: transportationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transportation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transportationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends bookingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bookingsDefaultArgs<ExtArgs>>): Prisma__bookingsClient<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transportation model
   */
  interface transportationFieldRefs {
    readonly id: FieldRef<"transportation", 'Int'>
    readonly type: FieldRef<"transportation", 'transportation_type'>
    readonly provider: FieldRef<"transportation", 'String'>
    readonly booking_ref: FieldRef<"transportation", 'String'>
    readonly departure_date: FieldRef<"transportation", 'DateTime'>
    readonly return_date: FieldRef<"transportation", 'DateTime'>
    readonly departure_point: FieldRef<"transportation", 'String'>
    readonly arrival_point: FieldRef<"transportation", 'String'>
    readonly cost: FieldRef<"transportation", 'Float'>
    readonly booking_id: FieldRef<"transportation", 'Int'>
    readonly status: FieldRef<"transportation", 'transportation_status'>
    readonly created_at: FieldRef<"transportation", 'DateTime'>
    readonly updated_at: FieldRef<"transportation", 'DateTime'>
    readonly deleted_at: FieldRef<"transportation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transportation findUnique
   */
  export type transportationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transportation
     */
    select?: transportationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transportation
     */
    omit?: transportationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transportationInclude<ExtArgs> | null
    /**
     * Filter, which transportation to fetch.
     */
    where: transportationWhereUniqueInput
  }

  /**
   * transportation findUniqueOrThrow
   */
  export type transportationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transportation
     */
    select?: transportationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transportation
     */
    omit?: transportationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transportationInclude<ExtArgs> | null
    /**
     * Filter, which transportation to fetch.
     */
    where: transportationWhereUniqueInput
  }

  /**
   * transportation findFirst
   */
  export type transportationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transportation
     */
    select?: transportationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transportation
     */
    omit?: transportationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transportationInclude<ExtArgs> | null
    /**
     * Filter, which transportation to fetch.
     */
    where?: transportationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transportation to fetch.
     */
    orderBy?: transportationOrderByWithRelationInput | transportationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transportation.
     */
    cursor?: transportationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transportation from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transportation.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transportation.
     */
    distinct?: TransportationScalarFieldEnum | TransportationScalarFieldEnum[]
  }

  /**
   * transportation findFirstOrThrow
   */
  export type transportationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transportation
     */
    select?: transportationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transportation
     */
    omit?: transportationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transportationInclude<ExtArgs> | null
    /**
     * Filter, which transportation to fetch.
     */
    where?: transportationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transportation to fetch.
     */
    orderBy?: transportationOrderByWithRelationInput | transportationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transportation.
     */
    cursor?: transportationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transportation from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transportation.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transportation.
     */
    distinct?: TransportationScalarFieldEnum | TransportationScalarFieldEnum[]
  }

  /**
   * transportation findMany
   */
  export type transportationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transportation
     */
    select?: transportationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transportation
     */
    omit?: transportationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transportationInclude<ExtArgs> | null
    /**
     * Filter, which transportation to fetch.
     */
    where?: transportationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transportation to fetch.
     */
    orderBy?: transportationOrderByWithRelationInput | transportationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transportation.
     */
    cursor?: transportationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transportation from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transportation.
     */
    skip?: number
    distinct?: TransportationScalarFieldEnum | TransportationScalarFieldEnum[]
  }

  /**
   * transportation create
   */
  export type transportationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transportation
     */
    select?: transportationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transportation
     */
    omit?: transportationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transportationInclude<ExtArgs> | null
    /**
     * The data needed to create a transportation.
     */
    data: XOR<transportationCreateInput, transportationUncheckedCreateInput>
  }

  /**
   * transportation createMany
   */
  export type transportationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transportation.
     */
    data: transportationCreateManyInput | transportationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transportation update
   */
  export type transportationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transportation
     */
    select?: transportationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transportation
     */
    omit?: transportationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transportationInclude<ExtArgs> | null
    /**
     * The data needed to update a transportation.
     */
    data: XOR<transportationUpdateInput, transportationUncheckedUpdateInput>
    /**
     * Choose, which transportation to update.
     */
    where: transportationWhereUniqueInput
  }

  /**
   * transportation updateMany
   */
  export type transportationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transportation.
     */
    data: XOR<transportationUpdateManyMutationInput, transportationUncheckedUpdateManyInput>
    /**
     * Filter which transportation to update
     */
    where?: transportationWhereInput
    /**
     * Limit how many transportation to update.
     */
    limit?: number
  }

  /**
   * transportation upsert
   */
  export type transportationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transportation
     */
    select?: transportationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transportation
     */
    omit?: transportationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transportationInclude<ExtArgs> | null
    /**
     * The filter to search for the transportation to update in case it exists.
     */
    where: transportationWhereUniqueInput
    /**
     * In case the transportation found by the `where` argument doesn't exist, create a new transportation with this data.
     */
    create: XOR<transportationCreateInput, transportationUncheckedCreateInput>
    /**
     * In case the transportation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transportationUpdateInput, transportationUncheckedUpdateInput>
  }

  /**
   * transportation delete
   */
  export type transportationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transportation
     */
    select?: transportationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transportation
     */
    omit?: transportationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transportationInclude<ExtArgs> | null
    /**
     * Filter which transportation to delete.
     */
    where: transportationWhereUniqueInput
  }

  /**
   * transportation deleteMany
   */
  export type transportationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transportation to delete
     */
    where?: transportationWhereInput
    /**
     * Limit how many transportation to delete.
     */
    limit?: number
  }

  /**
   * transportation without action
   */
  export type transportationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transportation
     */
    select?: transportationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transportation
     */
    omit?: transportationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transportationInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    branch_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    branch_id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    email_verified: Date | null
    password: string | null
    role: $Enums.users_role | null
    created_at: Date | null
    updated_at: Date | null
    status: $Enums.users_status | null
    deleted_at: Date | null
    public_id: string | null
    password_expiry: Date | null
    two_factor_enabled: boolean | null
    national_id: string | null
    phone: string | null
    branch_id: number | null
    image: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    email_verified: Date | null
    password: string | null
    role: $Enums.users_role | null
    created_at: Date | null
    updated_at: Date | null
    status: $Enums.users_status | null
    deleted_at: Date | null
    public_id: string | null
    password_expiry: Date | null
    two_factor_enabled: boolean | null
    national_id: string | null
    phone: string | null
    branch_id: number | null
    image: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    email: number
    email_verified: number
    password: number
    role: number
    created_at: number
    updated_at: number
    status: number
    deleted_at: number
    public_id: number
    password_expiry: number
    two_factor_enabled: number
    national_id: number
    phone: number
    branch_id: number
    image: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    branch_id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    branch_id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified?: true
    password?: true
    role?: true
    created_at?: true
    updated_at?: true
    status?: true
    deleted_at?: true
    public_id?: true
    password_expiry?: true
    two_factor_enabled?: true
    national_id?: true
    phone?: true
    branch_id?: true
    image?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified?: true
    password?: true
    role?: true
    created_at?: true
    updated_at?: true
    status?: true
    deleted_at?: true
    public_id?: true
    password_expiry?: true
    two_factor_enabled?: true
    national_id?: true
    phone?: true
    branch_id?: true
    image?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified?: true
    password?: true
    role?: true
    created_at?: true
    updated_at?: true
    status?: true
    deleted_at?: true
    public_id?: true
    password_expiry?: true
    two_factor_enabled?: true
    national_id?: true
    phone?: true
    branch_id?: true
    image?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    name: string
    email: string
    email_verified: Date | null
    password: string
    role: $Enums.users_role
    created_at: Date
    updated_at: Date | null
    status: $Enums.users_status
    deleted_at: Date | null
    public_id: string
    password_expiry: Date
    two_factor_enabled: boolean
    national_id: string | null
    phone: string | null
    branch_id: number | null
    image: string | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified?: boolean
    password?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    deleted_at?: boolean
    public_id?: boolean
    password_expiry?: boolean
    two_factor_enabled?: boolean
    national_id?: boolean
    phone?: boolean
    branch_id?: boolean
    image?: boolean
    accounts?: boolean | users$accountsArgs<ExtArgs>
    bookings?: boolean | users$bookingsArgs<ExtArgs>
    cancellations?: boolean | users$cancellationsArgs<ExtArgs>
    events?: boolean | users$eventsArgs<ExtArgs>
    notifications?: boolean | users$notificationsArgs<ExtArgs>
    rate_cards?: boolean | users$rate_cardsArgs<ExtArgs>
    sessions?: boolean | users$sessionsArgs<ExtArgs>
    branch?: boolean | users$branchArgs<ExtArgs>
    users_branches?: boolean | users$users_branchesArgs<ExtArgs>
    invoices?: boolean | users$invoicesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>



  export type usersSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified?: boolean
    password?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
    status?: boolean
    deleted_at?: boolean
    public_id?: boolean
    password_expiry?: boolean
    two_factor_enabled?: boolean
    national_id?: boolean
    phone?: boolean
    branch_id?: boolean
    image?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "email_verified" | "password" | "role" | "created_at" | "updated_at" | "status" | "deleted_at" | "public_id" | "password_expiry" | "two_factor_enabled" | "national_id" | "phone" | "branch_id" | "image", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | users$accountsArgs<ExtArgs>
    bookings?: boolean | users$bookingsArgs<ExtArgs>
    cancellations?: boolean | users$cancellationsArgs<ExtArgs>
    events?: boolean | users$eventsArgs<ExtArgs>
    notifications?: boolean | users$notificationsArgs<ExtArgs>
    rate_cards?: boolean | users$rate_cardsArgs<ExtArgs>
    sessions?: boolean | users$sessionsArgs<ExtArgs>
    branch?: boolean | users$branchArgs<ExtArgs>
    users_branches?: boolean | users$users_branchesArgs<ExtArgs>
    invoices?: boolean | users$invoicesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      accounts: Prisma.$accountsPayload<ExtArgs>[]
      bookings: Prisma.$bookingsPayload<ExtArgs>[]
      cancellations: Prisma.$cancellationsPayload<ExtArgs>[]
      events: Prisma.$events_logPayload<ExtArgs>[]
      notifications: Prisma.$notificationsPayload<ExtArgs>[]
      rate_cards: Prisma.$rate_cardsPayload<ExtArgs>[]
      sessions: Prisma.$sessionsPayload<ExtArgs>[]
      branch: Prisma.$branchesPayload<ExtArgs> | null
      users_branches: Prisma.$users_branchesPayload<ExtArgs>[]
      invoices: Prisma.$invoicesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      email_verified: Date | null
      password: string
      role: $Enums.users_role
      created_at: Date
      updated_at: Date | null
      status: $Enums.users_status
      deleted_at: Date | null
      public_id: string
      password_expiry: Date
      two_factor_enabled: boolean
      national_id: string | null
      phone: string | null
      branch_id: number | null
      image: string | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends users$accountsArgs<ExtArgs> = {}>(args?: Subset<T, users$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$accountsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends users$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, users$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cancellations<T extends users$cancellationsArgs<ExtArgs> = {}>(args?: Subset<T, users$cancellationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cancellationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends users$eventsArgs<ExtArgs> = {}>(args?: Subset<T, users$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$events_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends users$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, users$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rate_cards<T extends users$rate_cardsArgs<ExtArgs> = {}>(args?: Subset<T, users$rate_cardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rate_cardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends users$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, users$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    branch<T extends users$branchArgs<ExtArgs> = {}>(args?: Subset<T, users$branchArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users_branches<T extends users$users_branchesArgs<ExtArgs> = {}>(args?: Subset<T, users$users_branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$users_branchesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends users$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, users$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invoicesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly name: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly email_verified: FieldRef<"users", 'DateTime'>
    readonly password: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'users_role'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
    readonly status: FieldRef<"users", 'users_status'>
    readonly deleted_at: FieldRef<"users", 'DateTime'>
    readonly public_id: FieldRef<"users", 'String'>
    readonly password_expiry: FieldRef<"users", 'DateTime'>
    readonly two_factor_enabled: FieldRef<"users", 'Boolean'>
    readonly national_id: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly branch_id: FieldRef<"users", 'Int'>
    readonly image: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.accounts
   */
  export type users$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the accounts
     */
    select?: accountsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the accounts
     */
    omit?: accountsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: accountsInclude<ExtArgs> | null
    where?: accountsWhereInput
    orderBy?: accountsOrderByWithRelationInput | accountsOrderByWithRelationInput[]
    cursor?: accountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountsScalarFieldEnum | AccountsScalarFieldEnum[]
  }

  /**
   * users.bookings
   */
  export type users$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bookings
     */
    select?: bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bookings
     */
    omit?: bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bookingsInclude<ExtArgs> | null
    where?: bookingsWhereInput
    orderBy?: bookingsOrderByWithRelationInput | bookingsOrderByWithRelationInput[]
    cursor?: bookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingsScalarFieldEnum | BookingsScalarFieldEnum[]
  }

  /**
   * users.cancellations
   */
  export type users$cancellationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cancellations
     */
    select?: cancellationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cancellations
     */
    omit?: cancellationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cancellationsInclude<ExtArgs> | null
    where?: cancellationsWhereInput
    orderBy?: cancellationsOrderByWithRelationInput | cancellationsOrderByWithRelationInput[]
    cursor?: cancellationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CancellationsScalarFieldEnum | CancellationsScalarFieldEnum[]
  }

  /**
   * users.events
   */
  export type users$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events_log
     */
    select?: events_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the events_log
     */
    omit?: events_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: events_logInclude<ExtArgs> | null
    where?: events_logWhereInput
    orderBy?: events_logOrderByWithRelationInput | events_logOrderByWithRelationInput[]
    cursor?: events_logWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Events_logScalarFieldEnum | Events_logScalarFieldEnum[]
  }

  /**
   * users.notifications
   */
  export type users$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * users.rate_cards
   */
  export type users$rate_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rate_cards
     */
    select?: rate_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rate_cards
     */
    omit?: rate_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rate_cardsInclude<ExtArgs> | null
    where?: rate_cardsWhereInput
    orderBy?: rate_cardsOrderByWithRelationInput | rate_cardsOrderByWithRelationInput[]
    cursor?: rate_cardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Rate_cardsScalarFieldEnum | Rate_cardsScalarFieldEnum[]
  }

  /**
   * users.sessions
   */
  export type users$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    cursor?: sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * users.branch
   */
  export type users$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    where?: branchesWhereInput
  }

  /**
   * users.users_branches
   */
  export type users$users_branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_branches
     */
    select?: users_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_branches
     */
    omit?: users_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_branchesInclude<ExtArgs> | null
    where?: users_branchesWhereInput
    orderBy?: users_branchesOrderByWithRelationInput | users_branchesOrderByWithRelationInput[]
    cursor?: users_branchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Users_branchesScalarFieldEnum | Users_branchesScalarFieldEnum[]
  }

  /**
   * users.invoices
   */
  export type users$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invoices
     */
    select?: invoicesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invoices
     */
    omit?: invoicesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invoicesInclude<ExtArgs> | null
    where?: invoicesWhereInput
    orderBy?: invoicesOrderByWithRelationInput | invoicesOrderByWithRelationInput[]
    cursor?: invoicesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoicesScalarFieldEnum | InvoicesScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model branches
   */

  export type AggregateBranches = {
    _count: BranchesCountAggregateOutputType | null
    _avg: BranchesAvgAggregateOutputType | null
    _sum: BranchesSumAggregateOutputType | null
    _min: BranchesMinAggregateOutputType | null
    _max: BranchesMaxAggregateOutputType | null
  }

  export type BranchesAvgAggregateOutputType = {
    id: number | null
  }

  export type BranchesSumAggregateOutputType = {
    id: number | null
  }

  export type BranchesMinAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status | null
  }

  export type BranchesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    location: string | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status | null
  }

  export type BranchesCountAggregateOutputType = {
    id: number
    name: number
    location: number
    created_at: number
    updated_at: number
    deleted_at: number
    status: number
    _all: number
  }


  export type BranchesAvgAggregateInputType = {
    id?: true
  }

  export type BranchesSumAggregateInputType = {
    id?: true
  }

  export type BranchesMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
  }

  export type BranchesMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
  }

  export type BranchesCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
    _all?: true
  }

  export type BranchesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which branches to aggregate.
     */
    where?: branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchesOrderByWithRelationInput | branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned branches
    **/
    _count?: true | BranchesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchesMaxAggregateInputType
  }

  export type GetBranchesAggregateType<T extends BranchesAggregateArgs> = {
        [P in keyof T & keyof AggregateBranches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranches[P]>
      : GetScalarType<T[P], AggregateBranches[P]>
  }




  export type branchesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: branchesWhereInput
    orderBy?: branchesOrderByWithAggregationInput | branchesOrderByWithAggregationInput[]
    by: BranchesScalarFieldEnum[] | BranchesScalarFieldEnum
    having?: branchesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchesCountAggregateInputType | true
    _avg?: BranchesAvgAggregateInputType
    _sum?: BranchesSumAggregateInputType
    _min?: BranchesMinAggregateInputType
    _max?: BranchesMaxAggregateInputType
  }

  export type BranchesGroupByOutputType = {
    id: number
    name: string
    location: string
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status
    _count: BranchesCountAggregateOutputType | null
    _avg: BranchesAvgAggregateOutputType | null
    _sum: BranchesSumAggregateOutputType | null
    _min: BranchesMinAggregateOutputType | null
    _max: BranchesMaxAggregateOutputType | null
  }

  type GetBranchesGroupByPayload<T extends branchesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchesGroupByOutputType[P]>
            : GetScalarType<T[P], BranchesGroupByOutputType[P]>
        }
      >
    >


  export type branchesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    status?: boolean
    clients?: boolean | branches$clientsArgs<ExtArgs>
    users?: boolean | branches$usersArgs<ExtArgs>
    users_branches?: boolean | branches$users_branchesArgs<ExtArgs>
    _count?: boolean | BranchesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branches"]>



  export type branchesSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    status?: boolean
  }

  export type branchesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "location" | "created_at" | "updated_at" | "deleted_at" | "status", ExtArgs["result"]["branches"]>
  export type branchesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clients?: boolean | branches$clientsArgs<ExtArgs>
    users?: boolean | branches$usersArgs<ExtArgs>
    users_branches?: boolean | branches$users_branchesArgs<ExtArgs>
    _count?: boolean | BranchesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $branchesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "branches"
    objects: {
      clients: Prisma.$clientsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>[]
      users_branches: Prisma.$users_branchesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      location: string
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
      status: $Enums.shared_status
    }, ExtArgs["result"]["branches"]>
    composites: {}
  }

  type branchesGetPayload<S extends boolean | null | undefined | branchesDefaultArgs> = $Result.GetResult<Prisma.$branchesPayload, S>

  type branchesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<branchesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchesCountAggregateInputType | true
    }

  export interface branchesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['branches'], meta: { name: 'branches' } }
    /**
     * Find zero or one Branches that matches the filter.
     * @param {branchesFindUniqueArgs} args - Arguments to find a Branches
     * @example
     * // Get one Branches
     * const branches = await prisma.branches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends branchesFindUniqueArgs>(args: SelectSubset<T, branchesFindUniqueArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Branches that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {branchesFindUniqueOrThrowArgs} args - Arguments to find a Branches
     * @example
     * // Get one Branches
     * const branches = await prisma.branches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends branchesFindUniqueOrThrowArgs>(args: SelectSubset<T, branchesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesFindFirstArgs} args - Arguments to find a Branches
     * @example
     * // Get one Branches
     * const branches = await prisma.branches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends branchesFindFirstArgs>(args?: SelectSubset<T, branchesFindFirstArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesFindFirstOrThrowArgs} args - Arguments to find a Branches
     * @example
     * // Get one Branches
     * const branches = await prisma.branches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends branchesFindFirstOrThrowArgs>(args?: SelectSubset<T, branchesFindFirstOrThrowArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branches.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const branchesWithIdOnly = await prisma.branches.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends branchesFindManyArgs>(args?: SelectSubset<T, branchesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Branches.
     * @param {branchesCreateArgs} args - Arguments to create a Branches.
     * @example
     * // Create one Branches
     * const Branches = await prisma.branches.create({
     *   data: {
     *     // ... data to create a Branches
     *   }
     * })
     * 
     */
    create<T extends branchesCreateArgs>(args: SelectSubset<T, branchesCreateArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Branches.
     * @param {branchesCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branches = await prisma.branches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends branchesCreateManyArgs>(args?: SelectSubset<T, branchesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Branches.
     * @param {branchesDeleteArgs} args - Arguments to delete one Branches.
     * @example
     * // Delete one Branches
     * const Branches = await prisma.branches.delete({
     *   where: {
     *     // ... filter to delete one Branches
     *   }
     * })
     * 
     */
    delete<T extends branchesDeleteArgs>(args: SelectSubset<T, branchesDeleteArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Branches.
     * @param {branchesUpdateArgs} args - Arguments to update one Branches.
     * @example
     * // Update one Branches
     * const branches = await prisma.branches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends branchesUpdateArgs>(args: SelectSubset<T, branchesUpdateArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Branches.
     * @param {branchesDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends branchesDeleteManyArgs>(args?: SelectSubset<T, branchesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branches = await prisma.branches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends branchesUpdateManyArgs>(args: SelectSubset<T, branchesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branches.
     * @param {branchesUpsertArgs} args - Arguments to update or create a Branches.
     * @example
     * // Update or create a Branches
     * const branches = await prisma.branches.upsert({
     *   create: {
     *     // ... data to create a Branches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branches we want to update
     *   }
     * })
     */
    upsert<T extends branchesUpsertArgs>(args: SelectSubset<T, branchesUpsertArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branches.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends branchesCountArgs>(
      args?: Subset<T, branchesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchesAggregateArgs>(args: Subset<T, BranchesAggregateArgs>): Prisma.PrismaPromise<GetBranchesAggregateType<T>>

    /**
     * Group by Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {branchesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends branchesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: branchesGroupByArgs['orderBy'] }
        : { orderBy?: branchesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, branchesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the branches model
   */
  readonly fields: branchesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for branches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__branchesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clients<T extends branches$clientsArgs<ExtArgs> = {}>(args?: Subset<T, branches$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends branches$usersArgs<ExtArgs> = {}>(args?: Subset<T, branches$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users_branches<T extends branches$users_branchesArgs<ExtArgs> = {}>(args?: Subset<T, branches$users_branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$users_branchesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the branches model
   */
  interface branchesFieldRefs {
    readonly id: FieldRef<"branches", 'Int'>
    readonly name: FieldRef<"branches", 'String'>
    readonly location: FieldRef<"branches", 'String'>
    readonly created_at: FieldRef<"branches", 'DateTime'>
    readonly updated_at: FieldRef<"branches", 'DateTime'>
    readonly deleted_at: FieldRef<"branches", 'DateTime'>
    readonly status: FieldRef<"branches", 'shared_status'>
  }
    

  // Custom InputTypes
  /**
   * branches findUnique
   */
  export type branchesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where: branchesWhereUniqueInput
  }

  /**
   * branches findUniqueOrThrow
   */
  export type branchesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where: branchesWhereUniqueInput
  }

  /**
   * branches findFirst
   */
  export type branchesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where?: branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchesOrderByWithRelationInput | branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for branches.
     */
    cursor?: branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of branches.
     */
    distinct?: BranchesScalarFieldEnum | BranchesScalarFieldEnum[]
  }

  /**
   * branches findFirstOrThrow
   */
  export type branchesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where?: branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchesOrderByWithRelationInput | branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for branches.
     */
    cursor?: branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of branches.
     */
    distinct?: BranchesScalarFieldEnum | BranchesScalarFieldEnum[]
  }

  /**
   * branches findMany
   */
  export type branchesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter, which branches to fetch.
     */
    where?: branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of branches to fetch.
     */
    orderBy?: branchesOrderByWithRelationInput | branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing branches.
     */
    cursor?: branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` branches.
     */
    skip?: number
    distinct?: BranchesScalarFieldEnum | BranchesScalarFieldEnum[]
  }

  /**
   * branches create
   */
  export type branchesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * The data needed to create a branches.
     */
    data: XOR<branchesCreateInput, branchesUncheckedCreateInput>
  }

  /**
   * branches createMany
   */
  export type branchesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many branches.
     */
    data: branchesCreateManyInput | branchesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * branches update
   */
  export type branchesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * The data needed to update a branches.
     */
    data: XOR<branchesUpdateInput, branchesUncheckedUpdateInput>
    /**
     * Choose, which branches to update.
     */
    where: branchesWhereUniqueInput
  }

  /**
   * branches updateMany
   */
  export type branchesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update branches.
     */
    data: XOR<branchesUpdateManyMutationInput, branchesUncheckedUpdateManyInput>
    /**
     * Filter which branches to update
     */
    where?: branchesWhereInput
    /**
     * Limit how many branches to update.
     */
    limit?: number
  }

  /**
   * branches upsert
   */
  export type branchesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * The filter to search for the branches to update in case it exists.
     */
    where: branchesWhereUniqueInput
    /**
     * In case the branches found by the `where` argument doesn't exist, create a new branches with this data.
     */
    create: XOR<branchesCreateInput, branchesUncheckedCreateInput>
    /**
     * In case the branches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<branchesUpdateInput, branchesUncheckedUpdateInput>
  }

  /**
   * branches delete
   */
  export type branchesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
    /**
     * Filter which branches to delete.
     */
    where: branchesWhereUniqueInput
  }

  /**
   * branches deleteMany
   */
  export type branchesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which branches to delete
     */
    where?: branchesWhereInput
    /**
     * Limit how many branches to delete.
     */
    limit?: number
  }

  /**
   * branches.clients
   */
  export type branches$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clients
     */
    select?: clientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clients
     */
    omit?: clientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clientsInclude<ExtArgs> | null
    where?: clientsWhereInput
    orderBy?: clientsOrderByWithRelationInput | clientsOrderByWithRelationInput[]
    cursor?: clientsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[]
  }

  /**
   * branches.users
   */
  export type branches$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * branches.users_branches
   */
  export type branches$users_branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_branches
     */
    select?: users_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_branches
     */
    omit?: users_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_branchesInclude<ExtArgs> | null
    where?: users_branchesWhereInput
    orderBy?: users_branchesOrderByWithRelationInput | users_branchesOrderByWithRelationInput[]
    cursor?: users_branchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Users_branchesScalarFieldEnum | Users_branchesScalarFieldEnum[]
  }

  /**
   * branches without action
   */
  export type branchesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the branches
     */
    select?: branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the branches
     */
    omit?: branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: branchesInclude<ExtArgs> | null
  }


  /**
   * Model users_branches
   */

  export type AggregateUsers_branches = {
    _count: Users_branchesCountAggregateOutputType | null
    _avg: Users_branchesAvgAggregateOutputType | null
    _sum: Users_branchesSumAggregateOutputType | null
    _min: Users_branchesMinAggregateOutputType | null
    _max: Users_branchesMaxAggregateOutputType | null
  }

  export type Users_branchesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    branch_id: number | null
  }

  export type Users_branchesSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    branch_id: number | null
  }

  export type Users_branchesMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    branch_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status | null
  }

  export type Users_branchesMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    branch_id: number | null
    created_at: Date | null
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status | null
  }

  export type Users_branchesCountAggregateOutputType = {
    id: number
    user_id: number
    branch_id: number
    created_at: number
    updated_at: number
    deleted_at: number
    status: number
    _all: number
  }


  export type Users_branchesAvgAggregateInputType = {
    id?: true
    user_id?: true
    branch_id?: true
  }

  export type Users_branchesSumAggregateInputType = {
    id?: true
    user_id?: true
    branch_id?: true
  }

  export type Users_branchesMinAggregateInputType = {
    id?: true
    user_id?: true
    branch_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
  }

  export type Users_branchesMaxAggregateInputType = {
    id?: true
    user_id?: true
    branch_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
  }

  export type Users_branchesCountAggregateInputType = {
    id?: true
    user_id?: true
    branch_id?: true
    created_at?: true
    updated_at?: true
    deleted_at?: true
    status?: true
    _all?: true
  }

  export type Users_branchesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_branches to aggregate.
     */
    where?: users_branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_branches to fetch.
     */
    orderBy?: users_branchesOrderByWithRelationInput | users_branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: users_branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users_branches
    **/
    _count?: true | Users_branchesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Users_branchesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Users_branchesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users_branchesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users_branchesMaxAggregateInputType
  }

  export type GetUsers_branchesAggregateType<T extends Users_branchesAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers_branches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers_branches[P]>
      : GetScalarType<T[P], AggregateUsers_branches[P]>
  }




  export type users_branchesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: users_branchesWhereInput
    orderBy?: users_branchesOrderByWithAggregationInput | users_branchesOrderByWithAggregationInput[]
    by: Users_branchesScalarFieldEnum[] | Users_branchesScalarFieldEnum
    having?: users_branchesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users_branchesCountAggregateInputType | true
    _avg?: Users_branchesAvgAggregateInputType
    _sum?: Users_branchesSumAggregateInputType
    _min?: Users_branchesMinAggregateInputType
    _max?: Users_branchesMaxAggregateInputType
  }

  export type Users_branchesGroupByOutputType = {
    id: number
    user_id: number
    branch_id: number
    created_at: Date
    updated_at: Date | null
    deleted_at: Date | null
    status: $Enums.shared_status
    _count: Users_branchesCountAggregateOutputType | null
    _avg: Users_branchesAvgAggregateOutputType | null
    _sum: Users_branchesSumAggregateOutputType | null
    _min: Users_branchesMinAggregateOutputType | null
    _max: Users_branchesMaxAggregateOutputType | null
  }

  type GetUsers_branchesGroupByPayload<T extends users_branchesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Users_branchesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users_branchesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users_branchesGroupByOutputType[P]>
            : GetScalarType<T[P], Users_branchesGroupByOutputType[P]>
        }
      >
    >


  export type users_branchesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    branch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    status?: boolean
    branch?: boolean | branchesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users_branches"]>



  export type users_branchesSelectScalar = {
    id?: boolean
    user_id?: boolean
    branch_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    deleted_at?: boolean
    status?: boolean
  }

  export type users_branchesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "branch_id" | "created_at" | "updated_at" | "deleted_at" | "status", ExtArgs["result"]["users_branches"]>
  export type users_branchesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | branchesDefaultArgs<ExtArgs>
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $users_branchesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users_branches"
    objects: {
      branch: Prisma.$branchesPayload<ExtArgs>
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      branch_id: number
      created_at: Date
      updated_at: Date | null
      deleted_at: Date | null
      status: $Enums.shared_status
    }, ExtArgs["result"]["users_branches"]>
    composites: {}
  }

  type users_branchesGetPayload<S extends boolean | null | undefined | users_branchesDefaultArgs> = $Result.GetResult<Prisma.$users_branchesPayload, S>

  type users_branchesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<users_branchesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Users_branchesCountAggregateInputType | true
    }

  export interface users_branchesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users_branches'], meta: { name: 'users_branches' } }
    /**
     * Find zero or one Users_branches that matches the filter.
     * @param {users_branchesFindUniqueArgs} args - Arguments to find a Users_branches
     * @example
     * // Get one Users_branches
     * const users_branches = await prisma.users_branches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends users_branchesFindUniqueArgs>(args: SelectSubset<T, users_branchesFindUniqueArgs<ExtArgs>>): Prisma__users_branchesClient<$Result.GetResult<Prisma.$users_branchesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users_branches that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {users_branchesFindUniqueOrThrowArgs} args - Arguments to find a Users_branches
     * @example
     * // Get one Users_branches
     * const users_branches = await prisma.users_branches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends users_branchesFindUniqueOrThrowArgs>(args: SelectSubset<T, users_branchesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__users_branchesClient<$Result.GetResult<Prisma.$users_branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users_branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_branchesFindFirstArgs} args - Arguments to find a Users_branches
     * @example
     * // Get one Users_branches
     * const users_branches = await prisma.users_branches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends users_branchesFindFirstArgs>(args?: SelectSubset<T, users_branchesFindFirstArgs<ExtArgs>>): Prisma__users_branchesClient<$Result.GetResult<Prisma.$users_branchesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users_branches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_branchesFindFirstOrThrowArgs} args - Arguments to find a Users_branches
     * @example
     * // Get one Users_branches
     * const users_branches = await prisma.users_branches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends users_branchesFindFirstOrThrowArgs>(args?: SelectSubset<T, users_branchesFindFirstOrThrowArgs<ExtArgs>>): Prisma__users_branchesClient<$Result.GetResult<Prisma.$users_branchesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users_branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_branchesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users_branches
     * const users_branches = await prisma.users_branches.findMany()
     * 
     * // Get first 10 Users_branches
     * const users_branches = await prisma.users_branches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const users_branchesWithIdOnly = await prisma.users_branches.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends users_branchesFindManyArgs>(args?: SelectSubset<T, users_branchesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$users_branchesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users_branches.
     * @param {users_branchesCreateArgs} args - Arguments to create a Users_branches.
     * @example
     * // Create one Users_branches
     * const Users_branches = await prisma.users_branches.create({
     *   data: {
     *     // ... data to create a Users_branches
     *   }
     * })
     * 
     */
    create<T extends users_branchesCreateArgs>(args: SelectSubset<T, users_branchesCreateArgs<ExtArgs>>): Prisma__users_branchesClient<$Result.GetResult<Prisma.$users_branchesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users_branches.
     * @param {users_branchesCreateManyArgs} args - Arguments to create many Users_branches.
     * @example
     * // Create many Users_branches
     * const users_branches = await prisma.users_branches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends users_branchesCreateManyArgs>(args?: SelectSubset<T, users_branchesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users_branches.
     * @param {users_branchesDeleteArgs} args - Arguments to delete one Users_branches.
     * @example
     * // Delete one Users_branches
     * const Users_branches = await prisma.users_branches.delete({
     *   where: {
     *     // ... filter to delete one Users_branches
     *   }
     * })
     * 
     */
    delete<T extends users_branchesDeleteArgs>(args: SelectSubset<T, users_branchesDeleteArgs<ExtArgs>>): Prisma__users_branchesClient<$Result.GetResult<Prisma.$users_branchesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users_branches.
     * @param {users_branchesUpdateArgs} args - Arguments to update one Users_branches.
     * @example
     * // Update one Users_branches
     * const users_branches = await prisma.users_branches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends users_branchesUpdateArgs>(args: SelectSubset<T, users_branchesUpdateArgs<ExtArgs>>): Prisma__users_branchesClient<$Result.GetResult<Prisma.$users_branchesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users_branches.
     * @param {users_branchesDeleteManyArgs} args - Arguments to filter Users_branches to delete.
     * @example
     * // Delete a few Users_branches
     * const { count } = await prisma.users_branches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends users_branchesDeleteManyArgs>(args?: SelectSubset<T, users_branchesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users_branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_branchesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users_branches
     * const users_branches = await prisma.users_branches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends users_branchesUpdateManyArgs>(args: SelectSubset<T, users_branchesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users_branches.
     * @param {users_branchesUpsertArgs} args - Arguments to update or create a Users_branches.
     * @example
     * // Update or create a Users_branches
     * const users_branches = await prisma.users_branches.upsert({
     *   create: {
     *     // ... data to create a Users_branches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users_branches we want to update
     *   }
     * })
     */
    upsert<T extends users_branchesUpsertArgs>(args: SelectSubset<T, users_branchesUpsertArgs<ExtArgs>>): Prisma__users_branchesClient<$Result.GetResult<Prisma.$users_branchesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users_branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_branchesCountArgs} args - Arguments to filter Users_branches to count.
     * @example
     * // Count the number of Users_branches
     * const count = await prisma.users_branches.count({
     *   where: {
     *     // ... the filter for the Users_branches we want to count
     *   }
     * })
    **/
    count<T extends users_branchesCountArgs>(
      args?: Subset<T, users_branchesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users_branchesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users_branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_branchesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users_branchesAggregateArgs>(args: Subset<T, Users_branchesAggregateArgs>): Prisma.PrismaPromise<GetUsers_branchesAggregateType<T>>

    /**
     * Group by Users_branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_branchesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends users_branchesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: users_branchesGroupByArgs['orderBy'] }
        : { orderBy?: users_branchesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, users_branchesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers_branchesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users_branches model
   */
  readonly fields: users_branchesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users_branches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__users_branchesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends branchesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, branchesDefaultArgs<ExtArgs>>): Prisma__branchesClient<$Result.GetResult<Prisma.$branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users_branches model
   */
  interface users_branchesFieldRefs {
    readonly id: FieldRef<"users_branches", 'Int'>
    readonly user_id: FieldRef<"users_branches", 'Int'>
    readonly branch_id: FieldRef<"users_branches", 'Int'>
    readonly created_at: FieldRef<"users_branches", 'DateTime'>
    readonly updated_at: FieldRef<"users_branches", 'DateTime'>
    readonly deleted_at: FieldRef<"users_branches", 'DateTime'>
    readonly status: FieldRef<"users_branches", 'shared_status'>
  }
    

  // Custom InputTypes
  /**
   * users_branches findUnique
   */
  export type users_branchesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_branches
     */
    select?: users_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_branches
     */
    omit?: users_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_branchesInclude<ExtArgs> | null
    /**
     * Filter, which users_branches to fetch.
     */
    where: users_branchesWhereUniqueInput
  }

  /**
   * users_branches findUniqueOrThrow
   */
  export type users_branchesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_branches
     */
    select?: users_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_branches
     */
    omit?: users_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_branchesInclude<ExtArgs> | null
    /**
     * Filter, which users_branches to fetch.
     */
    where: users_branchesWhereUniqueInput
  }

  /**
   * users_branches findFirst
   */
  export type users_branchesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_branches
     */
    select?: users_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_branches
     */
    omit?: users_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_branchesInclude<ExtArgs> | null
    /**
     * Filter, which users_branches to fetch.
     */
    where?: users_branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_branches to fetch.
     */
    orderBy?: users_branchesOrderByWithRelationInput | users_branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_branches.
     */
    cursor?: users_branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_branches.
     */
    distinct?: Users_branchesScalarFieldEnum | Users_branchesScalarFieldEnum[]
  }

  /**
   * users_branches findFirstOrThrow
   */
  export type users_branchesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_branches
     */
    select?: users_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_branches
     */
    omit?: users_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_branchesInclude<ExtArgs> | null
    /**
     * Filter, which users_branches to fetch.
     */
    where?: users_branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_branches to fetch.
     */
    orderBy?: users_branchesOrderByWithRelationInput | users_branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_branches.
     */
    cursor?: users_branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_branches.
     */
    distinct?: Users_branchesScalarFieldEnum | Users_branchesScalarFieldEnum[]
  }

  /**
   * users_branches findMany
   */
  export type users_branchesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_branches
     */
    select?: users_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_branches
     */
    omit?: users_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_branchesInclude<ExtArgs> | null
    /**
     * Filter, which users_branches to fetch.
     */
    where?: users_branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_branches to fetch.
     */
    orderBy?: users_branchesOrderByWithRelationInput | users_branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users_branches.
     */
    cursor?: users_branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_branches.
     */
    skip?: number
    distinct?: Users_branchesScalarFieldEnum | Users_branchesScalarFieldEnum[]
  }

  /**
   * users_branches create
   */
  export type users_branchesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_branches
     */
    select?: users_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_branches
     */
    omit?: users_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_branchesInclude<ExtArgs> | null
    /**
     * The data needed to create a users_branches.
     */
    data: XOR<users_branchesCreateInput, users_branchesUncheckedCreateInput>
  }

  /**
   * users_branches createMany
   */
  export type users_branchesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users_branches.
     */
    data: users_branchesCreateManyInput | users_branchesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users_branches update
   */
  export type users_branchesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_branches
     */
    select?: users_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_branches
     */
    omit?: users_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_branchesInclude<ExtArgs> | null
    /**
     * The data needed to update a users_branches.
     */
    data: XOR<users_branchesUpdateInput, users_branchesUncheckedUpdateInput>
    /**
     * Choose, which users_branches to update.
     */
    where: users_branchesWhereUniqueInput
  }

  /**
   * users_branches updateMany
   */
  export type users_branchesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users_branches.
     */
    data: XOR<users_branchesUpdateManyMutationInput, users_branchesUncheckedUpdateManyInput>
    /**
     * Filter which users_branches to update
     */
    where?: users_branchesWhereInput
    /**
     * Limit how many users_branches to update.
     */
    limit?: number
  }

  /**
   * users_branches upsert
   */
  export type users_branchesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_branches
     */
    select?: users_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_branches
     */
    omit?: users_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_branchesInclude<ExtArgs> | null
    /**
     * The filter to search for the users_branches to update in case it exists.
     */
    where: users_branchesWhereUniqueInput
    /**
     * In case the users_branches found by the `where` argument doesn't exist, create a new users_branches with this data.
     */
    create: XOR<users_branchesCreateInput, users_branchesUncheckedCreateInput>
    /**
     * In case the users_branches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<users_branchesUpdateInput, users_branchesUncheckedUpdateInput>
  }

  /**
   * users_branches delete
   */
  export type users_branchesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_branches
     */
    select?: users_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_branches
     */
    omit?: users_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_branchesInclude<ExtArgs> | null
    /**
     * Filter which users_branches to delete.
     */
    where: users_branchesWhereUniqueInput
  }

  /**
   * users_branches deleteMany
   */
  export type users_branchesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users_branches to delete
     */
    where?: users_branchesWhereInput
    /**
     * Limit how many users_branches to delete.
     */
    limit?: number
  }

  /**
   * users_branches without action
   */
  export type users_branchesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users_branches
     */
    select?: users_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users_branches
     */
    omit?: users_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: users_branchesInclude<ExtArgs> | null
  }


  /**
   * Model events_log
   */

  export type AggregateEvents_log = {
    _count: Events_logCountAggregateOutputType | null
    _avg: Events_logAvgAggregateOutputType | null
    _sum: Events_logSumAggregateOutputType | null
    _min: Events_logMinAggregateOutputType | null
    _max: Events_logMaxAggregateOutputType | null
  }

  export type Events_logAvgAggregateOutputType = {
    id: number | null
    fld: number | null
    event_by: number | null
  }

  export type Events_logSumAggregateOutputType = {
    id: number | null
    fld: number | null
    event_by: number | null
  }

  export type Events_logMinAggregateOutputType = {
    id: number | null
    tbl: string | null
    fld: number | null
    details: string | null
    event_date: Date | null
    event_by: number | null
    status: $Enums.shared_status | null
    deleted_at: Date | null
  }

  export type Events_logMaxAggregateOutputType = {
    id: number | null
    tbl: string | null
    fld: number | null
    details: string | null
    event_date: Date | null
    event_by: number | null
    status: $Enums.shared_status | null
    deleted_at: Date | null
  }

  export type Events_logCountAggregateOutputType = {
    id: number
    tbl: number
    fld: number
    details: number
    event_date: number
    event_by: number
    status: number
    deleted_at: number
    _all: number
  }


  export type Events_logAvgAggregateInputType = {
    id?: true
    fld?: true
    event_by?: true
  }

  export type Events_logSumAggregateInputType = {
    id?: true
    fld?: true
    event_by?: true
  }

  export type Events_logMinAggregateInputType = {
    id?: true
    tbl?: true
    fld?: true
    details?: true
    event_date?: true
    event_by?: true
    status?: true
    deleted_at?: true
  }

  export type Events_logMaxAggregateInputType = {
    id?: true
    tbl?: true
    fld?: true
    details?: true
    event_date?: true
    event_by?: true
    status?: true
    deleted_at?: true
  }

  export type Events_logCountAggregateInputType = {
    id?: true
    tbl?: true
    fld?: true
    details?: true
    event_date?: true
    event_by?: true
    status?: true
    deleted_at?: true
    _all?: true
  }

  export type Events_logAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which events_log to aggregate.
     */
    where?: events_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events_logs to fetch.
     */
    orderBy?: events_logOrderByWithRelationInput | events_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: events_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned events_logs
    **/
    _count?: true | Events_logCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Events_logAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Events_logSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Events_logMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Events_logMaxAggregateInputType
  }

  export type GetEvents_logAggregateType<T extends Events_logAggregateArgs> = {
        [P in keyof T & keyof AggregateEvents_log]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvents_log[P]>
      : GetScalarType<T[P], AggregateEvents_log[P]>
  }




  export type events_logGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: events_logWhereInput
    orderBy?: events_logOrderByWithAggregationInput | events_logOrderByWithAggregationInput[]
    by: Events_logScalarFieldEnum[] | Events_logScalarFieldEnum
    having?: events_logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Events_logCountAggregateInputType | true
    _avg?: Events_logAvgAggregateInputType
    _sum?: Events_logSumAggregateInputType
    _min?: Events_logMinAggregateInputType
    _max?: Events_logMaxAggregateInputType
  }

  export type Events_logGroupByOutputType = {
    id: number
    tbl: string
    fld: number
    details: string
    event_date: Date
    event_by: number
    status: $Enums.shared_status
    deleted_at: Date | null
    _count: Events_logCountAggregateOutputType | null
    _avg: Events_logAvgAggregateOutputType | null
    _sum: Events_logSumAggregateOutputType | null
    _min: Events_logMinAggregateOutputType | null
    _max: Events_logMaxAggregateOutputType | null
  }

  type GetEvents_logGroupByPayload<T extends events_logGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Events_logGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Events_logGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Events_logGroupByOutputType[P]>
            : GetScalarType<T[P], Events_logGroupByOutputType[P]>
        }
      >
    >


  export type events_logSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tbl?: boolean
    fld?: boolean
    details?: boolean
    event_date?: boolean
    event_by?: boolean
    status?: boolean
    deleted_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["events_log"]>



  export type events_logSelectScalar = {
    id?: boolean
    tbl?: boolean
    fld?: boolean
    details?: boolean
    event_date?: boolean
    event_by?: boolean
    status?: boolean
    deleted_at?: boolean
  }

  export type events_logOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tbl" | "fld" | "details" | "event_date" | "event_by" | "status" | "deleted_at", ExtArgs["result"]["events_log"]>
  export type events_logInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $events_logPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "events_log"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tbl: string
      fld: number
      details: string
      event_date: Date
      event_by: number
      status: $Enums.shared_status
      deleted_at: Date | null
    }, ExtArgs["result"]["events_log"]>
    composites: {}
  }

  type events_logGetPayload<S extends boolean | null | undefined | events_logDefaultArgs> = $Result.GetResult<Prisma.$events_logPayload, S>

  type events_logCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<events_logFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Events_logCountAggregateInputType | true
    }

  export interface events_logDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['events_log'], meta: { name: 'events_log' } }
    /**
     * Find zero or one Events_log that matches the filter.
     * @param {events_logFindUniqueArgs} args - Arguments to find a Events_log
     * @example
     * // Get one Events_log
     * const events_log = await prisma.events_log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends events_logFindUniqueArgs>(args: SelectSubset<T, events_logFindUniqueArgs<ExtArgs>>): Prisma__events_logClient<$Result.GetResult<Prisma.$events_logPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Events_log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {events_logFindUniqueOrThrowArgs} args - Arguments to find a Events_log
     * @example
     * // Get one Events_log
     * const events_log = await prisma.events_log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends events_logFindUniqueOrThrowArgs>(args: SelectSubset<T, events_logFindUniqueOrThrowArgs<ExtArgs>>): Prisma__events_logClient<$Result.GetResult<Prisma.$events_logPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Events_log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {events_logFindFirstArgs} args - Arguments to find a Events_log
     * @example
     * // Get one Events_log
     * const events_log = await prisma.events_log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends events_logFindFirstArgs>(args?: SelectSubset<T, events_logFindFirstArgs<ExtArgs>>): Prisma__events_logClient<$Result.GetResult<Prisma.$events_logPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Events_log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {events_logFindFirstOrThrowArgs} args - Arguments to find a Events_log
     * @example
     * // Get one Events_log
     * const events_log = await prisma.events_log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends events_logFindFirstOrThrowArgs>(args?: SelectSubset<T, events_logFindFirstOrThrowArgs<ExtArgs>>): Prisma__events_logClient<$Result.GetResult<Prisma.$events_logPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {events_logFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events_logs
     * const events_logs = await prisma.events_log.findMany()
     * 
     * // Get first 10 Events_logs
     * const events_logs = await prisma.events_log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const events_logWithIdOnly = await prisma.events_log.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends events_logFindManyArgs>(args?: SelectSubset<T, events_logFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$events_logPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Events_log.
     * @param {events_logCreateArgs} args - Arguments to create a Events_log.
     * @example
     * // Create one Events_log
     * const Events_log = await prisma.events_log.create({
     *   data: {
     *     // ... data to create a Events_log
     *   }
     * })
     * 
     */
    create<T extends events_logCreateArgs>(args: SelectSubset<T, events_logCreateArgs<ExtArgs>>): Prisma__events_logClient<$Result.GetResult<Prisma.$events_logPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events_logs.
     * @param {events_logCreateManyArgs} args - Arguments to create many Events_logs.
     * @example
     * // Create many Events_logs
     * const events_log = await prisma.events_log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends events_logCreateManyArgs>(args?: SelectSubset<T, events_logCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Events_log.
     * @param {events_logDeleteArgs} args - Arguments to delete one Events_log.
     * @example
     * // Delete one Events_log
     * const Events_log = await prisma.events_log.delete({
     *   where: {
     *     // ... filter to delete one Events_log
     *   }
     * })
     * 
     */
    delete<T extends events_logDeleteArgs>(args: SelectSubset<T, events_logDeleteArgs<ExtArgs>>): Prisma__events_logClient<$Result.GetResult<Prisma.$events_logPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Events_log.
     * @param {events_logUpdateArgs} args - Arguments to update one Events_log.
     * @example
     * // Update one Events_log
     * const events_log = await prisma.events_log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends events_logUpdateArgs>(args: SelectSubset<T, events_logUpdateArgs<ExtArgs>>): Prisma__events_logClient<$Result.GetResult<Prisma.$events_logPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events_logs.
     * @param {events_logDeleteManyArgs} args - Arguments to filter Events_logs to delete.
     * @example
     * // Delete a few Events_logs
     * const { count } = await prisma.events_log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends events_logDeleteManyArgs>(args?: SelectSubset<T, events_logDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {events_logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events_logs
     * const events_log = await prisma.events_log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends events_logUpdateManyArgs>(args: SelectSubset<T, events_logUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Events_log.
     * @param {events_logUpsertArgs} args - Arguments to update or create a Events_log.
     * @example
     * // Update or create a Events_log
     * const events_log = await prisma.events_log.upsert({
     *   create: {
     *     // ... data to create a Events_log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Events_log we want to update
     *   }
     * })
     */
    upsert<T extends events_logUpsertArgs>(args: SelectSubset<T, events_logUpsertArgs<ExtArgs>>): Prisma__events_logClient<$Result.GetResult<Prisma.$events_logPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {events_logCountArgs} args - Arguments to filter Events_logs to count.
     * @example
     * // Count the number of Events_logs
     * const count = await prisma.events_log.count({
     *   where: {
     *     // ... the filter for the Events_logs we want to count
     *   }
     * })
    **/
    count<T extends events_logCountArgs>(
      args?: Subset<T, events_logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Events_logCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Events_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Events_logAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Events_logAggregateArgs>(args: Subset<T, Events_logAggregateArgs>): Prisma.PrismaPromise<GetEvents_logAggregateType<T>>

    /**
     * Group by Events_log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {events_logGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends events_logGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: events_logGroupByArgs['orderBy'] }
        : { orderBy?: events_logGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, events_logGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvents_logGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the events_log model
   */
  readonly fields: events_logFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for events_log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__events_logClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the events_log model
   */
  interface events_logFieldRefs {
    readonly id: FieldRef<"events_log", 'Int'>
    readonly tbl: FieldRef<"events_log", 'String'>
    readonly fld: FieldRef<"events_log", 'Int'>
    readonly details: FieldRef<"events_log", 'String'>
    readonly event_date: FieldRef<"events_log", 'DateTime'>
    readonly event_by: FieldRef<"events_log", 'Int'>
    readonly status: FieldRef<"events_log", 'shared_status'>
    readonly deleted_at: FieldRef<"events_log", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * events_log findUnique
   */
  export type events_logFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events_log
     */
    select?: events_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the events_log
     */
    omit?: events_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: events_logInclude<ExtArgs> | null
    /**
     * Filter, which events_log to fetch.
     */
    where: events_logWhereUniqueInput
  }

  /**
   * events_log findUniqueOrThrow
   */
  export type events_logFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events_log
     */
    select?: events_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the events_log
     */
    omit?: events_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: events_logInclude<ExtArgs> | null
    /**
     * Filter, which events_log to fetch.
     */
    where: events_logWhereUniqueInput
  }

  /**
   * events_log findFirst
   */
  export type events_logFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events_log
     */
    select?: events_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the events_log
     */
    omit?: events_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: events_logInclude<ExtArgs> | null
    /**
     * Filter, which events_log to fetch.
     */
    where?: events_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events_logs to fetch.
     */
    orderBy?: events_logOrderByWithRelationInput | events_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events_logs.
     */
    cursor?: events_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events_logs.
     */
    distinct?: Events_logScalarFieldEnum | Events_logScalarFieldEnum[]
  }

  /**
   * events_log findFirstOrThrow
   */
  export type events_logFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events_log
     */
    select?: events_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the events_log
     */
    omit?: events_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: events_logInclude<ExtArgs> | null
    /**
     * Filter, which events_log to fetch.
     */
    where?: events_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events_logs to fetch.
     */
    orderBy?: events_logOrderByWithRelationInput | events_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for events_logs.
     */
    cursor?: events_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of events_logs.
     */
    distinct?: Events_logScalarFieldEnum | Events_logScalarFieldEnum[]
  }

  /**
   * events_log findMany
   */
  export type events_logFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events_log
     */
    select?: events_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the events_log
     */
    omit?: events_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: events_logInclude<ExtArgs> | null
    /**
     * Filter, which events_logs to fetch.
     */
    where?: events_logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of events_logs to fetch.
     */
    orderBy?: events_logOrderByWithRelationInput | events_logOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing events_logs.
     */
    cursor?: events_logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` events_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` events_logs.
     */
    skip?: number
    distinct?: Events_logScalarFieldEnum | Events_logScalarFieldEnum[]
  }

  /**
   * events_log create
   */
  export type events_logCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events_log
     */
    select?: events_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the events_log
     */
    omit?: events_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: events_logInclude<ExtArgs> | null
    /**
     * The data needed to create a events_log.
     */
    data: XOR<events_logCreateInput, events_logUncheckedCreateInput>
  }

  /**
   * events_log createMany
   */
  export type events_logCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many events_logs.
     */
    data: events_logCreateManyInput | events_logCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * events_log update
   */
  export type events_logUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events_log
     */
    select?: events_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the events_log
     */
    omit?: events_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: events_logInclude<ExtArgs> | null
    /**
     * The data needed to update a events_log.
     */
    data: XOR<events_logUpdateInput, events_logUncheckedUpdateInput>
    /**
     * Choose, which events_log to update.
     */
    where: events_logWhereUniqueInput
  }

  /**
   * events_log updateMany
   */
  export type events_logUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update events_logs.
     */
    data: XOR<events_logUpdateManyMutationInput, events_logUncheckedUpdateManyInput>
    /**
     * Filter which events_logs to update
     */
    where?: events_logWhereInput
    /**
     * Limit how many events_logs to update.
     */
    limit?: number
  }

  /**
   * events_log upsert
   */
  export type events_logUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events_log
     */
    select?: events_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the events_log
     */
    omit?: events_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: events_logInclude<ExtArgs> | null
    /**
     * The filter to search for the events_log to update in case it exists.
     */
    where: events_logWhereUniqueInput
    /**
     * In case the events_log found by the `where` argument doesn't exist, create a new events_log with this data.
     */
    create: XOR<events_logCreateInput, events_logUncheckedCreateInput>
    /**
     * In case the events_log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<events_logUpdateInput, events_logUncheckedUpdateInput>
  }

  /**
   * events_log delete
   */
  export type events_logDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events_log
     */
    select?: events_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the events_log
     */
    omit?: events_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: events_logInclude<ExtArgs> | null
    /**
     * Filter which events_log to delete.
     */
    where: events_logWhereUniqueInput
  }

  /**
   * events_log deleteMany
   */
  export type events_logDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which events_logs to delete
     */
    where?: events_logWhereInput
    /**
     * Limit how many events_logs to delete.
     */
    limit?: number
  }

  /**
   * events_log without action
   */
  export type events_logDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the events_log
     */
    select?: events_logSelect<ExtArgs> | null
    /**
     * Omit specific fields from the events_log
     */
    omit?: events_logOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: events_logInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    provider_account_id: 'provider_account_id',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type AccountsScalarFieldEnum = (typeof AccountsScalarFieldEnum)[keyof typeof AccountsScalarFieldEnum]


  export const BookingsScalarFieldEnum: {
    id: 'id',
    quote_id: 'quote_id',
    client_id: 'client_id',
    hotel_id: 'hotel_id',
    travel_date: 'travel_date',
    return_date: 'return_date',
    meal_plan: 'meal_plan',
    room_category: 'room_category',
    status: 'status',
    voucher_url: 'voucher_url',
    agent_id: 'agent_id',
    invoiceid: 'invoiceid',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    public_id: 'public_id'
  };

  export type BookingsScalarFieldEnum = (typeof BookingsScalarFieldEnum)[keyof typeof BookingsScalarFieldEnum]


  export const CancellationsScalarFieldEnum: {
    id: 'id',
    booking_id: 'booking_id',
    cancellation_date: 'cancellation_date',
    reason: 'reason',
    hotel_charges: 'hotel_charges',
    credit_note_url: 'credit_note_url',
    refund_amount: 'refund_amount',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    processed_by: 'processed_by',
    status: 'status'
  };

  export type CancellationsScalarFieldEnum = (typeof CancellationsScalarFieldEnum)[keyof typeof CancellationsScalarFieldEnum]


  export const ClientsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    public_id: 'public_id',
    status: 'status',
    enc_phone: 'enc_phone',
    branch_id: 'branch_id'
  };

  export type ClientsScalarFieldEnum = (typeof ClientsScalarFieldEnum)[keyof typeof ClientsScalarFieldEnum]


  export const Hotel_policiesScalarFieldEnum: {
    id: 'id',
    cancellation: 'cancellation',
    payment_terms: 'payment_terms',
    commission_terms: 'commission_terms',
    hotel_id: 'hotel_id',
    deleted_at: 'deleted_at',
    created_at: 'created_at',
    status: 'status',
    updated_at: 'updated_at'
  };

  export type Hotel_policiesScalarFieldEnum = (typeof Hotel_policiesScalarFieldEnum)[keyof typeof Hotel_policiesScalarFieldEnum]


  export const HotelsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    contact_email: 'contact_email',
    contact_phone: 'contact_phone',
    commission_rate: 'commission_rate',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    status: 'status',
    enc_phone: 'enc_phone'
  };

  export type HotelsScalarFieldEnum = (typeof HotelsScalarFieldEnum)[keyof typeof HotelsScalarFieldEnum]


  export const InvoicesScalarFieldEnum: {
    id: 'id',
    invoice_number: 'invoice_number',
    quote_id: 'quote_id',
    client_id: 'client_id',
    amount: 'amount',
    tax_amount: 'tax_amount',
    total_amount: 'total_amount',
    due_date: 'due_date',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    public_id: 'public_id'
  };

  export type InvoicesScalarFieldEnum = (typeof InvoicesScalarFieldEnum)[keyof typeof InvoicesScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    title: 'title',
    message: 'message',
    is_read: 'is_read',
    read_at: 'read_at',
    type: 'type',
    reference_id: 'reference_id',
    reference_type: 'reference_type',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    status: 'status'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    invoice_id: 'invoice_id',
    amount: 'amount',
    payment_date: 'payment_date',
    payment_method: 'payment_method',
    transaction_id: 'transaction_id',
    receipt_url: 'receipt_url',
    is_confirmed: 'is_confirmed',
    confirmed_at: 'confirmed_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    public_id: 'public_id',
    status: 'status',
    enc_phone: 'enc_phone',
    phone: 'phone'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const PermissionsScalarFieldEnum: {
    id: 'id',
    role: 'role',
    user_id: 'user_id',
    tbl: 'tbl',
    rec: 'rec',
    general: 'general',
    create: 'create',
    read: 'read',
    update: 'update',
    delete: 'delete',
    custom_action: 'custom_action',
    added_by: 'added_by',
    created_at: 'created_at',
    updated_at: 'updated_at',
    status: 'status',
    deleted_at: 'deleted_at'
  };

  export type PermissionsScalarFieldEnum = (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]


  export const QuotesScalarFieldEnum: {
    id: 'id',
    rate_card_id: 'rate_card_id',
    client_id: 'client_id',
    status: 'status',
    expiration_date: 'expiration_date',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    public_id: 'public_id'
  };

  export type QuotesScalarFieldEnum = (typeof QuotesScalarFieldEnum)[keyof typeof QuotesScalarFieldEnum]


  export const Rack_ratesScalarFieldEnum: {
    id: 'id',
    rate: 'rate',
    currency: 'currency',
    travel_period: 'travel_period',
    meal_plan: 'meal_plan',
    room_category: 'room_category',
    pdf_url: 'pdf_url',
    isProcessed: 'isProcessed',
    processed_date: 'processed_date',
    hotel_id: 'hotel_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    public_id: 'public_id',
    status: 'status'
  };

  export type Rack_ratesScalarFieldEnum = (typeof Rack_ratesScalarFieldEnum)[keyof typeof Rack_ratesScalarFieldEnum]


  export const Rate_cardsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    base_rate: 'base_rate',
    commission_rate: 'commission_rate',
    markup_rate: 'markup_rate',
    discount_amount: 'discount_amount',
    discount_percent: 'discount_percent',
    final_rate: 'final_rate',
    currency: 'currency',
    travel_period: 'travel_period',
    meal_plan: 'meal_plan',
    room_category: 'room_category',
    commission: 'commission',
    is_active: 'is_active',
    rack_rate_id: 'rack_rate_id',
    hotel_id: 'hotel_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    created_by: 'created_by',
    public_id: 'public_id',
    status: 'status'
  };

  export type Rate_cardsScalarFieldEnum = (typeof Rate_cardsScalarFieldEnum)[keyof typeof Rate_cardsScalarFieldEnum]


  export const RemindersScalarFieldEnum: {
    id: 'id',
    invoice_id: 'invoice_id',
    reminder_date: 'reminder_date',
    message: 'message',
    is_sent: 'is_sent',
    sent_at: 'sent_at',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    status: 'status'
  };

  export type RemindersScalarFieldEnum = (typeof RemindersScalarFieldEnum)[keyof typeof RemindersScalarFieldEnum]


  export const SeasonsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    period_type: 'period_type',
    start_date: 'start_date',
    end_date: 'end_date',
    hotel_policy_id: 'hotel_policy_id',
    created_at: 'created_at',
    deleted_at: 'deleted_at',
    status: 'status',
    updated_at: 'updated_at'
  };

  export type SeasonsScalarFieldEnum = (typeof SeasonsScalarFieldEnum)[keyof typeof SeasonsScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    id: 'id',
    session_token: 'session_token',
    user_id: 'user_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    status: 'status',
    deleted_at: 'deleted_at',
    expires_at: 'expires_at'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const TransportationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    provider: 'provider',
    booking_ref: 'booking_ref',
    departure_date: 'departure_date',
    return_date: 'return_date',
    departure_point: 'departure_point',
    arrival_point: 'arrival_point',
    cost: 'cost',
    booking_id: 'booking_id',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at'
  };

  export type TransportationScalarFieldEnum = (typeof TransportationScalarFieldEnum)[keyof typeof TransportationScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    email_verified: 'email_verified',
    password: 'password',
    role: 'role',
    created_at: 'created_at',
    updated_at: 'updated_at',
    status: 'status',
    deleted_at: 'deleted_at',
    public_id: 'public_id',
    password_expiry: 'password_expiry',
    two_factor_enabled: 'two_factor_enabled',
    national_id: 'national_id',
    phone: 'phone',
    branch_id: 'branch_id',
    image: 'image'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const BranchesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    status: 'status'
  };

  export type BranchesScalarFieldEnum = (typeof BranchesScalarFieldEnum)[keyof typeof BranchesScalarFieldEnum]


  export const Users_branchesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    branch_id: 'branch_id',
    created_at: 'created_at',
    updated_at: 'updated_at',
    deleted_at: 'deleted_at',
    status: 'status'
  };

  export type Users_branchesScalarFieldEnum = (typeof Users_branchesScalarFieldEnum)[keyof typeof Users_branchesScalarFieldEnum]


  export const Events_logScalarFieldEnum: {
    id: 'id',
    tbl: 'tbl',
    fld: 'fld',
    details: 'details',
    event_date: 'event_date',
    event_by: 'event_by',
    status: 'status',
    deleted_at: 'deleted_at'
  };

  export type Events_logScalarFieldEnum = (typeof Events_logScalarFieldEnum)[keyof typeof Events_logScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const accountsOrderByRelevanceFieldEnum: {
    type: 'type',
    provider: 'provider',
    provider_account_id: 'provider_account_id',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type accountsOrderByRelevanceFieldEnum = (typeof accountsOrderByRelevanceFieldEnum)[keyof typeof accountsOrderByRelevanceFieldEnum]


  export const bookingsOrderByRelevanceFieldEnum: {
    voucher_url: 'voucher_url',
    public_id: 'public_id'
  };

  export type bookingsOrderByRelevanceFieldEnum = (typeof bookingsOrderByRelevanceFieldEnum)[keyof typeof bookingsOrderByRelevanceFieldEnum]


  export const cancellationsOrderByRelevanceFieldEnum: {
    reason: 'reason',
    credit_note_url: 'credit_note_url'
  };

  export type cancellationsOrderByRelevanceFieldEnum = (typeof cancellationsOrderByRelevanceFieldEnum)[keyof typeof cancellationsOrderByRelevanceFieldEnum]


  export const clientsOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    public_id: 'public_id',
    enc_phone: 'enc_phone'
  };

  export type clientsOrderByRelevanceFieldEnum = (typeof clientsOrderByRelevanceFieldEnum)[keyof typeof clientsOrderByRelevanceFieldEnum]


  export const hotel_policiesOrderByRelevanceFieldEnum: {
    cancellation: 'cancellation',
    payment_terms: 'payment_terms',
    commission_terms: 'commission_terms'
  };

  export type hotel_policiesOrderByRelevanceFieldEnum = (typeof hotel_policiesOrderByRelevanceFieldEnum)[keyof typeof hotel_policiesOrderByRelevanceFieldEnum]


  export const hotelsOrderByRelevanceFieldEnum: {
    name: 'name',
    location: 'location',
    contact_email: 'contact_email',
    contact_phone: 'contact_phone',
    enc_phone: 'enc_phone'
  };

  export type hotelsOrderByRelevanceFieldEnum = (typeof hotelsOrderByRelevanceFieldEnum)[keyof typeof hotelsOrderByRelevanceFieldEnum]


  export const invoicesOrderByRelevanceFieldEnum: {
    invoice_number: 'invoice_number',
    public_id: 'public_id'
  };

  export type invoicesOrderByRelevanceFieldEnum = (typeof invoicesOrderByRelevanceFieldEnum)[keyof typeof invoicesOrderByRelevanceFieldEnum]


  export const notificationsOrderByRelevanceFieldEnum: {
    title: 'title',
    message: 'message',
    reference_type: 'reference_type'
  };

  export type notificationsOrderByRelevanceFieldEnum = (typeof notificationsOrderByRelevanceFieldEnum)[keyof typeof notificationsOrderByRelevanceFieldEnum]


  export const paymentsOrderByRelevanceFieldEnum: {
    transaction_id: 'transaction_id',
    receipt_url: 'receipt_url',
    public_id: 'public_id',
    enc_phone: 'enc_phone',
    phone: 'phone'
  };

  export type paymentsOrderByRelevanceFieldEnum = (typeof paymentsOrderByRelevanceFieldEnum)[keyof typeof paymentsOrderByRelevanceFieldEnum]


  export const permissionsOrderByRelevanceFieldEnum: {
    tbl: 'tbl',
    custom_action: 'custom_action'
  };

  export type permissionsOrderByRelevanceFieldEnum = (typeof permissionsOrderByRelevanceFieldEnum)[keyof typeof permissionsOrderByRelevanceFieldEnum]


  export const quotesOrderByRelevanceFieldEnum: {
    public_id: 'public_id'
  };

  export type quotesOrderByRelevanceFieldEnum = (typeof quotesOrderByRelevanceFieldEnum)[keyof typeof quotesOrderByRelevanceFieldEnum]


  export const rack_ratesOrderByRelevanceFieldEnum: {
    currency: 'currency',
    pdf_url: 'pdf_url',
    public_id: 'public_id'
  };

  export type rack_ratesOrderByRelevanceFieldEnum = (typeof rack_ratesOrderByRelevanceFieldEnum)[keyof typeof rack_ratesOrderByRelevanceFieldEnum]


  export const rate_cardsOrderByRelevanceFieldEnum: {
    name: 'name',
    currency: 'currency',
    public_id: 'public_id'
  };

  export type rate_cardsOrderByRelevanceFieldEnum = (typeof rate_cardsOrderByRelevanceFieldEnum)[keyof typeof rate_cardsOrderByRelevanceFieldEnum]


  export const remindersOrderByRelevanceFieldEnum: {
    message: 'message'
  };

  export type remindersOrderByRelevanceFieldEnum = (typeof remindersOrderByRelevanceFieldEnum)[keyof typeof remindersOrderByRelevanceFieldEnum]


  export const seasonsOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type seasonsOrderByRelevanceFieldEnum = (typeof seasonsOrderByRelevanceFieldEnum)[keyof typeof seasonsOrderByRelevanceFieldEnum]


  export const sessionsOrderByRelevanceFieldEnum: {
    session_token: 'session_token'
  };

  export type sessionsOrderByRelevanceFieldEnum = (typeof sessionsOrderByRelevanceFieldEnum)[keyof typeof sessionsOrderByRelevanceFieldEnum]


  export const transportationOrderByRelevanceFieldEnum: {
    provider: 'provider',
    booking_ref: 'booking_ref',
    departure_point: 'departure_point',
    arrival_point: 'arrival_point'
  };

  export type transportationOrderByRelevanceFieldEnum = (typeof transportationOrderByRelevanceFieldEnum)[keyof typeof transportationOrderByRelevanceFieldEnum]


  export const usersOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    password: 'password',
    public_id: 'public_id',
    national_id: 'national_id',
    phone: 'phone',
    image: 'image'
  };

  export type usersOrderByRelevanceFieldEnum = (typeof usersOrderByRelevanceFieldEnum)[keyof typeof usersOrderByRelevanceFieldEnum]


  export const branchesOrderByRelevanceFieldEnum: {
    name: 'name',
    location: 'location'
  };

  export type branchesOrderByRelevanceFieldEnum = (typeof branchesOrderByRelevanceFieldEnum)[keyof typeof branchesOrderByRelevanceFieldEnum]


  export const events_logOrderByRelevanceFieldEnum: {
    tbl: 'tbl',
    details: 'details'
  };

  export type events_logOrderByRelevanceFieldEnum = (typeof events_logOrderByRelevanceFieldEnum)[keyof typeof events_logOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'bookings_meal_plan'
   */
  export type Enumbookings_meal_planFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'bookings_meal_plan'>
    


  /**
   * Reference to a field of type 'bookings_room_category'
   */
  export type Enumbookings_room_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'bookings_room_category'>
    


  /**
   * Reference to a field of type 'bookings_status'
   */
  export type Enumbookings_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'bookings_status'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'shared_status'
   */
  export type Enumshared_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'shared_status'>
    


  /**
   * Reference to a field of type 'invoices_status'
   */
  export type Enuminvoices_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'invoices_status'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'notifications_type'
   */
  export type Enumnotifications_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'notifications_type'>
    


  /**
   * Reference to a field of type 'payments_payment_method'
   */
  export type Enumpayments_payment_methodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payments_payment_method'>
    


  /**
   * Reference to a field of type 'users_role'
   */
  export type Enumusers_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'users_role'>
    


  /**
   * Reference to a field of type 'quotes_status'
   */
  export type Enumquotes_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'quotes_status'>
    


  /**
   * Reference to a field of type 'rack_rates_travel_period'
   */
  export type Enumrack_rates_travel_periodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'rack_rates_travel_period'>
    


  /**
   * Reference to a field of type 'rack_rates_meal_plan'
   */
  export type Enumrack_rates_meal_planFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'rack_rates_meal_plan'>
    


  /**
   * Reference to a field of type 'rack_rates_room_category'
   */
  export type Enumrack_rates_room_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'rack_rates_room_category'>
    


  /**
   * Reference to a field of type 'rate_cards_travel_period'
   */
  export type Enumrate_cards_travel_periodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'rate_cards_travel_period'>
    


  /**
   * Reference to a field of type 'rate_cards_meal_plan'
   */
  export type Enumrate_cards_meal_planFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'rate_cards_meal_plan'>
    


  /**
   * Reference to a field of type 'rate_cards_room_category'
   */
  export type Enumrate_cards_room_categoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'rate_cards_room_category'>
    


  /**
   * Reference to a field of type 'seasons_period_type'
   */
  export type Enumseasons_period_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'seasons_period_type'>
    


  /**
   * Reference to a field of type 'transportation_type'
   */
  export type Enumtransportation_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'transportation_type'>
    


  /**
   * Reference to a field of type 'transportation_status'
   */
  export type Enumtransportation_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'transportation_status'>
    


  /**
   * Reference to a field of type 'users_status'
   */
  export type Enumusers_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'users_status'>
    
  /**
   * Deep Input Types
   */


  export type accountsWhereInput = {
    AND?: accountsWhereInput | accountsWhereInput[]
    OR?: accountsWhereInput[]
    NOT?: accountsWhereInput | accountsWhereInput[]
    id?: IntFilter<"accounts"> | number
    userId?: IntFilter<"accounts"> | number
    type?: StringFilter<"accounts"> | string
    provider?: StringFilter<"accounts"> | string
    provider_account_id?: StringFilter<"accounts"> | string
    refresh_token?: StringNullableFilter<"accounts"> | string | null
    access_token?: StringNullableFilter<"accounts"> | string | null
    expires_at?: IntNullableFilter<"accounts"> | number | null
    token_type?: StringNullableFilter<"accounts"> | string | null
    scope?: StringNullableFilter<"accounts"> | string | null
    id_token?: StringNullableFilter<"accounts"> | string | null
    session_state?: StringNullableFilter<"accounts"> | string | null
    created_at?: DateTimeFilter<"accounts"> | Date | string
    updated_at?: DateTimeFilter<"accounts"> | Date | string
    deleted_at?: DateTimeNullableFilter<"accounts"> | Date | string | null
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type accountsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    user?: usersOrderByWithRelationInput
    _relevance?: accountsOrderByRelevanceInput
  }

  export type accountsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    provider_provider_account_id?: accountsProviderProvider_account_idCompoundUniqueInput
    AND?: accountsWhereInput | accountsWhereInput[]
    OR?: accountsWhereInput[]
    NOT?: accountsWhereInput | accountsWhereInput[]
    userId?: IntFilter<"accounts"> | number
    type?: StringFilter<"accounts"> | string
    provider?: StringFilter<"accounts"> | string
    provider_account_id?: StringFilter<"accounts"> | string
    refresh_token?: StringNullableFilter<"accounts"> | string | null
    access_token?: StringNullableFilter<"accounts"> | string | null
    expires_at?: IntNullableFilter<"accounts"> | number | null
    token_type?: StringNullableFilter<"accounts"> | string | null
    scope?: StringNullableFilter<"accounts"> | string | null
    id_token?: StringNullableFilter<"accounts"> | string | null
    session_state?: StringNullableFilter<"accounts"> | string | null
    created_at?: DateTimeFilter<"accounts"> | Date | string
    updated_at?: DateTimeFilter<"accounts"> | Date | string
    deleted_at?: DateTimeNullableFilter<"accounts"> | Date | string | null
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "provider_provider_account_id">

  export type accountsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: accountsCountOrderByAggregateInput
    _avg?: accountsAvgOrderByAggregateInput
    _max?: accountsMaxOrderByAggregateInput
    _min?: accountsMinOrderByAggregateInput
    _sum?: accountsSumOrderByAggregateInput
  }

  export type accountsScalarWhereWithAggregatesInput = {
    AND?: accountsScalarWhereWithAggregatesInput | accountsScalarWhereWithAggregatesInput[]
    OR?: accountsScalarWhereWithAggregatesInput[]
    NOT?: accountsScalarWhereWithAggregatesInput | accountsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"accounts"> | number
    userId?: IntWithAggregatesFilter<"accounts"> | number
    type?: StringWithAggregatesFilter<"accounts"> | string
    provider?: StringWithAggregatesFilter<"accounts"> | string
    provider_account_id?: StringWithAggregatesFilter<"accounts"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"accounts"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    scope?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"accounts"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"accounts"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"accounts"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"accounts"> | Date | string | null
  }

  export type bookingsWhereInput = {
    AND?: bookingsWhereInput | bookingsWhereInput[]
    OR?: bookingsWhereInput[]
    NOT?: bookingsWhereInput | bookingsWhereInput[]
    id?: IntFilter<"bookings"> | number
    quote_id?: IntFilter<"bookings"> | number
    client_id?: IntFilter<"bookings"> | number
    hotel_id?: IntFilter<"bookings"> | number
    travel_date?: DateTimeFilter<"bookings"> | Date | string
    return_date?: DateTimeFilter<"bookings"> | Date | string
    meal_plan?: Enumbookings_meal_planFilter<"bookings"> | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFilter<"bookings"> | $Enums.bookings_room_category
    status?: Enumbookings_statusFilter<"bookings"> | $Enums.bookings_status
    voucher_url?: StringNullableFilter<"bookings"> | string | null
    agent_id?: IntFilter<"bookings"> | number
    invoiceid?: IntNullableFilter<"bookings"> | number | null
    created_at?: DateTimeFilter<"bookings"> | Date | string
    updated_at?: DateTimeNullableFilter<"bookings"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"bookings"> | Date | string | null
    public_id?: StringFilter<"bookings"> | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    client?: XOR<ClientsScalarRelationFilter, clientsWhereInput>
    hotel?: XOR<HotelsScalarRelationFilter, hotelsWhereInput>
    invoice?: XOR<InvoicesNullableScalarRelationFilter, invoicesWhereInput> | null
    quote?: XOR<QuotesScalarRelationFilter, quotesWhereInput>
    cancellations?: CancellationsListRelationFilter
    transportation?: TransportationListRelationFilter
    payments?: PaymentsListRelationFilter
  }

  export type bookingsOrderByWithRelationInput = {
    id?: SortOrder
    quote_id?: SortOrder
    client_id?: SortOrder
    hotel_id?: SortOrder
    travel_date?: SortOrder
    return_date?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    status?: SortOrder
    voucher_url?: SortOrderInput | SortOrder
    agent_id?: SortOrder
    invoiceid?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    public_id?: SortOrder
    user?: usersOrderByWithRelationInput
    client?: clientsOrderByWithRelationInput
    hotel?: hotelsOrderByWithRelationInput
    invoice?: invoicesOrderByWithRelationInput
    quote?: quotesOrderByWithRelationInput
    cancellations?: cancellationsOrderByRelationAggregateInput
    transportation?: transportationOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
    _relevance?: bookingsOrderByRelevanceInput
  }

  export type bookingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    quote_id?: number
    invoiceid?: number
    public_id?: string
    AND?: bookingsWhereInput | bookingsWhereInput[]
    OR?: bookingsWhereInput[]
    NOT?: bookingsWhereInput | bookingsWhereInput[]
    client_id?: IntFilter<"bookings"> | number
    hotel_id?: IntFilter<"bookings"> | number
    travel_date?: DateTimeFilter<"bookings"> | Date | string
    return_date?: DateTimeFilter<"bookings"> | Date | string
    meal_plan?: Enumbookings_meal_planFilter<"bookings"> | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFilter<"bookings"> | $Enums.bookings_room_category
    status?: Enumbookings_statusFilter<"bookings"> | $Enums.bookings_status
    voucher_url?: StringNullableFilter<"bookings"> | string | null
    agent_id?: IntFilter<"bookings"> | number
    created_at?: DateTimeFilter<"bookings"> | Date | string
    updated_at?: DateTimeNullableFilter<"bookings"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"bookings"> | Date | string | null
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    client?: XOR<ClientsScalarRelationFilter, clientsWhereInput>
    hotel?: XOR<HotelsScalarRelationFilter, hotelsWhereInput>
    invoice?: XOR<InvoicesNullableScalarRelationFilter, invoicesWhereInput> | null
    quote?: XOR<QuotesScalarRelationFilter, quotesWhereInput>
    cancellations?: CancellationsListRelationFilter
    transportation?: TransportationListRelationFilter
    payments?: PaymentsListRelationFilter
  }, "id" | "quote_id" | "invoiceid" | "public_id">

  export type bookingsOrderByWithAggregationInput = {
    id?: SortOrder
    quote_id?: SortOrder
    client_id?: SortOrder
    hotel_id?: SortOrder
    travel_date?: SortOrder
    return_date?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    status?: SortOrder
    voucher_url?: SortOrderInput | SortOrder
    agent_id?: SortOrder
    invoiceid?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    public_id?: SortOrder
    _count?: bookingsCountOrderByAggregateInput
    _avg?: bookingsAvgOrderByAggregateInput
    _max?: bookingsMaxOrderByAggregateInput
    _min?: bookingsMinOrderByAggregateInput
    _sum?: bookingsSumOrderByAggregateInput
  }

  export type bookingsScalarWhereWithAggregatesInput = {
    AND?: bookingsScalarWhereWithAggregatesInput | bookingsScalarWhereWithAggregatesInput[]
    OR?: bookingsScalarWhereWithAggregatesInput[]
    NOT?: bookingsScalarWhereWithAggregatesInput | bookingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bookings"> | number
    quote_id?: IntWithAggregatesFilter<"bookings"> | number
    client_id?: IntWithAggregatesFilter<"bookings"> | number
    hotel_id?: IntWithAggregatesFilter<"bookings"> | number
    travel_date?: DateTimeWithAggregatesFilter<"bookings"> | Date | string
    return_date?: DateTimeWithAggregatesFilter<"bookings"> | Date | string
    meal_plan?: Enumbookings_meal_planWithAggregatesFilter<"bookings"> | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryWithAggregatesFilter<"bookings"> | $Enums.bookings_room_category
    status?: Enumbookings_statusWithAggregatesFilter<"bookings"> | $Enums.bookings_status
    voucher_url?: StringNullableWithAggregatesFilter<"bookings"> | string | null
    agent_id?: IntWithAggregatesFilter<"bookings"> | number
    invoiceid?: IntNullableWithAggregatesFilter<"bookings"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"bookings"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"bookings"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"bookings"> | Date | string | null
    public_id?: StringWithAggregatesFilter<"bookings"> | string
  }

  export type cancellationsWhereInput = {
    AND?: cancellationsWhereInput | cancellationsWhereInput[]
    OR?: cancellationsWhereInput[]
    NOT?: cancellationsWhereInput | cancellationsWhereInput[]
    id?: IntFilter<"cancellations"> | number
    booking_id?: IntFilter<"cancellations"> | number
    cancellation_date?: DateTimeFilter<"cancellations"> | Date | string
    reason?: StringNullableFilter<"cancellations"> | string | null
    hotel_charges?: FloatFilter<"cancellations"> | number
    credit_note_url?: StringNullableFilter<"cancellations"> | string | null
    refund_amount?: FloatFilter<"cancellations"> | number
    created_at?: DateTimeFilter<"cancellations"> | Date | string
    updated_at?: DateTimeNullableFilter<"cancellations"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"cancellations"> | Date | string | null
    processed_by?: IntFilter<"cancellations"> | number
    status?: Enumshared_statusFilter<"cancellations"> | $Enums.shared_status
    booking?: XOR<BookingsScalarRelationFilter, bookingsWhereInput>
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type cancellationsOrderByWithRelationInput = {
    id?: SortOrder
    booking_id?: SortOrder
    cancellation_date?: SortOrder
    reason?: SortOrderInput | SortOrder
    hotel_charges?: SortOrder
    credit_note_url?: SortOrderInput | SortOrder
    refund_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    processed_by?: SortOrder
    status?: SortOrder
    booking?: bookingsOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
    _relevance?: cancellationsOrderByRelevanceInput
  }

  export type cancellationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cancellationsWhereInput | cancellationsWhereInput[]
    OR?: cancellationsWhereInput[]
    NOT?: cancellationsWhereInput | cancellationsWhereInput[]
    booking_id?: IntFilter<"cancellations"> | number
    cancellation_date?: DateTimeFilter<"cancellations"> | Date | string
    reason?: StringNullableFilter<"cancellations"> | string | null
    hotel_charges?: FloatFilter<"cancellations"> | number
    credit_note_url?: StringNullableFilter<"cancellations"> | string | null
    refund_amount?: FloatFilter<"cancellations"> | number
    created_at?: DateTimeFilter<"cancellations"> | Date | string
    updated_at?: DateTimeNullableFilter<"cancellations"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"cancellations"> | Date | string | null
    processed_by?: IntFilter<"cancellations"> | number
    status?: Enumshared_statusFilter<"cancellations"> | $Enums.shared_status
    booking?: XOR<BookingsScalarRelationFilter, bookingsWhereInput>
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type cancellationsOrderByWithAggregationInput = {
    id?: SortOrder
    booking_id?: SortOrder
    cancellation_date?: SortOrder
    reason?: SortOrderInput | SortOrder
    hotel_charges?: SortOrder
    credit_note_url?: SortOrderInput | SortOrder
    refund_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    processed_by?: SortOrder
    status?: SortOrder
    _count?: cancellationsCountOrderByAggregateInput
    _avg?: cancellationsAvgOrderByAggregateInput
    _max?: cancellationsMaxOrderByAggregateInput
    _min?: cancellationsMinOrderByAggregateInput
    _sum?: cancellationsSumOrderByAggregateInput
  }

  export type cancellationsScalarWhereWithAggregatesInput = {
    AND?: cancellationsScalarWhereWithAggregatesInput | cancellationsScalarWhereWithAggregatesInput[]
    OR?: cancellationsScalarWhereWithAggregatesInput[]
    NOT?: cancellationsScalarWhereWithAggregatesInput | cancellationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cancellations"> | number
    booking_id?: IntWithAggregatesFilter<"cancellations"> | number
    cancellation_date?: DateTimeWithAggregatesFilter<"cancellations"> | Date | string
    reason?: StringNullableWithAggregatesFilter<"cancellations"> | string | null
    hotel_charges?: FloatWithAggregatesFilter<"cancellations"> | number
    credit_note_url?: StringNullableWithAggregatesFilter<"cancellations"> | string | null
    refund_amount?: FloatWithAggregatesFilter<"cancellations"> | number
    created_at?: DateTimeWithAggregatesFilter<"cancellations"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"cancellations"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"cancellations"> | Date | string | null
    processed_by?: IntWithAggregatesFilter<"cancellations"> | number
    status?: Enumshared_statusWithAggregatesFilter<"cancellations"> | $Enums.shared_status
  }

  export type clientsWhereInput = {
    AND?: clientsWhereInput | clientsWhereInput[]
    OR?: clientsWhereInput[]
    NOT?: clientsWhereInput | clientsWhereInput[]
    id?: IntFilter<"clients"> | number
    name?: StringFilter<"clients"> | string
    email?: StringFilter<"clients"> | string
    phone?: StringFilter<"clients"> | string
    address?: StringNullableFilter<"clients"> | string | null
    created_at?: DateTimeFilter<"clients"> | Date | string
    updated_at?: DateTimeNullableFilter<"clients"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"clients"> | Date | string | null
    public_id?: StringFilter<"clients"> | string
    status?: Enumshared_statusFilter<"clients"> | $Enums.shared_status
    enc_phone?: StringFilter<"clients"> | string
    branch_id?: IntNullableFilter<"clients"> | number | null
    bookings?: BookingsListRelationFilter
    branch?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    invoices?: InvoicesListRelationFilter
    quotes?: QuotesListRelationFilter
  }

  export type clientsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    public_id?: SortOrder
    status?: SortOrder
    enc_phone?: SortOrder
    branch_id?: SortOrderInput | SortOrder
    bookings?: bookingsOrderByRelationAggregateInput
    branch?: branchesOrderByWithRelationInput
    invoices?: invoicesOrderByRelationAggregateInput
    quotes?: quotesOrderByRelationAggregateInput
    _relevance?: clientsOrderByRelevanceInput
  }

  export type clientsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    phone?: string
    enc_phone?: string
    AND?: clientsWhereInput | clientsWhereInput[]
    OR?: clientsWhereInput[]
    NOT?: clientsWhereInput | clientsWhereInput[]
    name?: StringFilter<"clients"> | string
    address?: StringNullableFilter<"clients"> | string | null
    created_at?: DateTimeFilter<"clients"> | Date | string
    updated_at?: DateTimeNullableFilter<"clients"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"clients"> | Date | string | null
    public_id?: StringFilter<"clients"> | string
    status?: Enumshared_statusFilter<"clients"> | $Enums.shared_status
    branch_id?: IntNullableFilter<"clients"> | number | null
    bookings?: BookingsListRelationFilter
    branch?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    invoices?: InvoicesListRelationFilter
    quotes?: QuotesListRelationFilter
  }, "id" | "email" | "phone" | "enc_phone">

  export type clientsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    public_id?: SortOrder
    status?: SortOrder
    enc_phone?: SortOrder
    branch_id?: SortOrderInput | SortOrder
    _count?: clientsCountOrderByAggregateInput
    _avg?: clientsAvgOrderByAggregateInput
    _max?: clientsMaxOrderByAggregateInput
    _min?: clientsMinOrderByAggregateInput
    _sum?: clientsSumOrderByAggregateInput
  }

  export type clientsScalarWhereWithAggregatesInput = {
    AND?: clientsScalarWhereWithAggregatesInput | clientsScalarWhereWithAggregatesInput[]
    OR?: clientsScalarWhereWithAggregatesInput[]
    NOT?: clientsScalarWhereWithAggregatesInput | clientsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"clients"> | number
    name?: StringWithAggregatesFilter<"clients"> | string
    email?: StringWithAggregatesFilter<"clients"> | string
    phone?: StringWithAggregatesFilter<"clients"> | string
    address?: StringNullableWithAggregatesFilter<"clients"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"clients"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"clients"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"clients"> | Date | string | null
    public_id?: StringWithAggregatesFilter<"clients"> | string
    status?: Enumshared_statusWithAggregatesFilter<"clients"> | $Enums.shared_status
    enc_phone?: StringWithAggregatesFilter<"clients"> | string
    branch_id?: IntNullableWithAggregatesFilter<"clients"> | number | null
  }

  export type hotel_policiesWhereInput = {
    AND?: hotel_policiesWhereInput | hotel_policiesWhereInput[]
    OR?: hotel_policiesWhereInput[]
    NOT?: hotel_policiesWhereInput | hotel_policiesWhereInput[]
    id?: IntFilter<"hotel_policies"> | number
    cancellation?: StringFilter<"hotel_policies"> | string
    payment_terms?: StringFilter<"hotel_policies"> | string
    commission_terms?: StringFilter<"hotel_policies"> | string
    hotel_id?: IntFilter<"hotel_policies"> | number
    deleted_at?: DateTimeNullableFilter<"hotel_policies"> | Date | string | null
    created_at?: DateTimeFilter<"hotel_policies"> | Date | string
    status?: Enumshared_statusFilter<"hotel_policies"> | $Enums.shared_status
    updated_at?: DateTimeNullableFilter<"hotel_policies"> | Date | string | null
    hotel?: XOR<HotelsScalarRelationFilter, hotelsWhereInput>
    seasons?: SeasonsListRelationFilter
  }

  export type hotel_policiesOrderByWithRelationInput = {
    id?: SortOrder
    cancellation?: SortOrder
    payment_terms?: SortOrder
    commission_terms?: SortOrder
    hotel_id?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    status?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    hotel?: hotelsOrderByWithRelationInput
    seasons?: seasonsOrderByRelationAggregateInput
    _relevance?: hotel_policiesOrderByRelevanceInput
  }

  export type hotel_policiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: hotel_policiesWhereInput | hotel_policiesWhereInput[]
    OR?: hotel_policiesWhereInput[]
    NOT?: hotel_policiesWhereInput | hotel_policiesWhereInput[]
    cancellation?: StringFilter<"hotel_policies"> | string
    payment_terms?: StringFilter<"hotel_policies"> | string
    commission_terms?: StringFilter<"hotel_policies"> | string
    hotel_id?: IntFilter<"hotel_policies"> | number
    deleted_at?: DateTimeNullableFilter<"hotel_policies"> | Date | string | null
    created_at?: DateTimeFilter<"hotel_policies"> | Date | string
    status?: Enumshared_statusFilter<"hotel_policies"> | $Enums.shared_status
    updated_at?: DateTimeNullableFilter<"hotel_policies"> | Date | string | null
    hotel?: XOR<HotelsScalarRelationFilter, hotelsWhereInput>
    seasons?: SeasonsListRelationFilter
  }, "id">

  export type hotel_policiesOrderByWithAggregationInput = {
    id?: SortOrder
    cancellation?: SortOrder
    payment_terms?: SortOrder
    commission_terms?: SortOrder
    hotel_id?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    status?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: hotel_policiesCountOrderByAggregateInput
    _avg?: hotel_policiesAvgOrderByAggregateInput
    _max?: hotel_policiesMaxOrderByAggregateInput
    _min?: hotel_policiesMinOrderByAggregateInput
    _sum?: hotel_policiesSumOrderByAggregateInput
  }

  export type hotel_policiesScalarWhereWithAggregatesInput = {
    AND?: hotel_policiesScalarWhereWithAggregatesInput | hotel_policiesScalarWhereWithAggregatesInput[]
    OR?: hotel_policiesScalarWhereWithAggregatesInput[]
    NOT?: hotel_policiesScalarWhereWithAggregatesInput | hotel_policiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"hotel_policies"> | number
    cancellation?: StringWithAggregatesFilter<"hotel_policies"> | string
    payment_terms?: StringWithAggregatesFilter<"hotel_policies"> | string
    commission_terms?: StringWithAggregatesFilter<"hotel_policies"> | string
    hotel_id?: IntWithAggregatesFilter<"hotel_policies"> | number
    deleted_at?: DateTimeNullableWithAggregatesFilter<"hotel_policies"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"hotel_policies"> | Date | string
    status?: Enumshared_statusWithAggregatesFilter<"hotel_policies"> | $Enums.shared_status
    updated_at?: DateTimeNullableWithAggregatesFilter<"hotel_policies"> | Date | string | null
  }

  export type hotelsWhereInput = {
    AND?: hotelsWhereInput | hotelsWhereInput[]
    OR?: hotelsWhereInput[]
    NOT?: hotelsWhereInput | hotelsWhereInput[]
    id?: IntFilter<"hotels"> | number
    name?: StringFilter<"hotels"> | string
    location?: StringFilter<"hotels"> | string
    contact_email?: StringFilter<"hotels"> | string
    contact_phone?: StringFilter<"hotels"> | string
    commission_rate?: FloatNullableFilter<"hotels"> | number | null
    created_at?: DateTimeFilter<"hotels"> | Date | string
    updated_at?: DateTimeNullableFilter<"hotels"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"hotels"> | Date | string | null
    status?: Enumshared_statusFilter<"hotels"> | $Enums.shared_status
    enc_phone?: StringFilter<"hotels"> | string
    bookings?: BookingsListRelationFilter
    hotel_policies?: Hotel_policiesListRelationFilter
    rack_rates?: Rack_ratesListRelationFilter
    rate_cards?: Rate_cardsListRelationFilter
  }

  export type hotelsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    contact_email?: SortOrder
    contact_phone?: SortOrder
    commission_rate?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    enc_phone?: SortOrder
    bookings?: bookingsOrderByRelationAggregateInput
    hotel_policies?: hotel_policiesOrderByRelationAggregateInput
    rack_rates?: rack_ratesOrderByRelationAggregateInput
    rate_cards?: rate_cardsOrderByRelationAggregateInput
    _relevance?: hotelsOrderByRelevanceInput
  }

  export type hotelsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    contact_email?: string
    contact_phone?: string
    enc_phone?: string
    AND?: hotelsWhereInput | hotelsWhereInput[]
    OR?: hotelsWhereInput[]
    NOT?: hotelsWhereInput | hotelsWhereInput[]
    name?: StringFilter<"hotels"> | string
    location?: StringFilter<"hotels"> | string
    commission_rate?: FloatNullableFilter<"hotels"> | number | null
    created_at?: DateTimeFilter<"hotels"> | Date | string
    updated_at?: DateTimeNullableFilter<"hotels"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"hotels"> | Date | string | null
    status?: Enumshared_statusFilter<"hotels"> | $Enums.shared_status
    bookings?: BookingsListRelationFilter
    hotel_policies?: Hotel_policiesListRelationFilter
    rack_rates?: Rack_ratesListRelationFilter
    rate_cards?: Rate_cardsListRelationFilter
  }, "id" | "contact_email" | "contact_phone" | "enc_phone">

  export type hotelsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    contact_email?: SortOrder
    contact_phone?: SortOrder
    commission_rate?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    enc_phone?: SortOrder
    _count?: hotelsCountOrderByAggregateInput
    _avg?: hotelsAvgOrderByAggregateInput
    _max?: hotelsMaxOrderByAggregateInput
    _min?: hotelsMinOrderByAggregateInput
    _sum?: hotelsSumOrderByAggregateInput
  }

  export type hotelsScalarWhereWithAggregatesInput = {
    AND?: hotelsScalarWhereWithAggregatesInput | hotelsScalarWhereWithAggregatesInput[]
    OR?: hotelsScalarWhereWithAggregatesInput[]
    NOT?: hotelsScalarWhereWithAggregatesInput | hotelsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"hotels"> | number
    name?: StringWithAggregatesFilter<"hotels"> | string
    location?: StringWithAggregatesFilter<"hotels"> | string
    contact_email?: StringWithAggregatesFilter<"hotels"> | string
    contact_phone?: StringWithAggregatesFilter<"hotels"> | string
    commission_rate?: FloatNullableWithAggregatesFilter<"hotels"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"hotels"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"hotels"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"hotels"> | Date | string | null
    status?: Enumshared_statusWithAggregatesFilter<"hotels"> | $Enums.shared_status
    enc_phone?: StringWithAggregatesFilter<"hotels"> | string
  }

  export type invoicesWhereInput = {
    AND?: invoicesWhereInput | invoicesWhereInput[]
    OR?: invoicesWhereInput[]
    NOT?: invoicesWhereInput | invoicesWhereInput[]
    id?: IntFilter<"invoices"> | number
    invoice_number?: StringFilter<"invoices"> | string
    quote_id?: IntFilter<"invoices"> | number
    client_id?: IntFilter<"invoices"> | number
    amount?: FloatFilter<"invoices"> | number
    tax_amount?: FloatFilter<"invoices"> | number
    total_amount?: FloatFilter<"invoices"> | number
    due_date?: DateTimeFilter<"invoices"> | Date | string
    status?: Enuminvoices_statusFilter<"invoices"> | $Enums.invoices_status
    created_at?: DateTimeFilter<"invoices"> | Date | string
    updated_at?: DateTimeNullableFilter<"invoices"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"invoices"> | Date | string | null
    public_id?: StringFilter<"invoices"> | string
    booking?: XOR<BookingsNullableScalarRelationFilter, bookingsWhereInput> | null
    client?: XOR<ClientsScalarRelationFilter, clientsWhereInput>
    quote?: XOR<QuotesScalarRelationFilter, quotesWhereInput>
    payments?: PaymentsListRelationFilter
    reminders?: RemindersListRelationFilter
    users?: UsersListRelationFilter
  }

  export type invoicesOrderByWithRelationInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    quote_id?: SortOrder
    client_id?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    public_id?: SortOrder
    booking?: bookingsOrderByWithRelationInput
    client?: clientsOrderByWithRelationInput
    quote?: quotesOrderByWithRelationInput
    payments?: paymentsOrderByRelationAggregateInput
    reminders?: remindersOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
    _relevance?: invoicesOrderByRelevanceInput
  }

  export type invoicesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    invoice_number?: string
    quote_id?: number
    public_id?: string
    AND?: invoicesWhereInput | invoicesWhereInput[]
    OR?: invoicesWhereInput[]
    NOT?: invoicesWhereInput | invoicesWhereInput[]
    client_id?: IntFilter<"invoices"> | number
    amount?: FloatFilter<"invoices"> | number
    tax_amount?: FloatFilter<"invoices"> | number
    total_amount?: FloatFilter<"invoices"> | number
    due_date?: DateTimeFilter<"invoices"> | Date | string
    status?: Enuminvoices_statusFilter<"invoices"> | $Enums.invoices_status
    created_at?: DateTimeFilter<"invoices"> | Date | string
    updated_at?: DateTimeNullableFilter<"invoices"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"invoices"> | Date | string | null
    booking?: XOR<BookingsNullableScalarRelationFilter, bookingsWhereInput> | null
    client?: XOR<ClientsScalarRelationFilter, clientsWhereInput>
    quote?: XOR<QuotesScalarRelationFilter, quotesWhereInput>
    payments?: PaymentsListRelationFilter
    reminders?: RemindersListRelationFilter
    users?: UsersListRelationFilter
  }, "id" | "invoice_number" | "quote_id" | "public_id">

  export type invoicesOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    quote_id?: SortOrder
    client_id?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    public_id?: SortOrder
    _count?: invoicesCountOrderByAggregateInput
    _avg?: invoicesAvgOrderByAggregateInput
    _max?: invoicesMaxOrderByAggregateInput
    _min?: invoicesMinOrderByAggregateInput
    _sum?: invoicesSumOrderByAggregateInput
  }

  export type invoicesScalarWhereWithAggregatesInput = {
    AND?: invoicesScalarWhereWithAggregatesInput | invoicesScalarWhereWithAggregatesInput[]
    OR?: invoicesScalarWhereWithAggregatesInput[]
    NOT?: invoicesScalarWhereWithAggregatesInput | invoicesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"invoices"> | number
    invoice_number?: StringWithAggregatesFilter<"invoices"> | string
    quote_id?: IntWithAggregatesFilter<"invoices"> | number
    client_id?: IntWithAggregatesFilter<"invoices"> | number
    amount?: FloatWithAggregatesFilter<"invoices"> | number
    tax_amount?: FloatWithAggregatesFilter<"invoices"> | number
    total_amount?: FloatWithAggregatesFilter<"invoices"> | number
    due_date?: DateTimeWithAggregatesFilter<"invoices"> | Date | string
    status?: Enuminvoices_statusWithAggregatesFilter<"invoices"> | $Enums.invoices_status
    created_at?: DateTimeWithAggregatesFilter<"invoices"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"invoices"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"invoices"> | Date | string | null
    public_id?: StringWithAggregatesFilter<"invoices"> | string
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: IntFilter<"notifications"> | number
    user_id?: IntFilter<"notifications"> | number
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    is_read?: BoolFilter<"notifications"> | boolean
    read_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    type?: Enumnotifications_typeFilter<"notifications"> | $Enums.notifications_type
    reference_id?: IntNullableFilter<"notifications"> | number | null
    reference_type?: StringNullableFilter<"notifications"> | string | null
    created_at?: DateTimeFilter<"notifications"> | Date | string
    updated_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    status?: Enumshared_statusFilter<"notifications"> | $Enums.shared_status
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    read_at?: SortOrderInput | SortOrder
    type?: SortOrder
    reference_id?: SortOrderInput | SortOrder
    reference_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    users?: usersOrderByWithRelationInput
    _relevance?: notificationsOrderByRelevanceInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    user_id?: IntFilter<"notifications"> | number
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    is_read?: BoolFilter<"notifications"> | boolean
    read_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    type?: Enumnotifications_typeFilter<"notifications"> | $Enums.notifications_type
    reference_id?: IntNullableFilter<"notifications"> | number | null
    reference_type?: StringNullableFilter<"notifications"> | string | null
    created_at?: DateTimeFilter<"notifications"> | Date | string
    updated_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    status?: Enumshared_statusFilter<"notifications"> | $Enums.shared_status
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    read_at?: SortOrderInput | SortOrder
    type?: SortOrder
    reference_id?: SortOrderInput | SortOrder
    reference_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _avg?: notificationsAvgOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
    _sum?: notificationsSumOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notifications"> | number
    user_id?: IntWithAggregatesFilter<"notifications"> | number
    title?: StringWithAggregatesFilter<"notifications"> | string
    message?: StringWithAggregatesFilter<"notifications"> | string
    is_read?: BoolWithAggregatesFilter<"notifications"> | boolean
    read_at?: DateTimeNullableWithAggregatesFilter<"notifications"> | Date | string | null
    type?: Enumnotifications_typeWithAggregatesFilter<"notifications"> | $Enums.notifications_type
    reference_id?: IntNullableWithAggregatesFilter<"notifications"> | number | null
    reference_type?: StringNullableWithAggregatesFilter<"notifications"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"notifications"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"notifications"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"notifications"> | Date | string | null
    status?: Enumshared_statusWithAggregatesFilter<"notifications"> | $Enums.shared_status
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: IntFilter<"payments"> | number
    invoice_id?: IntFilter<"payments"> | number
    amount?: FloatFilter<"payments"> | number
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: Enumpayments_payment_methodFilter<"payments"> | $Enums.payments_payment_method
    transaction_id?: StringNullableFilter<"payments"> | string | null
    receipt_url?: StringNullableFilter<"payments"> | string | null
    is_confirmed?: BoolFilter<"payments"> | boolean
    confirmed_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    created_at?: DateTimeFilter<"payments"> | Date | string
    updated_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    public_id?: StringFilter<"payments"> | string
    status?: Enumshared_statusFilter<"payments"> | $Enums.shared_status
    enc_phone?: StringNullableFilter<"payments"> | string | null
    phone?: StringNullableFilter<"payments"> | string | null
    invoice?: XOR<InvoicesScalarRelationFilter, invoicesWhereInput>
    bookings?: BookingsListRelationFilter
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrderInput | SortOrder
    receipt_url?: SortOrderInput | SortOrder
    is_confirmed?: SortOrder
    confirmed_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    public_id?: SortOrder
    status?: SortOrder
    enc_phone?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    invoice?: invoicesOrderByWithRelationInput
    bookings?: bookingsOrderByRelationAggregateInput
    _relevance?: paymentsOrderByRelevanceInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    public_id?: string
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    invoice_id?: IntFilter<"payments"> | number
    amount?: FloatFilter<"payments"> | number
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: Enumpayments_payment_methodFilter<"payments"> | $Enums.payments_payment_method
    transaction_id?: StringNullableFilter<"payments"> | string | null
    receipt_url?: StringNullableFilter<"payments"> | string | null
    is_confirmed?: BoolFilter<"payments"> | boolean
    confirmed_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    created_at?: DateTimeFilter<"payments"> | Date | string
    updated_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    status?: Enumshared_statusFilter<"payments"> | $Enums.shared_status
    enc_phone?: StringNullableFilter<"payments"> | string | null
    phone?: StringNullableFilter<"payments"> | string | null
    invoice?: XOR<InvoicesScalarRelationFilter, invoicesWhereInput>
    bookings?: BookingsListRelationFilter
  }, "id" | "public_id">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrderInput | SortOrder
    receipt_url?: SortOrderInput | SortOrder
    is_confirmed?: SortOrder
    confirmed_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    public_id?: SortOrder
    status?: SortOrder
    enc_phone?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"payments"> | number
    invoice_id?: IntWithAggregatesFilter<"payments"> | number
    amount?: FloatWithAggregatesFilter<"payments"> | number
    payment_date?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    payment_method?: Enumpayments_payment_methodWithAggregatesFilter<"payments"> | $Enums.payments_payment_method
    transaction_id?: StringNullableWithAggregatesFilter<"payments"> | string | null
    receipt_url?: StringNullableWithAggregatesFilter<"payments"> | string | null
    is_confirmed?: BoolWithAggregatesFilter<"payments"> | boolean
    confirmed_at?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    public_id?: StringWithAggregatesFilter<"payments"> | string
    status?: Enumshared_statusWithAggregatesFilter<"payments"> | $Enums.shared_status
    enc_phone?: StringNullableWithAggregatesFilter<"payments"> | string | null
    phone?: StringNullableWithAggregatesFilter<"payments"> | string | null
  }

  export type permissionsWhereInput = {
    AND?: permissionsWhereInput | permissionsWhereInput[]
    OR?: permissionsWhereInput[]
    NOT?: permissionsWhereInput | permissionsWhereInput[]
    id?: IntFilter<"permissions"> | number
    role?: Enumusers_roleFilter<"permissions"> | $Enums.users_role
    user_id?: IntFilter<"permissions"> | number
    tbl?: StringFilter<"permissions"> | string
    rec?: IntFilter<"permissions"> | number
    general?: IntFilter<"permissions"> | number
    create?: IntFilter<"permissions"> | number
    read?: IntFilter<"permissions"> | number
    update?: IntFilter<"permissions"> | number
    delete?: IntFilter<"permissions"> | number
    custom_action?: StringNullableFilter<"permissions"> | string | null
    added_by?: IntFilter<"permissions"> | number
    created_at?: DateTimeFilter<"permissions"> | Date | string
    updated_at?: DateTimeNullableFilter<"permissions"> | Date | string | null
    status?: Enumshared_statusFilter<"permissions"> | $Enums.shared_status
    deleted_at?: DateTimeNullableFilter<"permissions"> | Date | string | null
  }

  export type permissionsOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    user_id?: SortOrder
    tbl?: SortOrder
    rec?: SortOrder
    general?: SortOrder
    create?: SortOrder
    read?: SortOrder
    update?: SortOrder
    delete?: SortOrder
    custom_action?: SortOrderInput | SortOrder
    added_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _relevance?: permissionsOrderByRelevanceInput
  }

  export type permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: permissionsWhereInput | permissionsWhereInput[]
    OR?: permissionsWhereInput[]
    NOT?: permissionsWhereInput | permissionsWhereInput[]
    role?: Enumusers_roleFilter<"permissions"> | $Enums.users_role
    user_id?: IntFilter<"permissions"> | number
    tbl?: StringFilter<"permissions"> | string
    rec?: IntFilter<"permissions"> | number
    general?: IntFilter<"permissions"> | number
    create?: IntFilter<"permissions"> | number
    read?: IntFilter<"permissions"> | number
    update?: IntFilter<"permissions"> | number
    delete?: IntFilter<"permissions"> | number
    custom_action?: StringNullableFilter<"permissions"> | string | null
    added_by?: IntFilter<"permissions"> | number
    created_at?: DateTimeFilter<"permissions"> | Date | string
    updated_at?: DateTimeNullableFilter<"permissions"> | Date | string | null
    status?: Enumshared_statusFilter<"permissions"> | $Enums.shared_status
    deleted_at?: DateTimeNullableFilter<"permissions"> | Date | string | null
  }, "id">

  export type permissionsOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    user_id?: SortOrder
    tbl?: SortOrder
    rec?: SortOrder
    general?: SortOrder
    create?: SortOrder
    read?: SortOrder
    update?: SortOrder
    delete?: SortOrder
    custom_action?: SortOrderInput | SortOrder
    added_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: permissionsCountOrderByAggregateInput
    _avg?: permissionsAvgOrderByAggregateInput
    _max?: permissionsMaxOrderByAggregateInput
    _min?: permissionsMinOrderByAggregateInput
    _sum?: permissionsSumOrderByAggregateInput
  }

  export type permissionsScalarWhereWithAggregatesInput = {
    AND?: permissionsScalarWhereWithAggregatesInput | permissionsScalarWhereWithAggregatesInput[]
    OR?: permissionsScalarWhereWithAggregatesInput[]
    NOT?: permissionsScalarWhereWithAggregatesInput | permissionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"permissions"> | number
    role?: Enumusers_roleWithAggregatesFilter<"permissions"> | $Enums.users_role
    user_id?: IntWithAggregatesFilter<"permissions"> | number
    tbl?: StringWithAggregatesFilter<"permissions"> | string
    rec?: IntWithAggregatesFilter<"permissions"> | number
    general?: IntWithAggregatesFilter<"permissions"> | number
    create?: IntWithAggregatesFilter<"permissions"> | number
    read?: IntWithAggregatesFilter<"permissions"> | number
    update?: IntWithAggregatesFilter<"permissions"> | number
    delete?: IntWithAggregatesFilter<"permissions"> | number
    custom_action?: StringNullableWithAggregatesFilter<"permissions"> | string | null
    added_by?: IntWithAggregatesFilter<"permissions"> | number
    created_at?: DateTimeWithAggregatesFilter<"permissions"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"permissions"> | Date | string | null
    status?: Enumshared_statusWithAggregatesFilter<"permissions"> | $Enums.shared_status
    deleted_at?: DateTimeNullableWithAggregatesFilter<"permissions"> | Date | string | null
  }

  export type quotesWhereInput = {
    AND?: quotesWhereInput | quotesWhereInput[]
    OR?: quotesWhereInput[]
    NOT?: quotesWhereInput | quotesWhereInput[]
    id?: IntFilter<"quotes"> | number
    rate_card_id?: IntFilter<"quotes"> | number
    client_id?: IntFilter<"quotes"> | number
    status?: Enumquotes_statusFilter<"quotes"> | $Enums.quotes_status
    expiration_date?: DateTimeFilter<"quotes"> | Date | string
    created_at?: DateTimeFilter<"quotes"> | Date | string
    updated_at?: DateTimeNullableFilter<"quotes"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"quotes"> | Date | string | null
    public_id?: StringFilter<"quotes"> | string
    booking?: XOR<BookingsNullableScalarRelationFilter, bookingsWhereInput> | null
    invoice?: XOR<InvoicesNullableScalarRelationFilter, invoicesWhereInput> | null
    client?: XOR<ClientsScalarRelationFilter, clientsWhereInput>
    rate_card?: XOR<Rate_cardsScalarRelationFilter, rate_cardsWhereInput>
  }

  export type quotesOrderByWithRelationInput = {
    id?: SortOrder
    rate_card_id?: SortOrder
    client_id?: SortOrder
    status?: SortOrder
    expiration_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    public_id?: SortOrder
    booking?: bookingsOrderByWithRelationInput
    invoice?: invoicesOrderByWithRelationInput
    client?: clientsOrderByWithRelationInput
    rate_card?: rate_cardsOrderByWithRelationInput
    _relevance?: quotesOrderByRelevanceInput
  }

  export type quotesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    public_id?: string
    AND?: quotesWhereInput | quotesWhereInput[]
    OR?: quotesWhereInput[]
    NOT?: quotesWhereInput | quotesWhereInput[]
    rate_card_id?: IntFilter<"quotes"> | number
    client_id?: IntFilter<"quotes"> | number
    status?: Enumquotes_statusFilter<"quotes"> | $Enums.quotes_status
    expiration_date?: DateTimeFilter<"quotes"> | Date | string
    created_at?: DateTimeFilter<"quotes"> | Date | string
    updated_at?: DateTimeNullableFilter<"quotes"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"quotes"> | Date | string | null
    booking?: XOR<BookingsNullableScalarRelationFilter, bookingsWhereInput> | null
    invoice?: XOR<InvoicesNullableScalarRelationFilter, invoicesWhereInput> | null
    client?: XOR<ClientsScalarRelationFilter, clientsWhereInput>
    rate_card?: XOR<Rate_cardsScalarRelationFilter, rate_cardsWhereInput>
  }, "id" | "public_id">

  export type quotesOrderByWithAggregationInput = {
    id?: SortOrder
    rate_card_id?: SortOrder
    client_id?: SortOrder
    status?: SortOrder
    expiration_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    public_id?: SortOrder
    _count?: quotesCountOrderByAggregateInput
    _avg?: quotesAvgOrderByAggregateInput
    _max?: quotesMaxOrderByAggregateInput
    _min?: quotesMinOrderByAggregateInput
    _sum?: quotesSumOrderByAggregateInput
  }

  export type quotesScalarWhereWithAggregatesInput = {
    AND?: quotesScalarWhereWithAggregatesInput | quotesScalarWhereWithAggregatesInput[]
    OR?: quotesScalarWhereWithAggregatesInput[]
    NOT?: quotesScalarWhereWithAggregatesInput | quotesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"quotes"> | number
    rate_card_id?: IntWithAggregatesFilter<"quotes"> | number
    client_id?: IntWithAggregatesFilter<"quotes"> | number
    status?: Enumquotes_statusWithAggregatesFilter<"quotes"> | $Enums.quotes_status
    expiration_date?: DateTimeWithAggregatesFilter<"quotes"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"quotes"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"quotes"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"quotes"> | Date | string | null
    public_id?: StringWithAggregatesFilter<"quotes"> | string
  }

  export type rack_ratesWhereInput = {
    AND?: rack_ratesWhereInput | rack_ratesWhereInput[]
    OR?: rack_ratesWhereInput[]
    NOT?: rack_ratesWhereInput | rack_ratesWhereInput[]
    id?: IntFilter<"rack_rates"> | number
    rate?: FloatFilter<"rack_rates"> | number
    currency?: StringFilter<"rack_rates"> | string
    travel_period?: Enumrack_rates_travel_periodFilter<"rack_rates"> | $Enums.rack_rates_travel_period
    meal_plan?: Enumrack_rates_meal_planFilter<"rack_rates"> | $Enums.rack_rates_meal_plan
    room_category?: Enumrack_rates_room_categoryFilter<"rack_rates"> | $Enums.rack_rates_room_category
    pdf_url?: StringNullableFilter<"rack_rates"> | string | null
    isProcessed?: BoolFilter<"rack_rates"> | boolean
    processed_date?: DateTimeNullableFilter<"rack_rates"> | Date | string | null
    hotel_id?: IntFilter<"rack_rates"> | number
    created_at?: DateTimeFilter<"rack_rates"> | Date | string
    updated_at?: DateTimeNullableFilter<"rack_rates"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"rack_rates"> | Date | string | null
    public_id?: StringFilter<"rack_rates"> | string
    status?: Enumshared_statusFilter<"rack_rates"> | $Enums.shared_status
    hotel?: XOR<HotelsScalarRelationFilter, hotelsWhereInput>
    rate_cards?: Rate_cardsListRelationFilter
  }

  export type rack_ratesOrderByWithRelationInput = {
    id?: SortOrder
    rate?: SortOrder
    currency?: SortOrder
    travel_period?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    pdf_url?: SortOrderInput | SortOrder
    isProcessed?: SortOrder
    processed_date?: SortOrderInput | SortOrder
    hotel_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    public_id?: SortOrder
    status?: SortOrder
    hotel?: hotelsOrderByWithRelationInput
    rate_cards?: rate_cardsOrderByRelationAggregateInput
    _relevance?: rack_ratesOrderByRelevanceInput
  }

  export type rack_ratesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    public_id?: string
    AND?: rack_ratesWhereInput | rack_ratesWhereInput[]
    OR?: rack_ratesWhereInput[]
    NOT?: rack_ratesWhereInput | rack_ratesWhereInput[]
    rate?: FloatFilter<"rack_rates"> | number
    currency?: StringFilter<"rack_rates"> | string
    travel_period?: Enumrack_rates_travel_periodFilter<"rack_rates"> | $Enums.rack_rates_travel_period
    meal_plan?: Enumrack_rates_meal_planFilter<"rack_rates"> | $Enums.rack_rates_meal_plan
    room_category?: Enumrack_rates_room_categoryFilter<"rack_rates"> | $Enums.rack_rates_room_category
    pdf_url?: StringNullableFilter<"rack_rates"> | string | null
    isProcessed?: BoolFilter<"rack_rates"> | boolean
    processed_date?: DateTimeNullableFilter<"rack_rates"> | Date | string | null
    hotel_id?: IntFilter<"rack_rates"> | number
    created_at?: DateTimeFilter<"rack_rates"> | Date | string
    updated_at?: DateTimeNullableFilter<"rack_rates"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"rack_rates"> | Date | string | null
    status?: Enumshared_statusFilter<"rack_rates"> | $Enums.shared_status
    hotel?: XOR<HotelsScalarRelationFilter, hotelsWhereInput>
    rate_cards?: Rate_cardsListRelationFilter
  }, "id" | "public_id">

  export type rack_ratesOrderByWithAggregationInput = {
    id?: SortOrder
    rate?: SortOrder
    currency?: SortOrder
    travel_period?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    pdf_url?: SortOrderInput | SortOrder
    isProcessed?: SortOrder
    processed_date?: SortOrderInput | SortOrder
    hotel_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    public_id?: SortOrder
    status?: SortOrder
    _count?: rack_ratesCountOrderByAggregateInput
    _avg?: rack_ratesAvgOrderByAggregateInput
    _max?: rack_ratesMaxOrderByAggregateInput
    _min?: rack_ratesMinOrderByAggregateInput
    _sum?: rack_ratesSumOrderByAggregateInput
  }

  export type rack_ratesScalarWhereWithAggregatesInput = {
    AND?: rack_ratesScalarWhereWithAggregatesInput | rack_ratesScalarWhereWithAggregatesInput[]
    OR?: rack_ratesScalarWhereWithAggregatesInput[]
    NOT?: rack_ratesScalarWhereWithAggregatesInput | rack_ratesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"rack_rates"> | number
    rate?: FloatWithAggregatesFilter<"rack_rates"> | number
    currency?: StringWithAggregatesFilter<"rack_rates"> | string
    travel_period?: Enumrack_rates_travel_periodWithAggregatesFilter<"rack_rates"> | $Enums.rack_rates_travel_period
    meal_plan?: Enumrack_rates_meal_planWithAggregatesFilter<"rack_rates"> | $Enums.rack_rates_meal_plan
    room_category?: Enumrack_rates_room_categoryWithAggregatesFilter<"rack_rates"> | $Enums.rack_rates_room_category
    pdf_url?: StringNullableWithAggregatesFilter<"rack_rates"> | string | null
    isProcessed?: BoolWithAggregatesFilter<"rack_rates"> | boolean
    processed_date?: DateTimeNullableWithAggregatesFilter<"rack_rates"> | Date | string | null
    hotel_id?: IntWithAggregatesFilter<"rack_rates"> | number
    created_at?: DateTimeWithAggregatesFilter<"rack_rates"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"rack_rates"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"rack_rates"> | Date | string | null
    public_id?: StringWithAggregatesFilter<"rack_rates"> | string
    status?: Enumshared_statusWithAggregatesFilter<"rack_rates"> | $Enums.shared_status
  }

  export type rate_cardsWhereInput = {
    AND?: rate_cardsWhereInput | rate_cardsWhereInput[]
    OR?: rate_cardsWhereInput[]
    NOT?: rate_cardsWhereInput | rate_cardsWhereInput[]
    id?: IntFilter<"rate_cards"> | number
    name?: StringFilter<"rate_cards"> | string
    base_rate?: FloatFilter<"rate_cards"> | number
    commission_rate?: FloatNullableFilter<"rate_cards"> | number | null
    markup_rate?: FloatNullableFilter<"rate_cards"> | number | null
    discount_amount?: FloatNullableFilter<"rate_cards"> | number | null
    discount_percent?: FloatNullableFilter<"rate_cards"> | number | null
    final_rate?: FloatFilter<"rate_cards"> | number
    currency?: StringFilter<"rate_cards"> | string
    travel_period?: Enumrate_cards_travel_periodFilter<"rate_cards"> | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFilter<"rate_cards"> | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFilter<"rate_cards"> | $Enums.rate_cards_room_category
    commission?: FloatNullableFilter<"rate_cards"> | number | null
    is_active?: BoolFilter<"rate_cards"> | boolean
    rack_rate_id?: IntFilter<"rate_cards"> | number
    hotel_id?: IntFilter<"rate_cards"> | number
    created_at?: DateTimeFilter<"rate_cards"> | Date | string
    updated_at?: DateTimeNullableFilter<"rate_cards"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"rate_cards"> | Date | string | null
    created_by?: IntFilter<"rate_cards"> | number
    public_id?: StringFilter<"rate_cards"> | string
    status?: Enumshared_statusFilter<"rate_cards"> | $Enums.shared_status
    quotes?: QuotesListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    hotels?: XOR<HotelsScalarRelationFilter, hotelsWhereInput>
    rack_rates?: XOR<Rack_ratesScalarRelationFilter, rack_ratesWhereInput>
  }

  export type rate_cardsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    base_rate?: SortOrder
    commission_rate?: SortOrderInput | SortOrder
    markup_rate?: SortOrderInput | SortOrder
    discount_amount?: SortOrderInput | SortOrder
    discount_percent?: SortOrderInput | SortOrder
    final_rate?: SortOrder
    currency?: SortOrder
    travel_period?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    commission?: SortOrderInput | SortOrder
    is_active?: SortOrder
    rack_rate_id?: SortOrder
    hotel_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_by?: SortOrder
    public_id?: SortOrder
    status?: SortOrder
    quotes?: quotesOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    hotels?: hotelsOrderByWithRelationInput
    rack_rates?: rack_ratesOrderByWithRelationInput
    _relevance?: rate_cardsOrderByRelevanceInput
  }

  export type rate_cardsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    public_id?: string
    AND?: rate_cardsWhereInput | rate_cardsWhereInput[]
    OR?: rate_cardsWhereInput[]
    NOT?: rate_cardsWhereInput | rate_cardsWhereInput[]
    name?: StringFilter<"rate_cards"> | string
    base_rate?: FloatFilter<"rate_cards"> | number
    commission_rate?: FloatNullableFilter<"rate_cards"> | number | null
    markup_rate?: FloatNullableFilter<"rate_cards"> | number | null
    discount_amount?: FloatNullableFilter<"rate_cards"> | number | null
    discount_percent?: FloatNullableFilter<"rate_cards"> | number | null
    final_rate?: FloatFilter<"rate_cards"> | number
    currency?: StringFilter<"rate_cards"> | string
    travel_period?: Enumrate_cards_travel_periodFilter<"rate_cards"> | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFilter<"rate_cards"> | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFilter<"rate_cards"> | $Enums.rate_cards_room_category
    commission?: FloatNullableFilter<"rate_cards"> | number | null
    is_active?: BoolFilter<"rate_cards"> | boolean
    rack_rate_id?: IntFilter<"rate_cards"> | number
    hotel_id?: IntFilter<"rate_cards"> | number
    created_at?: DateTimeFilter<"rate_cards"> | Date | string
    updated_at?: DateTimeNullableFilter<"rate_cards"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"rate_cards"> | Date | string | null
    created_by?: IntFilter<"rate_cards"> | number
    status?: Enumshared_statusFilter<"rate_cards"> | $Enums.shared_status
    quotes?: QuotesListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    hotels?: XOR<HotelsScalarRelationFilter, hotelsWhereInput>
    rack_rates?: XOR<Rack_ratesScalarRelationFilter, rack_ratesWhereInput>
  }, "id" | "public_id">

  export type rate_cardsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    base_rate?: SortOrder
    commission_rate?: SortOrderInput | SortOrder
    markup_rate?: SortOrderInput | SortOrder
    discount_amount?: SortOrderInput | SortOrder
    discount_percent?: SortOrderInput | SortOrder
    final_rate?: SortOrder
    currency?: SortOrder
    travel_period?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    commission?: SortOrderInput | SortOrder
    is_active?: SortOrder
    rack_rate_id?: SortOrder
    hotel_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_by?: SortOrder
    public_id?: SortOrder
    status?: SortOrder
    _count?: rate_cardsCountOrderByAggregateInput
    _avg?: rate_cardsAvgOrderByAggregateInput
    _max?: rate_cardsMaxOrderByAggregateInput
    _min?: rate_cardsMinOrderByAggregateInput
    _sum?: rate_cardsSumOrderByAggregateInput
  }

  export type rate_cardsScalarWhereWithAggregatesInput = {
    AND?: rate_cardsScalarWhereWithAggregatesInput | rate_cardsScalarWhereWithAggregatesInput[]
    OR?: rate_cardsScalarWhereWithAggregatesInput[]
    NOT?: rate_cardsScalarWhereWithAggregatesInput | rate_cardsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"rate_cards"> | number
    name?: StringWithAggregatesFilter<"rate_cards"> | string
    base_rate?: FloatWithAggregatesFilter<"rate_cards"> | number
    commission_rate?: FloatNullableWithAggregatesFilter<"rate_cards"> | number | null
    markup_rate?: FloatNullableWithAggregatesFilter<"rate_cards"> | number | null
    discount_amount?: FloatNullableWithAggregatesFilter<"rate_cards"> | number | null
    discount_percent?: FloatNullableWithAggregatesFilter<"rate_cards"> | number | null
    final_rate?: FloatWithAggregatesFilter<"rate_cards"> | number
    currency?: StringWithAggregatesFilter<"rate_cards"> | string
    travel_period?: Enumrate_cards_travel_periodWithAggregatesFilter<"rate_cards"> | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planWithAggregatesFilter<"rate_cards"> | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryWithAggregatesFilter<"rate_cards"> | $Enums.rate_cards_room_category
    commission?: FloatNullableWithAggregatesFilter<"rate_cards"> | number | null
    is_active?: BoolWithAggregatesFilter<"rate_cards"> | boolean
    rack_rate_id?: IntWithAggregatesFilter<"rate_cards"> | number
    hotel_id?: IntWithAggregatesFilter<"rate_cards"> | number
    created_at?: DateTimeWithAggregatesFilter<"rate_cards"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"rate_cards"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"rate_cards"> | Date | string | null
    created_by?: IntWithAggregatesFilter<"rate_cards"> | number
    public_id?: StringWithAggregatesFilter<"rate_cards"> | string
    status?: Enumshared_statusWithAggregatesFilter<"rate_cards"> | $Enums.shared_status
  }

  export type remindersWhereInput = {
    AND?: remindersWhereInput | remindersWhereInput[]
    OR?: remindersWhereInput[]
    NOT?: remindersWhereInput | remindersWhereInput[]
    id?: IntFilter<"reminders"> | number
    invoice_id?: IntFilter<"reminders"> | number
    reminder_date?: DateTimeFilter<"reminders"> | Date | string
    message?: StringFilter<"reminders"> | string
    is_sent?: BoolFilter<"reminders"> | boolean
    sent_at?: DateTimeNullableFilter<"reminders"> | Date | string | null
    created_at?: DateTimeFilter<"reminders"> | Date | string
    updated_at?: DateTimeNullableFilter<"reminders"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"reminders"> | Date | string | null
    status?: Enumshared_statusFilter<"reminders"> | $Enums.shared_status
    invoices?: XOR<InvoicesScalarRelationFilter, invoicesWhereInput>
  }

  export type remindersOrderByWithRelationInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    reminder_date?: SortOrder
    message?: SortOrder
    is_sent?: SortOrder
    sent_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    invoices?: invoicesOrderByWithRelationInput
    _relevance?: remindersOrderByRelevanceInput
  }

  export type remindersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: remindersWhereInput | remindersWhereInput[]
    OR?: remindersWhereInput[]
    NOT?: remindersWhereInput | remindersWhereInput[]
    invoice_id?: IntFilter<"reminders"> | number
    reminder_date?: DateTimeFilter<"reminders"> | Date | string
    message?: StringFilter<"reminders"> | string
    is_sent?: BoolFilter<"reminders"> | boolean
    sent_at?: DateTimeNullableFilter<"reminders"> | Date | string | null
    created_at?: DateTimeFilter<"reminders"> | Date | string
    updated_at?: DateTimeNullableFilter<"reminders"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"reminders"> | Date | string | null
    status?: Enumshared_statusFilter<"reminders"> | $Enums.shared_status
    invoices?: XOR<InvoicesScalarRelationFilter, invoicesWhereInput>
  }, "id">

  export type remindersOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    reminder_date?: SortOrder
    message?: SortOrder
    is_sent?: SortOrder
    sent_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: remindersCountOrderByAggregateInput
    _avg?: remindersAvgOrderByAggregateInput
    _max?: remindersMaxOrderByAggregateInput
    _min?: remindersMinOrderByAggregateInput
    _sum?: remindersSumOrderByAggregateInput
  }

  export type remindersScalarWhereWithAggregatesInput = {
    AND?: remindersScalarWhereWithAggregatesInput | remindersScalarWhereWithAggregatesInput[]
    OR?: remindersScalarWhereWithAggregatesInput[]
    NOT?: remindersScalarWhereWithAggregatesInput | remindersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"reminders"> | number
    invoice_id?: IntWithAggregatesFilter<"reminders"> | number
    reminder_date?: DateTimeWithAggregatesFilter<"reminders"> | Date | string
    message?: StringWithAggregatesFilter<"reminders"> | string
    is_sent?: BoolWithAggregatesFilter<"reminders"> | boolean
    sent_at?: DateTimeNullableWithAggregatesFilter<"reminders"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"reminders"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"reminders"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"reminders"> | Date | string | null
    status?: Enumshared_statusWithAggregatesFilter<"reminders"> | $Enums.shared_status
  }

  export type seasonsWhereInput = {
    AND?: seasonsWhereInput | seasonsWhereInput[]
    OR?: seasonsWhereInput[]
    NOT?: seasonsWhereInput | seasonsWhereInput[]
    id?: IntFilter<"seasons"> | number
    name?: StringFilter<"seasons"> | string
    period_type?: Enumseasons_period_typeFilter<"seasons"> | $Enums.seasons_period_type
    start_date?: DateTimeFilter<"seasons"> | Date | string
    end_date?: DateTimeFilter<"seasons"> | Date | string
    hotel_policy_id?: IntFilter<"seasons"> | number
    created_at?: DateTimeFilter<"seasons"> | Date | string
    deleted_at?: DateTimeNullableFilter<"seasons"> | Date | string | null
    status?: Enumshared_statusFilter<"seasons"> | $Enums.shared_status
    updated_at?: DateTimeNullableFilter<"seasons"> | Date | string | null
    hotel_policies?: XOR<Hotel_policiesScalarRelationFilter, hotel_policiesWhereInput>
  }

  export type seasonsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    period_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    hotel_policy_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    hotel_policies?: hotel_policiesOrderByWithRelationInput
    _relevance?: seasonsOrderByRelevanceInput
  }

  export type seasonsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: seasonsWhereInput | seasonsWhereInput[]
    OR?: seasonsWhereInput[]
    NOT?: seasonsWhereInput | seasonsWhereInput[]
    name?: StringFilter<"seasons"> | string
    period_type?: Enumseasons_period_typeFilter<"seasons"> | $Enums.seasons_period_type
    start_date?: DateTimeFilter<"seasons"> | Date | string
    end_date?: DateTimeFilter<"seasons"> | Date | string
    hotel_policy_id?: IntFilter<"seasons"> | number
    created_at?: DateTimeFilter<"seasons"> | Date | string
    deleted_at?: DateTimeNullableFilter<"seasons"> | Date | string | null
    status?: Enumshared_statusFilter<"seasons"> | $Enums.shared_status
    updated_at?: DateTimeNullableFilter<"seasons"> | Date | string | null
    hotel_policies?: XOR<Hotel_policiesScalarRelationFilter, hotel_policiesWhereInput>
  }, "id">

  export type seasonsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    period_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    hotel_policy_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: seasonsCountOrderByAggregateInput
    _avg?: seasonsAvgOrderByAggregateInput
    _max?: seasonsMaxOrderByAggregateInput
    _min?: seasonsMinOrderByAggregateInput
    _sum?: seasonsSumOrderByAggregateInput
  }

  export type seasonsScalarWhereWithAggregatesInput = {
    AND?: seasonsScalarWhereWithAggregatesInput | seasonsScalarWhereWithAggregatesInput[]
    OR?: seasonsScalarWhereWithAggregatesInput[]
    NOT?: seasonsScalarWhereWithAggregatesInput | seasonsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"seasons"> | number
    name?: StringWithAggregatesFilter<"seasons"> | string
    period_type?: Enumseasons_period_typeWithAggregatesFilter<"seasons"> | $Enums.seasons_period_type
    start_date?: DateTimeWithAggregatesFilter<"seasons"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"seasons"> | Date | string
    hotel_policy_id?: IntWithAggregatesFilter<"seasons"> | number
    created_at?: DateTimeWithAggregatesFilter<"seasons"> | Date | string
    deleted_at?: DateTimeNullableWithAggregatesFilter<"seasons"> | Date | string | null
    status?: Enumshared_statusWithAggregatesFilter<"seasons"> | $Enums.shared_status
    updated_at?: DateTimeNullableWithAggregatesFilter<"seasons"> | Date | string | null
  }

  export type sessionsWhereInput = {
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    id?: IntFilter<"sessions"> | number
    session_token?: StringFilter<"sessions"> | string
    user_id?: IntFilter<"sessions"> | number
    created_at?: DateTimeFilter<"sessions"> | Date | string
    updated_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    status?: Enumshared_statusFilter<"sessions"> | $Enums.shared_status
    deleted_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    expires_at?: DateTimeFilter<"sessions"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type sessionsOrderByWithRelationInput = {
    id?: SortOrder
    session_token?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    expires_at?: SortOrder
    users?: usersOrderByWithRelationInput
    _relevance?: sessionsOrderByRelevanceInput
  }

  export type sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    session_token?: string
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    user_id?: IntFilter<"sessions"> | number
    created_at?: DateTimeFilter<"sessions"> | Date | string
    updated_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    status?: Enumshared_statusFilter<"sessions"> | $Enums.shared_status
    deleted_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    expires_at?: DateTimeFilter<"sessions"> | Date | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "session_token">

  export type sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    session_token?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    expires_at?: SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _avg?: sessionsAvgOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
    _sum?: sessionsSumOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    OR?: sessionsScalarWhereWithAggregatesInput[]
    NOT?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"sessions"> | number
    session_token?: StringWithAggregatesFilter<"sessions"> | string
    user_id?: IntWithAggregatesFilter<"sessions"> | number
    created_at?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"sessions"> | Date | string | null
    status?: Enumshared_statusWithAggregatesFilter<"sessions"> | $Enums.shared_status
    deleted_at?: DateTimeNullableWithAggregatesFilter<"sessions"> | Date | string | null
    expires_at?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
  }

  export type transportationWhereInput = {
    AND?: transportationWhereInput | transportationWhereInput[]
    OR?: transportationWhereInput[]
    NOT?: transportationWhereInput | transportationWhereInput[]
    id?: IntFilter<"transportation"> | number
    type?: Enumtransportation_typeFilter<"transportation"> | $Enums.transportation_type
    provider?: StringFilter<"transportation"> | string
    booking_ref?: StringNullableFilter<"transportation"> | string | null
    departure_date?: DateTimeFilter<"transportation"> | Date | string
    return_date?: DateTimeNullableFilter<"transportation"> | Date | string | null
    departure_point?: StringFilter<"transportation"> | string
    arrival_point?: StringFilter<"transportation"> | string
    cost?: FloatFilter<"transportation"> | number
    booking_id?: IntFilter<"transportation"> | number
    status?: Enumtransportation_statusFilter<"transportation"> | $Enums.transportation_status
    created_at?: DateTimeFilter<"transportation"> | Date | string
    updated_at?: DateTimeNullableFilter<"transportation"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"transportation"> | Date | string | null
    bookings?: XOR<BookingsScalarRelationFilter, bookingsWhereInput>
  }

  export type transportationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    booking_ref?: SortOrderInput | SortOrder
    departure_date?: SortOrder
    return_date?: SortOrderInput | SortOrder
    departure_point?: SortOrder
    arrival_point?: SortOrder
    cost?: SortOrder
    booking_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    bookings?: bookingsOrderByWithRelationInput
    _relevance?: transportationOrderByRelevanceInput
  }

  export type transportationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: transportationWhereInput | transportationWhereInput[]
    OR?: transportationWhereInput[]
    NOT?: transportationWhereInput | transportationWhereInput[]
    type?: Enumtransportation_typeFilter<"transportation"> | $Enums.transportation_type
    provider?: StringFilter<"transportation"> | string
    booking_ref?: StringNullableFilter<"transportation"> | string | null
    departure_date?: DateTimeFilter<"transportation"> | Date | string
    return_date?: DateTimeNullableFilter<"transportation"> | Date | string | null
    departure_point?: StringFilter<"transportation"> | string
    arrival_point?: StringFilter<"transportation"> | string
    cost?: FloatFilter<"transportation"> | number
    booking_id?: IntFilter<"transportation"> | number
    status?: Enumtransportation_statusFilter<"transportation"> | $Enums.transportation_status
    created_at?: DateTimeFilter<"transportation"> | Date | string
    updated_at?: DateTimeNullableFilter<"transportation"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"transportation"> | Date | string | null
    bookings?: XOR<BookingsScalarRelationFilter, bookingsWhereInput>
  }, "id">

  export type transportationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    booking_ref?: SortOrderInput | SortOrder
    departure_date?: SortOrder
    return_date?: SortOrderInput | SortOrder
    departure_point?: SortOrder
    arrival_point?: SortOrder
    cost?: SortOrder
    booking_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: transportationCountOrderByAggregateInput
    _avg?: transportationAvgOrderByAggregateInput
    _max?: transportationMaxOrderByAggregateInput
    _min?: transportationMinOrderByAggregateInput
    _sum?: transportationSumOrderByAggregateInput
  }

  export type transportationScalarWhereWithAggregatesInput = {
    AND?: transportationScalarWhereWithAggregatesInput | transportationScalarWhereWithAggregatesInput[]
    OR?: transportationScalarWhereWithAggregatesInput[]
    NOT?: transportationScalarWhereWithAggregatesInput | transportationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"transportation"> | number
    type?: Enumtransportation_typeWithAggregatesFilter<"transportation"> | $Enums.transportation_type
    provider?: StringWithAggregatesFilter<"transportation"> | string
    booking_ref?: StringNullableWithAggregatesFilter<"transportation"> | string | null
    departure_date?: DateTimeWithAggregatesFilter<"transportation"> | Date | string
    return_date?: DateTimeNullableWithAggregatesFilter<"transportation"> | Date | string | null
    departure_point?: StringWithAggregatesFilter<"transportation"> | string
    arrival_point?: StringWithAggregatesFilter<"transportation"> | string
    cost?: FloatWithAggregatesFilter<"transportation"> | number
    booking_id?: IntWithAggregatesFilter<"transportation"> | number
    status?: Enumtransportation_statusWithAggregatesFilter<"transportation"> | $Enums.transportation_status
    created_at?: DateTimeWithAggregatesFilter<"transportation"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"transportation"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"transportation"> | Date | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    name?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    email_verified?: DateTimeNullableFilter<"users"> | Date | string | null
    password?: StringFilter<"users"> | string
    role?: Enumusers_roleFilter<"users"> | $Enums.users_role
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    status?: Enumusers_statusFilter<"users"> | $Enums.users_status
    deleted_at?: DateTimeNullableFilter<"users"> | Date | string | null
    public_id?: StringFilter<"users"> | string
    password_expiry?: DateTimeFilter<"users"> | Date | string
    two_factor_enabled?: BoolFilter<"users"> | boolean
    national_id?: StringNullableFilter<"users"> | string | null
    phone?: StringNullableFilter<"users"> | string | null
    branch_id?: IntNullableFilter<"users"> | number | null
    image?: StringNullableFilter<"users"> | string | null
    accounts?: AccountsListRelationFilter
    bookings?: BookingsListRelationFilter
    cancellations?: CancellationsListRelationFilter
    events?: Events_logListRelationFilter
    notifications?: NotificationsListRelationFilter
    rate_cards?: Rate_cardsListRelationFilter
    sessions?: SessionsListRelationFilter
    branch?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    users_branches?: Users_branchesListRelationFilter
    invoices?: InvoicesListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    public_id?: SortOrder
    password_expiry?: SortOrder
    two_factor_enabled?: SortOrder
    national_id?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    accounts?: accountsOrderByRelationAggregateInput
    bookings?: bookingsOrderByRelationAggregateInput
    cancellations?: cancellationsOrderByRelationAggregateInput
    events?: events_logOrderByRelationAggregateInput
    notifications?: notificationsOrderByRelationAggregateInput
    rate_cards?: rate_cardsOrderByRelationAggregateInput
    sessions?: sessionsOrderByRelationAggregateInput
    branch?: branchesOrderByWithRelationInput
    users_branches?: users_branchesOrderByRelationAggregateInput
    invoices?: invoicesOrderByRelationAggregateInput
    _relevance?: usersOrderByRelevanceInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    public_id?: string
    national_id?: string
    phone?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringFilter<"users"> | string
    email_verified?: DateTimeNullableFilter<"users"> | Date | string | null
    password?: StringFilter<"users"> | string
    role?: Enumusers_roleFilter<"users"> | $Enums.users_role
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    status?: Enumusers_statusFilter<"users"> | $Enums.users_status
    deleted_at?: DateTimeNullableFilter<"users"> | Date | string | null
    password_expiry?: DateTimeFilter<"users"> | Date | string
    two_factor_enabled?: BoolFilter<"users"> | boolean
    branch_id?: IntNullableFilter<"users"> | number | null
    image?: StringNullableFilter<"users"> | string | null
    accounts?: AccountsListRelationFilter
    bookings?: BookingsListRelationFilter
    cancellations?: CancellationsListRelationFilter
    events?: Events_logListRelationFilter
    notifications?: NotificationsListRelationFilter
    rate_cards?: Rate_cardsListRelationFilter
    sessions?: SessionsListRelationFilter
    branch?: XOR<BranchesNullableScalarRelationFilter, branchesWhereInput> | null
    users_branches?: Users_branchesListRelationFilter
    invoices?: InvoicesListRelationFilter
  }, "id" | "email" | "public_id" | "national_id" | "phone">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    public_id?: SortOrder
    password_expiry?: SortOrder
    two_factor_enabled?: SortOrder
    national_id?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    name?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    email_verified?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    password?: StringWithAggregatesFilter<"users"> | string
    role?: Enumusers_roleWithAggregatesFilter<"users"> | $Enums.users_role
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    status?: Enumusers_statusWithAggregatesFilter<"users"> | $Enums.users_status
    deleted_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    public_id?: StringWithAggregatesFilter<"users"> | string
    password_expiry?: DateTimeWithAggregatesFilter<"users"> | Date | string
    two_factor_enabled?: BoolWithAggregatesFilter<"users"> | boolean
    national_id?: StringNullableWithAggregatesFilter<"users"> | string | null
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    branch_id?: IntNullableWithAggregatesFilter<"users"> | number | null
    image?: StringNullableWithAggregatesFilter<"users"> | string | null
  }

  export type branchesWhereInput = {
    AND?: branchesWhereInput | branchesWhereInput[]
    OR?: branchesWhereInput[]
    NOT?: branchesWhereInput | branchesWhereInput[]
    id?: IntFilter<"branches"> | number
    name?: StringFilter<"branches"> | string
    location?: StringFilter<"branches"> | string
    created_at?: DateTimeFilter<"branches"> | Date | string
    updated_at?: DateTimeNullableFilter<"branches"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"branches"> | Date | string | null
    status?: Enumshared_statusFilter<"branches"> | $Enums.shared_status
    clients?: ClientsListRelationFilter
    users?: UsersListRelationFilter
    users_branches?: Users_branchesListRelationFilter
  }

  export type branchesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    clients?: clientsOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
    users_branches?: users_branchesOrderByRelationAggregateInput
    _relevance?: branchesOrderByRelevanceInput
  }

  export type branchesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: branchesWhereInput | branchesWhereInput[]
    OR?: branchesWhereInput[]
    NOT?: branchesWhereInput | branchesWhereInput[]
    location?: StringFilter<"branches"> | string
    created_at?: DateTimeFilter<"branches"> | Date | string
    updated_at?: DateTimeNullableFilter<"branches"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"branches"> | Date | string | null
    status?: Enumshared_statusFilter<"branches"> | $Enums.shared_status
    clients?: ClientsListRelationFilter
    users?: UsersListRelationFilter
    users_branches?: Users_branchesListRelationFilter
  }, "id" | "name">

  export type branchesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: branchesCountOrderByAggregateInput
    _avg?: branchesAvgOrderByAggregateInput
    _max?: branchesMaxOrderByAggregateInput
    _min?: branchesMinOrderByAggregateInput
    _sum?: branchesSumOrderByAggregateInput
  }

  export type branchesScalarWhereWithAggregatesInput = {
    AND?: branchesScalarWhereWithAggregatesInput | branchesScalarWhereWithAggregatesInput[]
    OR?: branchesScalarWhereWithAggregatesInput[]
    NOT?: branchesScalarWhereWithAggregatesInput | branchesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"branches"> | number
    name?: StringWithAggregatesFilter<"branches"> | string
    location?: StringWithAggregatesFilter<"branches"> | string
    created_at?: DateTimeWithAggregatesFilter<"branches"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"branches"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"branches"> | Date | string | null
    status?: Enumshared_statusWithAggregatesFilter<"branches"> | $Enums.shared_status
  }

  export type users_branchesWhereInput = {
    AND?: users_branchesWhereInput | users_branchesWhereInput[]
    OR?: users_branchesWhereInput[]
    NOT?: users_branchesWhereInput | users_branchesWhereInput[]
    id?: IntFilter<"users_branches"> | number
    user_id?: IntFilter<"users_branches"> | number
    branch_id?: IntFilter<"users_branches"> | number
    created_at?: DateTimeFilter<"users_branches"> | Date | string
    updated_at?: DateTimeNullableFilter<"users_branches"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"users_branches"> | Date | string | null
    status?: Enumshared_statusFilter<"users_branches"> | $Enums.shared_status
    branch?: XOR<BranchesScalarRelationFilter, branchesWhereInput>
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type users_branchesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    branch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    branch?: branchesOrderByWithRelationInput
    user?: usersOrderByWithRelationInput
  }

  export type users_branchesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: users_branchesWhereInput | users_branchesWhereInput[]
    OR?: users_branchesWhereInput[]
    NOT?: users_branchesWhereInput | users_branchesWhereInput[]
    user_id?: IntFilter<"users_branches"> | number
    branch_id?: IntFilter<"users_branches"> | number
    created_at?: DateTimeFilter<"users_branches"> | Date | string
    updated_at?: DateTimeNullableFilter<"users_branches"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"users_branches"> | Date | string | null
    status?: Enumshared_statusFilter<"users_branches"> | $Enums.shared_status
    branch?: XOR<BranchesScalarRelationFilter, branchesWhereInput>
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type users_branchesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    branch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: users_branchesCountOrderByAggregateInput
    _avg?: users_branchesAvgOrderByAggregateInput
    _max?: users_branchesMaxOrderByAggregateInput
    _min?: users_branchesMinOrderByAggregateInput
    _sum?: users_branchesSumOrderByAggregateInput
  }

  export type users_branchesScalarWhereWithAggregatesInput = {
    AND?: users_branchesScalarWhereWithAggregatesInput | users_branchesScalarWhereWithAggregatesInput[]
    OR?: users_branchesScalarWhereWithAggregatesInput[]
    NOT?: users_branchesScalarWhereWithAggregatesInput | users_branchesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users_branches"> | number
    user_id?: IntWithAggregatesFilter<"users_branches"> | number
    branch_id?: IntWithAggregatesFilter<"users_branches"> | number
    created_at?: DateTimeWithAggregatesFilter<"users_branches"> | Date | string
    updated_at?: DateTimeNullableWithAggregatesFilter<"users_branches"> | Date | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"users_branches"> | Date | string | null
    status?: Enumshared_statusWithAggregatesFilter<"users_branches"> | $Enums.shared_status
  }

  export type events_logWhereInput = {
    AND?: events_logWhereInput | events_logWhereInput[]
    OR?: events_logWhereInput[]
    NOT?: events_logWhereInput | events_logWhereInput[]
    id?: IntFilter<"events_log"> | number
    tbl?: StringFilter<"events_log"> | string
    fld?: IntFilter<"events_log"> | number
    details?: StringFilter<"events_log"> | string
    event_date?: DateTimeFilter<"events_log"> | Date | string
    event_by?: IntFilter<"events_log"> | number
    status?: Enumshared_statusFilter<"events_log"> | $Enums.shared_status
    deleted_at?: DateTimeNullableFilter<"events_log"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type events_logOrderByWithRelationInput = {
    id?: SortOrder
    tbl?: SortOrder
    fld?: SortOrder
    details?: SortOrder
    event_date?: SortOrder
    event_by?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
    _relevance?: events_logOrderByRelevanceInput
  }

  export type events_logWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: events_logWhereInput | events_logWhereInput[]
    OR?: events_logWhereInput[]
    NOT?: events_logWhereInput | events_logWhereInput[]
    tbl?: StringFilter<"events_log"> | string
    fld?: IntFilter<"events_log"> | number
    details?: StringFilter<"events_log"> | string
    event_date?: DateTimeFilter<"events_log"> | Date | string
    event_by?: IntFilter<"events_log"> | number
    status?: Enumshared_statusFilter<"events_log"> | $Enums.shared_status
    deleted_at?: DateTimeNullableFilter<"events_log"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type events_logOrderByWithAggregationInput = {
    id?: SortOrder
    tbl?: SortOrder
    fld?: SortOrder
    details?: SortOrder
    event_date?: SortOrder
    event_by?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrderInput | SortOrder
    _count?: events_logCountOrderByAggregateInput
    _avg?: events_logAvgOrderByAggregateInput
    _max?: events_logMaxOrderByAggregateInput
    _min?: events_logMinOrderByAggregateInput
    _sum?: events_logSumOrderByAggregateInput
  }

  export type events_logScalarWhereWithAggregatesInput = {
    AND?: events_logScalarWhereWithAggregatesInput | events_logScalarWhereWithAggregatesInput[]
    OR?: events_logScalarWhereWithAggregatesInput[]
    NOT?: events_logScalarWhereWithAggregatesInput | events_logScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"events_log"> | number
    tbl?: StringWithAggregatesFilter<"events_log"> | string
    fld?: IntWithAggregatesFilter<"events_log"> | number
    details?: StringWithAggregatesFilter<"events_log"> | string
    event_date?: DateTimeWithAggregatesFilter<"events_log"> | Date | string
    event_by?: IntWithAggregatesFilter<"events_log"> | number
    status?: Enumshared_statusWithAggregatesFilter<"events_log"> | $Enums.shared_status
    deleted_at?: DateTimeNullableWithAggregatesFilter<"events_log"> | Date | string | null
  }

  export type accountsCreateInput = {
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
    user: usersCreateNestedOneWithoutAccountsInput
  }

  export type accountsUncheckedCreateInput = {
    id?: number
    userId: number
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type accountsUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: usersUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type accountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type accountsCreateManyInput = {
    id?: number
    userId: number
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type accountsUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type accountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bookingsCreateInput = {
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    user: usersCreateNestedOneWithoutBookingsInput
    client: clientsCreateNestedOneWithoutBookingsInput
    hotel: hotelsCreateNestedOneWithoutBookingsInput
    invoice?: invoicesCreateNestedOneWithoutBookingInput
    quote: quotesCreateNestedOneWithoutBookingInput
    cancellations?: cancellationsCreateNestedManyWithoutBookingInput
    transportation?: transportationCreateNestedManyWithoutBookingsInput
    payments?: paymentsCreateNestedManyWithoutBookingsInput
  }

  export type bookingsUncheckedCreateInput = {
    id?: number
    quote_id: number
    client_id: number
    hotel_id: number
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    agent_id: number
    invoiceid?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutBookingInput
    transportation?: transportationUncheckedCreateNestedManyWithoutBookingsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingsInput
  }

  export type bookingsUpdateInput = {
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    user?: usersUpdateOneRequiredWithoutBookingsNestedInput
    client?: clientsUpdateOneRequiredWithoutBookingsNestedInput
    hotel?: hotelsUpdateOneRequiredWithoutBookingsNestedInput
    invoice?: invoicesUpdateOneWithoutBookingNestedInput
    quote?: quotesUpdateOneRequiredWithoutBookingNestedInput
    cancellations?: cancellationsUpdateManyWithoutBookingNestedInput
    transportation?: transportationUpdateManyWithoutBookingsNestedInput
    payments?: paymentsUpdateManyWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    agent_id?: IntFieldUpdateOperationsInput | number
    invoiceid?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    cancellations?: cancellationsUncheckedUpdateManyWithoutBookingNestedInput
    transportation?: transportationUncheckedUpdateManyWithoutBookingsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingsNestedInput
  }

  export type bookingsCreateManyInput = {
    id?: number
    quote_id: number
    client_id: number
    hotel_id: number
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    agent_id: number
    invoiceid?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
  }

  export type bookingsUpdateManyMutationInput = {
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
  }

  export type bookingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    agent_id?: IntFieldUpdateOperationsInput | number
    invoiceid?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
  }

  export type cancellationsCreateInput = {
    cancellation_date?: Date | string
    reason?: string | null
    hotel_charges: number
    credit_note_url?: string | null
    refund_amount: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    booking: bookingsCreateNestedOneWithoutCancellationsInput
    user: usersCreateNestedOneWithoutCancellationsInput
  }

  export type cancellationsUncheckedCreateInput = {
    id?: number
    booking_id: number
    cancellation_date?: Date | string
    reason?: string | null
    hotel_charges: number
    credit_note_url?: string | null
    refund_amount: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    processed_by: number
    status?: $Enums.shared_status
  }

  export type cancellationsUpdateInput = {
    cancellation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    hotel_charges?: FloatFieldUpdateOperationsInput | number
    credit_note_url?: NullableStringFieldUpdateOperationsInput | string | null
    refund_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    booking?: bookingsUpdateOneRequiredWithoutCancellationsNestedInput
    user?: usersUpdateOneRequiredWithoutCancellationsNestedInput
  }

  export type cancellationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    booking_id?: IntFieldUpdateOperationsInput | number
    cancellation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    hotel_charges?: FloatFieldUpdateOperationsInput | number
    credit_note_url?: NullableStringFieldUpdateOperationsInput | string | null
    refund_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed_by?: IntFieldUpdateOperationsInput | number
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type cancellationsCreateManyInput = {
    id?: number
    booking_id: number
    cancellation_date?: Date | string
    reason?: string | null
    hotel_charges: number
    credit_note_url?: string | null
    refund_amount: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    processed_by: number
    status?: $Enums.shared_status
  }

  export type cancellationsUpdateManyMutationInput = {
    cancellation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    hotel_charges?: FloatFieldUpdateOperationsInput | number
    credit_note_url?: NullableStringFieldUpdateOperationsInput | string | null
    refund_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type cancellationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    booking_id?: IntFieldUpdateOperationsInput | number
    cancellation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    hotel_charges?: FloatFieldUpdateOperationsInput | number
    credit_note_url?: NullableStringFieldUpdateOperationsInput | string | null
    refund_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed_by?: IntFieldUpdateOperationsInput | number
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type clientsCreateInput = {
    name: string
    email: string
    phone: string
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone: string
    bookings?: bookingsCreateNestedManyWithoutClientInput
    branch?: branchesCreateNestedOneWithoutClientsInput
    invoices?: invoicesCreateNestedManyWithoutClientInput
    quotes?: quotesCreateNestedManyWithoutClientInput
  }

  export type clientsUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    phone: string
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone: string
    branch_id?: number | null
    bookings?: bookingsUncheckedCreateNestedManyWithoutClientInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutClientInput
    quotes?: quotesUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUpdateManyWithoutClientNestedInput
    branch?: branchesUpdateOneWithoutClientsNestedInput
    invoices?: invoicesUpdateManyWithoutClientNestedInput
    quotes?: quotesUpdateManyWithoutClientNestedInput
  }

  export type clientsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    bookings?: bookingsUncheckedUpdateManyWithoutClientNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutClientNestedInput
    quotes?: quotesUncheckedUpdateManyWithoutClientNestedInput
  }

  export type clientsCreateManyInput = {
    id?: number
    name: string
    email: string
    phone: string
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone: string
    branch_id?: number | null
  }

  export type clientsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
  }

  export type clientsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type hotel_policiesCreateInput = {
    cancellation: string
    payment_terms: string
    commission_terms: string
    deleted_at?: Date | string | null
    created_at?: Date | string
    status?: $Enums.shared_status
    updated_at?: Date | string | null
    hotel: hotelsCreateNestedOneWithoutHotel_policiesInput
    seasons?: seasonsCreateNestedManyWithoutHotel_policiesInput
  }

  export type hotel_policiesUncheckedCreateInput = {
    id?: number
    cancellation: string
    payment_terms: string
    commission_terms: string
    hotel_id: number
    deleted_at?: Date | string | null
    created_at?: Date | string
    status?: $Enums.shared_status
    updated_at?: Date | string | null
    seasons?: seasonsUncheckedCreateNestedManyWithoutHotel_policiesInput
  }

  export type hotel_policiesUpdateInput = {
    cancellation?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    commission_terms?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotel?: hotelsUpdateOneRequiredWithoutHotel_policiesNestedInput
    seasons?: seasonsUpdateManyWithoutHotel_policiesNestedInput
  }

  export type hotel_policiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cancellation?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    commission_terms?: StringFieldUpdateOperationsInput | string
    hotel_id?: IntFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasons?: seasonsUncheckedUpdateManyWithoutHotel_policiesNestedInput
  }

  export type hotel_policiesCreateManyInput = {
    id?: number
    cancellation: string
    payment_terms: string
    commission_terms: string
    hotel_id: number
    deleted_at?: Date | string | null
    created_at?: Date | string
    status?: $Enums.shared_status
    updated_at?: Date | string | null
  }

  export type hotel_policiesUpdateManyMutationInput = {
    cancellation?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    commission_terms?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hotel_policiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cancellation?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    commission_terms?: StringFieldUpdateOperationsInput | string
    hotel_id?: IntFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type hotelsCreateInput = {
    name: string
    location: string
    contact_email: string
    contact_phone: string
    commission_rate?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    enc_phone: string
    bookings?: bookingsCreateNestedManyWithoutHotelInput
    hotel_policies?: hotel_policiesCreateNestedManyWithoutHotelInput
    rack_rates?: rack_ratesCreateNestedManyWithoutHotelInput
    rate_cards?: rate_cardsCreateNestedManyWithoutHotelsInput
  }

  export type hotelsUncheckedCreateInput = {
    id?: number
    name: string
    location: string
    contact_email: string
    contact_phone: string
    commission_rate?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    enc_phone: string
    bookings?: bookingsUncheckedCreateNestedManyWithoutHotelInput
    hotel_policies?: hotel_policiesUncheckedCreateNestedManyWithoutHotelInput
    rack_rates?: rack_ratesUncheckedCreateNestedManyWithoutHotelInput
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutHotelsInput
  }

  export type hotelsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUpdateManyWithoutHotelNestedInput
    hotel_policies?: hotel_policiesUpdateManyWithoutHotelNestedInput
    rack_rates?: rack_ratesUpdateManyWithoutHotelNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutHotelsNestedInput
  }

  export type hotelsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUncheckedUpdateManyWithoutHotelNestedInput
    hotel_policies?: hotel_policiesUncheckedUpdateManyWithoutHotelNestedInput
    rack_rates?: rack_ratesUncheckedUpdateManyWithoutHotelNestedInput
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutHotelsNestedInput
  }

  export type hotelsCreateManyInput = {
    id?: number
    name: string
    location: string
    contact_email: string
    contact_phone: string
    commission_rate?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    enc_phone: string
  }

  export type hotelsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
  }

  export type hotelsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
  }

  export type invoicesCreateInput = {
    invoice_number: string
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsCreateNestedOneWithoutInvoiceInput
    client: clientsCreateNestedOneWithoutInvoicesInput
    quote: quotesCreateNestedOneWithoutInvoiceInput
    payments?: paymentsCreateNestedManyWithoutInvoiceInput
    reminders?: remindersCreateNestedManyWithoutInvoicesInput
    users?: usersCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateInput = {
    id?: number
    invoice_number: string
    quote_id: number
    client_id: number
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsUncheckedCreateNestedOneWithoutInvoiceInput
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoiceInput
    reminders?: remindersUncheckedCreateNestedManyWithoutInvoicesInput
    users?: usersUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUpdateInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUpdateOneWithoutInvoiceNestedInput
    client?: clientsUpdateOneRequiredWithoutInvoicesNestedInput
    quote?: quotesUpdateOneRequiredWithoutInvoiceNestedInput
    payments?: paymentsUpdateManyWithoutInvoiceNestedInput
    reminders?: remindersUpdateManyWithoutInvoicesNestedInput
    users?: usersUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUncheckedUpdateOneWithoutInvoiceNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutInvoiceNestedInput
    reminders?: remindersUncheckedUpdateManyWithoutInvoicesNestedInput
    users?: usersUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesCreateManyInput = {
    id?: number
    invoice_number: string
    quote_id: number
    client_id: number
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
  }

  export type invoicesUpdateManyMutationInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
  }

  export type invoicesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
  }

  export type notificationsCreateInput = {
    title: string
    message: string
    is_read?: boolean
    read_at?: Date | string | null
    type: $Enums.notifications_type
    reference_id?: number | null
    reference_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    users: usersCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateInput = {
    id?: number
    user_id: number
    title: string
    message: string
    is_read?: boolean
    read_at?: Date | string | null
    type: $Enums.notifications_type
    reference_id?: number | null
    reference_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type notificationsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: Enumnotifications_typeFieldUpdateOperationsInput | $Enums.notifications_type
    reference_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    users?: usersUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: Enumnotifications_typeFieldUpdateOperationsInput | $Enums.notifications_type
    reference_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type notificationsCreateManyInput = {
    id?: number
    user_id: number
    title: string
    message: string
    is_read?: boolean
    read_at?: Date | string | null
    type: $Enums.notifications_type
    reference_id?: number | null
    reference_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type notificationsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: Enumnotifications_typeFieldUpdateOperationsInput | $Enums.notifications_type
    reference_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: Enumnotifications_typeFieldUpdateOperationsInput | $Enums.notifications_type
    reference_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type paymentsCreateInput = {
    amount: number
    payment_date?: Date | string
    payment_method: $Enums.payments_payment_method
    transaction_id?: string | null
    receipt_url?: string | null
    is_confirmed?: boolean
    confirmed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone?: string | null
    phone?: string | null
    invoice: invoicesCreateNestedOneWithoutPaymentsInput
    bookings?: bookingsCreateNestedManyWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    id?: number
    invoice_id: number
    amount: number
    payment_date?: Date | string
    payment_method: $Enums.payments_payment_method
    transaction_id?: string | null
    receipt_url?: string | null
    is_confirmed?: boolean
    confirmed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone?: string | null
    phone?: string | null
    bookings?: bookingsUncheckedCreateNestedManyWithoutPaymentsInput
  }

  export type paymentsUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayments_payment_methodFieldUpdateOperationsInput | $Enums.payments_payment_method
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoicesUpdateOneRequiredWithoutPaymentsNestedInput
    bookings?: bookingsUpdateManyWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayments_payment_methodFieldUpdateOperationsInput | $Enums.payments_payment_method
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: bookingsUncheckedUpdateManyWithoutPaymentsNestedInput
  }

  export type paymentsCreateManyInput = {
    id?: number
    invoice_id: number
    amount: number
    payment_date?: Date | string
    payment_method: $Enums.payments_payment_method
    transaction_id?: string | null
    receipt_url?: string | null
    is_confirmed?: boolean
    confirmed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone?: string | null
    phone?: string | null
  }

  export type paymentsUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayments_payment_methodFieldUpdateOperationsInput | $Enums.payments_payment_method
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayments_payment_methodFieldUpdateOperationsInput | $Enums.payments_payment_method
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type permissionsCreateInput = {
    role: $Enums.users_role
    user_id?: number
    tbl: string
    rec?: number
    general?: number
    create?: number
    read?: number
    update?: number
    delete?: number
    custom_action?: string | null
    added_by?: number
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
  }

  export type permissionsUncheckedCreateInput = {
    id?: number
    role: $Enums.users_role
    user_id?: number
    tbl: string
    rec?: number
    general?: number
    create?: number
    read?: number
    update?: number
    delete?: number
    custom_action?: string | null
    added_by?: number
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
  }

  export type permissionsUpdateInput = {
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    user_id?: IntFieldUpdateOperationsInput | number
    tbl?: StringFieldUpdateOperationsInput | string
    rec?: IntFieldUpdateOperationsInput | number
    general?: IntFieldUpdateOperationsInput | number
    create?: IntFieldUpdateOperationsInput | number
    read?: IntFieldUpdateOperationsInput | number
    update?: IntFieldUpdateOperationsInput | number
    delete?: IntFieldUpdateOperationsInput | number
    custom_action?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type permissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    user_id?: IntFieldUpdateOperationsInput | number
    tbl?: StringFieldUpdateOperationsInput | string
    rec?: IntFieldUpdateOperationsInput | number
    general?: IntFieldUpdateOperationsInput | number
    create?: IntFieldUpdateOperationsInput | number
    read?: IntFieldUpdateOperationsInput | number
    update?: IntFieldUpdateOperationsInput | number
    delete?: IntFieldUpdateOperationsInput | number
    custom_action?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type permissionsCreateManyInput = {
    id?: number
    role: $Enums.users_role
    user_id?: number
    tbl: string
    rec?: number
    general?: number
    create?: number
    read?: number
    update?: number
    delete?: number
    custom_action?: string | null
    added_by?: number
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
  }

  export type permissionsUpdateManyMutationInput = {
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    user_id?: IntFieldUpdateOperationsInput | number
    tbl?: StringFieldUpdateOperationsInput | string
    rec?: IntFieldUpdateOperationsInput | number
    general?: IntFieldUpdateOperationsInput | number
    create?: IntFieldUpdateOperationsInput | number
    read?: IntFieldUpdateOperationsInput | number
    update?: IntFieldUpdateOperationsInput | number
    delete?: IntFieldUpdateOperationsInput | number
    custom_action?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type permissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    user_id?: IntFieldUpdateOperationsInput | number
    tbl?: StringFieldUpdateOperationsInput | string
    rec?: IntFieldUpdateOperationsInput | number
    general?: IntFieldUpdateOperationsInput | number
    create?: IntFieldUpdateOperationsInput | number
    read?: IntFieldUpdateOperationsInput | number
    update?: IntFieldUpdateOperationsInput | number
    delete?: IntFieldUpdateOperationsInput | number
    custom_action?: NullableStringFieldUpdateOperationsInput | string | null
    added_by?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type quotesCreateInput = {
    status?: $Enums.quotes_status
    expiration_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsCreateNestedOneWithoutQuoteInput
    invoice?: invoicesCreateNestedOneWithoutQuoteInput
    client: clientsCreateNestedOneWithoutQuotesInput
    rate_card: rate_cardsCreateNestedOneWithoutQuotesInput
  }

  export type quotesUncheckedCreateInput = {
    id?: number
    rate_card_id: number
    client_id: number
    status?: $Enums.quotes_status
    expiration_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsUncheckedCreateNestedOneWithoutQuoteInput
    invoice?: invoicesUncheckedCreateNestedOneWithoutQuoteInput
  }

  export type quotesUpdateInput = {
    status?: Enumquotes_statusFieldUpdateOperationsInput | $Enums.quotes_status
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUpdateOneWithoutQuoteNestedInput
    invoice?: invoicesUpdateOneWithoutQuoteNestedInput
    client?: clientsUpdateOneRequiredWithoutQuotesNestedInput
    rate_card?: rate_cardsUpdateOneRequiredWithoutQuotesNestedInput
  }

  export type quotesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate_card_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    status?: Enumquotes_statusFieldUpdateOperationsInput | $Enums.quotes_status
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUncheckedUpdateOneWithoutQuoteNestedInput
    invoice?: invoicesUncheckedUpdateOneWithoutQuoteNestedInput
  }

  export type quotesCreateManyInput = {
    id?: number
    rate_card_id: number
    client_id: number
    status?: $Enums.quotes_status
    expiration_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
  }

  export type quotesUpdateManyMutationInput = {
    status?: Enumquotes_statusFieldUpdateOperationsInput | $Enums.quotes_status
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
  }

  export type quotesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate_card_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    status?: Enumquotes_statusFieldUpdateOperationsInput | $Enums.quotes_status
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
  }

  export type rack_ratesCreateInput = {
    rate: number
    currency?: string
    travel_period: $Enums.rack_rates_travel_period
    meal_plan: $Enums.rack_rates_meal_plan
    room_category: $Enums.rack_rates_room_category
    pdf_url?: string | null
    isProcessed?: boolean
    processed_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    hotel: hotelsCreateNestedOneWithoutRack_ratesInput
    rate_cards?: rate_cardsCreateNestedManyWithoutRack_ratesInput
  }

  export type rack_ratesUncheckedCreateInput = {
    id?: number
    rate: number
    currency?: string
    travel_period: $Enums.rack_rates_travel_period
    meal_plan: $Enums.rack_rates_meal_plan
    room_category: $Enums.rack_rates_room_category
    pdf_url?: string | null
    isProcessed?: boolean
    processed_date?: Date | string | null
    hotel_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutRack_ratesInput
  }

  export type rack_ratesUpdateInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrack_rates_travel_periodFieldUpdateOperationsInput | $Enums.rack_rates_travel_period
    meal_plan?: Enumrack_rates_meal_planFieldUpdateOperationsInput | $Enums.rack_rates_meal_plan
    room_category?: Enumrack_rates_room_categoryFieldUpdateOperationsInput | $Enums.rack_rates_room_category
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    hotel?: hotelsUpdateOneRequiredWithoutRack_ratesNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutRack_ratesNestedInput
  }

  export type rack_ratesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrack_rates_travel_periodFieldUpdateOperationsInput | $Enums.rack_rates_travel_period
    meal_plan?: Enumrack_rates_meal_planFieldUpdateOperationsInput | $Enums.rack_rates_meal_plan
    room_category?: Enumrack_rates_room_categoryFieldUpdateOperationsInput | $Enums.rack_rates_room_category
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotel_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutRack_ratesNestedInput
  }

  export type rack_ratesCreateManyInput = {
    id?: number
    rate: number
    currency?: string
    travel_period: $Enums.rack_rates_travel_period
    meal_plan: $Enums.rack_rates_meal_plan
    room_category: $Enums.rack_rates_room_category
    pdf_url?: string | null
    isProcessed?: boolean
    processed_date?: Date | string | null
    hotel_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
  }

  export type rack_ratesUpdateManyMutationInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrack_rates_travel_periodFieldUpdateOperationsInput | $Enums.rack_rates_travel_period
    meal_plan?: Enumrack_rates_meal_planFieldUpdateOperationsInput | $Enums.rack_rates_meal_plan
    room_category?: Enumrack_rates_room_categoryFieldUpdateOperationsInput | $Enums.rack_rates_room_category
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type rack_ratesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrack_rates_travel_periodFieldUpdateOperationsInput | $Enums.rack_rates_travel_period
    meal_plan?: Enumrack_rates_meal_planFieldUpdateOperationsInput | $Enums.rack_rates_meal_plan
    room_category?: Enumrack_rates_room_categoryFieldUpdateOperationsInput | $Enums.rack_rates_room_category
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotel_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type rate_cardsCreateInput = {
    name: string
    base_rate: number
    commission_rate?: number | null
    markup_rate?: number | null
    discount_amount?: number | null
    discount_percent?: number | null
    final_rate: number
    currency?: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    quotes?: quotesCreateNestedManyWithoutRate_cardInput
    users: usersCreateNestedOneWithoutRate_cardsInput
    hotels: hotelsCreateNestedOneWithoutRate_cardsInput
    rack_rates: rack_ratesCreateNestedOneWithoutRate_cardsInput
  }

  export type rate_cardsUncheckedCreateInput = {
    id?: number
    name: string
    base_rate: number
    commission_rate?: number | null
    markup_rate?: number | null
    discount_amount?: number | null
    discount_percent?: number | null
    final_rate: number
    currency?: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission?: number | null
    is_active?: boolean
    rack_rate_id: number
    hotel_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    created_by: number
    public_id: string
    status?: $Enums.shared_status
    quotes?: quotesUncheckedCreateNestedManyWithoutRate_cardInput
  }

  export type rate_cardsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    quotes?: quotesUpdateManyWithoutRate_cardNestedInput
    users?: usersUpdateOneRequiredWithoutRate_cardsNestedInput
    hotels?: hotelsUpdateOneRequiredWithoutRate_cardsNestedInput
    rack_rates?: rack_ratesUpdateOneRequiredWithoutRate_cardsNestedInput
  }

  export type rate_cardsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rack_rate_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    quotes?: quotesUncheckedUpdateManyWithoutRate_cardNestedInput
  }

  export type rate_cardsCreateManyInput = {
    id?: number
    name: string
    base_rate: number
    commission_rate?: number | null
    markup_rate?: number | null
    discount_amount?: number | null
    discount_percent?: number | null
    final_rate: number
    currency?: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission?: number | null
    is_active?: boolean
    rack_rate_id: number
    hotel_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    created_by: number
    public_id: string
    status?: $Enums.shared_status
  }

  export type rate_cardsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type rate_cardsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rack_rate_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type remindersCreateInput = {
    reminder_date: Date | string
    message: string
    is_sent?: boolean
    sent_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    invoices: invoicesCreateNestedOneWithoutRemindersInput
  }

  export type remindersUncheckedCreateInput = {
    id?: number
    invoice_id: number
    reminder_date: Date | string
    message: string
    is_sent?: boolean
    sent_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type remindersUpdateInput = {
    reminder_date?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    is_sent?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    invoices?: invoicesUpdateOneRequiredWithoutRemindersNestedInput
  }

  export type remindersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_id?: IntFieldUpdateOperationsInput | number
    reminder_date?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    is_sent?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type remindersCreateManyInput = {
    id?: number
    invoice_id: number
    reminder_date: Date | string
    message: string
    is_sent?: boolean
    sent_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type remindersUpdateManyMutationInput = {
    reminder_date?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    is_sent?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type remindersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_id?: IntFieldUpdateOperationsInput | number
    reminder_date?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    is_sent?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type seasonsCreateInput = {
    name: string
    period_type: $Enums.seasons_period_type
    start_date: Date | string
    end_date: Date | string
    created_at?: Date | string
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    updated_at?: Date | string | null
    hotel_policies: hotel_policiesCreateNestedOneWithoutSeasonsInput
  }

  export type seasonsUncheckedCreateInput = {
    id?: number
    name: string
    period_type: $Enums.seasons_period_type
    start_date: Date | string
    end_date: Date | string
    hotel_policy_id: number
    created_at?: Date | string
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    updated_at?: Date | string | null
  }

  export type seasonsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    period_type?: Enumseasons_period_typeFieldUpdateOperationsInput | $Enums.seasons_period_type
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotel_policies?: hotel_policiesUpdateOneRequiredWithoutSeasonsNestedInput
  }

  export type seasonsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    period_type?: Enumseasons_period_typeFieldUpdateOperationsInput | $Enums.seasons_period_type
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel_policy_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type seasonsCreateManyInput = {
    id?: number
    name: string
    period_type: $Enums.seasons_period_type
    start_date: Date | string
    end_date: Date | string
    hotel_policy_id: number
    created_at?: Date | string
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    updated_at?: Date | string | null
  }

  export type seasonsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    period_type?: Enumseasons_period_typeFieldUpdateOperationsInput | $Enums.seasons_period_type
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type seasonsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    period_type?: Enumseasons_period_typeFieldUpdateOperationsInput | $Enums.seasons_period_type
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel_policy_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionsCreateInput = {
    session_token: string
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
    expires_at: Date | string
    users: usersCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateInput = {
    id?: number
    session_token: string
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
    expires_at: Date | string
  }

  export type sessionsUpdateInput = {
    session_token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_token?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsCreateManyInput = {
    id?: number
    session_token: string
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
    expires_at: Date | string
  }

  export type sessionsUpdateManyMutationInput = {
    session_token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_token?: StringFieldUpdateOperationsInput | string
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transportationCreateInput = {
    type: $Enums.transportation_type
    provider: string
    booking_ref?: string | null
    departure_date: Date | string
    return_date?: Date | string | null
    departure_point: string
    arrival_point: string
    cost: number
    status?: $Enums.transportation_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    bookings: bookingsCreateNestedOneWithoutTransportationInput
  }

  export type transportationUncheckedCreateInput = {
    id?: number
    type: $Enums.transportation_type
    provider: string
    booking_ref?: string | null
    departure_date: Date | string
    return_date?: Date | string | null
    departure_point: string
    arrival_point: string
    cost: number
    booking_id: number
    status?: $Enums.transportation_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type transportationUpdateInput = {
    type?: Enumtransportation_typeFieldUpdateOperationsInput | $Enums.transportation_type
    provider?: StringFieldUpdateOperationsInput | string
    booking_ref?: NullableStringFieldUpdateOperationsInput | string | null
    departure_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departure_point?: StringFieldUpdateOperationsInput | string
    arrival_point?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    status?: Enumtransportation_statusFieldUpdateOperationsInput | $Enums.transportation_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: bookingsUpdateOneRequiredWithoutTransportationNestedInput
  }

  export type transportationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: Enumtransportation_typeFieldUpdateOperationsInput | $Enums.transportation_type
    provider?: StringFieldUpdateOperationsInput | string
    booking_ref?: NullableStringFieldUpdateOperationsInput | string | null
    departure_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departure_point?: StringFieldUpdateOperationsInput | string
    arrival_point?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    booking_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtransportation_statusFieldUpdateOperationsInput | $Enums.transportation_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transportationCreateManyInput = {
    id?: number
    type: $Enums.transportation_type
    provider: string
    booking_ref?: string | null
    departure_date: Date | string
    return_date?: Date | string | null
    departure_point: string
    arrival_point: string
    cost: number
    booking_id: number
    status?: $Enums.transportation_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type transportationUpdateManyMutationInput = {
    type?: Enumtransportation_typeFieldUpdateOperationsInput | $Enums.transportation_type
    provider?: StringFieldUpdateOperationsInput | string
    booking_ref?: NullableStringFieldUpdateOperationsInput | string | null
    departure_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departure_point?: StringFieldUpdateOperationsInput | string
    arrival_point?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    status?: Enumtransportation_statusFieldUpdateOperationsInput | $Enums.transportation_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transportationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: Enumtransportation_typeFieldUpdateOperationsInput | $Enums.transportation_type
    provider?: StringFieldUpdateOperationsInput | string
    booking_ref?: NullableStringFieldUpdateOperationsInput | string | null
    departure_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departure_point?: StringFieldUpdateOperationsInput | string
    arrival_point?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    booking_id?: IntFieldUpdateOperationsInput | number
    status?: Enumtransportation_statusFieldUpdateOperationsInput | $Enums.transportation_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    image?: string | null
    accounts?: accountsCreateNestedManyWithoutUserInput
    bookings?: bookingsCreateNestedManyWithoutUserInput
    cancellations?: cancellationsCreateNestedManyWithoutUserInput
    events?: events_logCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    branch?: branchesCreateNestedOneWithoutUsersInput
    users_branches?: users_branchesCreateNestedManyWithoutUserInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    branch_id?: number | null
    image?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutUserInput
    bookings?: bookingsUncheckedCreateNestedManyWithoutUserInput
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutUserInput
    events?: events_logUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    users_branches?: users_branchesUncheckedCreateNestedManyWithoutUserInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutUserNestedInput
    bookings?: bookingsUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUpdateManyWithoutUserNestedInput
    events?: events_logUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    branch?: branchesUpdateOneWithoutUsersNestedInput
    users_branches?: users_branchesUpdateManyWithoutUserNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutUserNestedInput
    bookings?: bookingsUncheckedUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUncheckedUpdateManyWithoutUserNestedInput
    events?: events_logUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    users_branches?: users_branchesUncheckedUpdateManyWithoutUserNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    branch_id?: number | null
    image?: string | null
  }

  export type usersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type branchesCreateInput = {
    name: string
    location: string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    clients?: clientsCreateNestedManyWithoutBranchInput
    users?: usersCreateNestedManyWithoutBranchInput
    users_branches?: users_branchesCreateNestedManyWithoutBranchInput
  }

  export type branchesUncheckedCreateInput = {
    id?: number
    name: string
    location: string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    clients?: clientsUncheckedCreateNestedManyWithoutBranchInput
    users?: usersUncheckedCreateNestedManyWithoutBranchInput
    users_branches?: users_branchesUncheckedCreateNestedManyWithoutBranchInput
  }

  export type branchesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    clients?: clientsUpdateManyWithoutBranchNestedInput
    users?: usersUpdateManyWithoutBranchNestedInput
    users_branches?: users_branchesUpdateManyWithoutBranchNestedInput
  }

  export type branchesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    clients?: clientsUncheckedUpdateManyWithoutBranchNestedInput
    users?: usersUncheckedUpdateManyWithoutBranchNestedInput
    users_branches?: users_branchesUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type branchesCreateManyInput = {
    id?: number
    name: string
    location: string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type branchesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type branchesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type users_branchesCreateInput = {
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    branch: branchesCreateNestedOneWithoutUsers_branchesInput
    user: usersCreateNestedOneWithoutUsers_branchesInput
  }

  export type users_branchesUncheckedCreateInput = {
    id?: number
    user_id: number
    branch_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type users_branchesUpdateInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    branch?: branchesUpdateOneRequiredWithoutUsers_branchesNestedInput
    user?: usersUpdateOneRequiredWithoutUsers_branchesNestedInput
  }

  export type users_branchesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    branch_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type users_branchesCreateManyInput = {
    id?: number
    user_id: number
    branch_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type users_branchesUpdateManyMutationInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type users_branchesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    branch_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type events_logCreateInput = {
    tbl: string
    fld: number
    details: string
    event_date?: Date | string
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
    users?: usersCreateNestedOneWithoutEventsInput
  }

  export type events_logUncheckedCreateInput = {
    id?: number
    tbl: string
    fld: number
    details: string
    event_date?: Date | string
    event_by?: number
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
  }

  export type events_logUpdateInput = {
    tbl?: StringFieldUpdateOperationsInput | string
    fld?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutEventsNestedInput
  }

  export type events_logUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tbl?: StringFieldUpdateOperationsInput | string
    fld?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_by?: IntFieldUpdateOperationsInput | number
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type events_logCreateManyInput = {
    id?: number
    tbl: string
    fld: number
    details: string
    event_date?: Date | string
    event_by?: number
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
  }

  export type events_logUpdateManyMutationInput = {
    tbl?: StringFieldUpdateOperationsInput | string
    fld?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type events_logUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tbl?: StringFieldUpdateOperationsInput | string
    fld?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_by?: IntFieldUpdateOperationsInput | number
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type accountsOrderByRelevanceInput = {
    fields: accountsOrderByRelevanceFieldEnum | accountsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type accountsProviderProvider_account_idCompoundUniqueInput = {
    provider: string
    provider_account_id: string
  }

  export type accountsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type accountsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires_at?: SortOrder
  }

  export type accountsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type accountsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type accountsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expires_at?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Enumbookings_meal_planFilter<$PrismaModel = never> = {
    equals?: $Enums.bookings_meal_plan | Enumbookings_meal_planFieldRefInput<$PrismaModel>
    in?: $Enums.bookings_meal_plan[]
    notIn?: $Enums.bookings_meal_plan[]
    not?: NestedEnumbookings_meal_planFilter<$PrismaModel> | $Enums.bookings_meal_plan
  }

  export type Enumbookings_room_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.bookings_room_category | Enumbookings_room_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.bookings_room_category[]
    notIn?: $Enums.bookings_room_category[]
    not?: NestedEnumbookings_room_categoryFilter<$PrismaModel> | $Enums.bookings_room_category
  }

  export type Enumbookings_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.bookings_status | Enumbookings_statusFieldRefInput<$PrismaModel>
    in?: $Enums.bookings_status[]
    notIn?: $Enums.bookings_status[]
    not?: NestedEnumbookings_statusFilter<$PrismaModel> | $Enums.bookings_status
  }

  export type ClientsScalarRelationFilter = {
    is?: clientsWhereInput
    isNot?: clientsWhereInput
  }

  export type HotelsScalarRelationFilter = {
    is?: hotelsWhereInput
    isNot?: hotelsWhereInput
  }

  export type InvoicesNullableScalarRelationFilter = {
    is?: invoicesWhereInput | null
    isNot?: invoicesWhereInput | null
  }

  export type QuotesScalarRelationFilter = {
    is?: quotesWhereInput
    isNot?: quotesWhereInput
  }

  export type CancellationsListRelationFilter = {
    every?: cancellationsWhereInput
    some?: cancellationsWhereInput
    none?: cancellationsWhereInput
  }

  export type TransportationListRelationFilter = {
    every?: transportationWhereInput
    some?: transportationWhereInput
    none?: transportationWhereInput
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type cancellationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transportationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bookingsOrderByRelevanceInput = {
    fields: bookingsOrderByRelevanceFieldEnum | bookingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type bookingsCountOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    client_id?: SortOrder
    hotel_id?: SortOrder
    travel_date?: SortOrder
    return_date?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    status?: SortOrder
    voucher_url?: SortOrder
    agent_id?: SortOrder
    invoiceid?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
  }

  export type bookingsAvgOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    client_id?: SortOrder
    hotel_id?: SortOrder
    agent_id?: SortOrder
    invoiceid?: SortOrder
  }

  export type bookingsMaxOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    client_id?: SortOrder
    hotel_id?: SortOrder
    travel_date?: SortOrder
    return_date?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    status?: SortOrder
    voucher_url?: SortOrder
    agent_id?: SortOrder
    invoiceid?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
  }

  export type bookingsMinOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    client_id?: SortOrder
    hotel_id?: SortOrder
    travel_date?: SortOrder
    return_date?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    status?: SortOrder
    voucher_url?: SortOrder
    agent_id?: SortOrder
    invoiceid?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
  }

  export type bookingsSumOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    client_id?: SortOrder
    hotel_id?: SortOrder
    agent_id?: SortOrder
    invoiceid?: SortOrder
  }

  export type Enumbookings_meal_planWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.bookings_meal_plan | Enumbookings_meal_planFieldRefInput<$PrismaModel>
    in?: $Enums.bookings_meal_plan[]
    notIn?: $Enums.bookings_meal_plan[]
    not?: NestedEnumbookings_meal_planWithAggregatesFilter<$PrismaModel> | $Enums.bookings_meal_plan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumbookings_meal_planFilter<$PrismaModel>
    _max?: NestedEnumbookings_meal_planFilter<$PrismaModel>
  }

  export type Enumbookings_room_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.bookings_room_category | Enumbookings_room_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.bookings_room_category[]
    notIn?: $Enums.bookings_room_category[]
    not?: NestedEnumbookings_room_categoryWithAggregatesFilter<$PrismaModel> | $Enums.bookings_room_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumbookings_room_categoryFilter<$PrismaModel>
    _max?: NestedEnumbookings_room_categoryFilter<$PrismaModel>
  }

  export type Enumbookings_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.bookings_status | Enumbookings_statusFieldRefInput<$PrismaModel>
    in?: $Enums.bookings_status[]
    notIn?: $Enums.bookings_status[]
    not?: NestedEnumbookings_statusWithAggregatesFilter<$PrismaModel> | $Enums.bookings_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumbookings_statusFilter<$PrismaModel>
    _max?: NestedEnumbookings_statusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type Enumshared_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.shared_status | Enumshared_statusFieldRefInput<$PrismaModel>
    in?: $Enums.shared_status[]
    notIn?: $Enums.shared_status[]
    not?: NestedEnumshared_statusFilter<$PrismaModel> | $Enums.shared_status
  }

  export type BookingsScalarRelationFilter = {
    is?: bookingsWhereInput
    isNot?: bookingsWhereInput
  }

  export type cancellationsOrderByRelevanceInput = {
    fields: cancellationsOrderByRelevanceFieldEnum | cancellationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type cancellationsCountOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    cancellation_date?: SortOrder
    reason?: SortOrder
    hotel_charges?: SortOrder
    credit_note_url?: SortOrder
    refund_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    processed_by?: SortOrder
    status?: SortOrder
  }

  export type cancellationsAvgOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    hotel_charges?: SortOrder
    refund_amount?: SortOrder
    processed_by?: SortOrder
  }

  export type cancellationsMaxOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    cancellation_date?: SortOrder
    reason?: SortOrder
    hotel_charges?: SortOrder
    credit_note_url?: SortOrder
    refund_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    processed_by?: SortOrder
    status?: SortOrder
  }

  export type cancellationsMinOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    cancellation_date?: SortOrder
    reason?: SortOrder
    hotel_charges?: SortOrder
    credit_note_url?: SortOrder
    refund_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    processed_by?: SortOrder
    status?: SortOrder
  }

  export type cancellationsSumOrderByAggregateInput = {
    id?: SortOrder
    booking_id?: SortOrder
    hotel_charges?: SortOrder
    refund_amount?: SortOrder
    processed_by?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type Enumshared_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.shared_status | Enumshared_statusFieldRefInput<$PrismaModel>
    in?: $Enums.shared_status[]
    notIn?: $Enums.shared_status[]
    not?: NestedEnumshared_statusWithAggregatesFilter<$PrismaModel> | $Enums.shared_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumshared_statusFilter<$PrismaModel>
    _max?: NestedEnumshared_statusFilter<$PrismaModel>
  }

  export type BookingsListRelationFilter = {
    every?: bookingsWhereInput
    some?: bookingsWhereInput
    none?: bookingsWhereInput
  }

  export type BranchesNullableScalarRelationFilter = {
    is?: branchesWhereInput | null
    isNot?: branchesWhereInput | null
  }

  export type InvoicesListRelationFilter = {
    every?: invoicesWhereInput
    some?: invoicesWhereInput
    none?: invoicesWhereInput
  }

  export type QuotesListRelationFilter = {
    every?: quotesWhereInput
    some?: quotesWhereInput
    none?: quotesWhereInput
  }

  export type bookingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invoicesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clientsOrderByRelevanceInput = {
    fields: clientsOrderByRelevanceFieldEnum | clientsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type clientsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
    status?: SortOrder
    enc_phone?: SortOrder
    branch_id?: SortOrder
  }

  export type clientsAvgOrderByAggregateInput = {
    id?: SortOrder
    branch_id?: SortOrder
  }

  export type clientsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
    status?: SortOrder
    enc_phone?: SortOrder
    branch_id?: SortOrder
  }

  export type clientsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
    status?: SortOrder
    enc_phone?: SortOrder
    branch_id?: SortOrder
  }

  export type clientsSumOrderByAggregateInput = {
    id?: SortOrder
    branch_id?: SortOrder
  }

  export type SeasonsListRelationFilter = {
    every?: seasonsWhereInput
    some?: seasonsWhereInput
    none?: seasonsWhereInput
  }

  export type seasonsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type hotel_policiesOrderByRelevanceInput = {
    fields: hotel_policiesOrderByRelevanceFieldEnum | hotel_policiesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type hotel_policiesCountOrderByAggregateInput = {
    id?: SortOrder
    cancellation?: SortOrder
    payment_terms?: SortOrder
    commission_terms?: SortOrder
    hotel_id?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
    updated_at?: SortOrder
  }

  export type hotel_policiesAvgOrderByAggregateInput = {
    id?: SortOrder
    hotel_id?: SortOrder
  }

  export type hotel_policiesMaxOrderByAggregateInput = {
    id?: SortOrder
    cancellation?: SortOrder
    payment_terms?: SortOrder
    commission_terms?: SortOrder
    hotel_id?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
    updated_at?: SortOrder
  }

  export type hotel_policiesMinOrderByAggregateInput = {
    id?: SortOrder
    cancellation?: SortOrder
    payment_terms?: SortOrder
    commission_terms?: SortOrder
    hotel_id?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    status?: SortOrder
    updated_at?: SortOrder
  }

  export type hotel_policiesSumOrderByAggregateInput = {
    id?: SortOrder
    hotel_id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type Hotel_policiesListRelationFilter = {
    every?: hotel_policiesWhereInput
    some?: hotel_policiesWhereInput
    none?: hotel_policiesWhereInput
  }

  export type Rack_ratesListRelationFilter = {
    every?: rack_ratesWhereInput
    some?: rack_ratesWhereInput
    none?: rack_ratesWhereInput
  }

  export type Rate_cardsListRelationFilter = {
    every?: rate_cardsWhereInput
    some?: rate_cardsWhereInput
    none?: rate_cardsWhereInput
  }

  export type hotel_policiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rack_ratesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rate_cardsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type hotelsOrderByRelevanceInput = {
    fields: hotelsOrderByRelevanceFieldEnum | hotelsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type hotelsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    contact_email?: SortOrder
    contact_phone?: SortOrder
    commission_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
    enc_phone?: SortOrder
  }

  export type hotelsAvgOrderByAggregateInput = {
    id?: SortOrder
    commission_rate?: SortOrder
  }

  export type hotelsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    contact_email?: SortOrder
    contact_phone?: SortOrder
    commission_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
    enc_phone?: SortOrder
  }

  export type hotelsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    contact_email?: SortOrder
    contact_phone?: SortOrder
    commission_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
    enc_phone?: SortOrder
  }

  export type hotelsSumOrderByAggregateInput = {
    id?: SortOrder
    commission_rate?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type Enuminvoices_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.invoices_status | Enuminvoices_statusFieldRefInput<$PrismaModel>
    in?: $Enums.invoices_status[]
    notIn?: $Enums.invoices_status[]
    not?: NestedEnuminvoices_statusFilter<$PrismaModel> | $Enums.invoices_status
  }

  export type BookingsNullableScalarRelationFilter = {
    is?: bookingsWhereInput | null
    isNot?: bookingsWhereInput | null
  }

  export type RemindersListRelationFilter = {
    every?: remindersWhereInput
    some?: remindersWhereInput
    none?: remindersWhereInput
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type remindersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type invoicesOrderByRelevanceInput = {
    fields: invoicesOrderByRelevanceFieldEnum | invoicesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type invoicesCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    quote_id?: SortOrder
    client_id?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
  }

  export type invoicesAvgOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    client_id?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
  }

  export type invoicesMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    quote_id?: SortOrder
    client_id?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
  }

  export type invoicesMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_number?: SortOrder
    quote_id?: SortOrder
    client_id?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
  }

  export type invoicesSumOrderByAggregateInput = {
    id?: SortOrder
    quote_id?: SortOrder
    client_id?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrder
    total_amount?: SortOrder
  }

  export type Enuminvoices_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.invoices_status | Enuminvoices_statusFieldRefInput<$PrismaModel>
    in?: $Enums.invoices_status[]
    notIn?: $Enums.invoices_status[]
    not?: NestedEnuminvoices_statusWithAggregatesFilter<$PrismaModel> | $Enums.invoices_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminvoices_statusFilter<$PrismaModel>
    _max?: NestedEnuminvoices_statusFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Enumnotifications_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.notifications_type | Enumnotifications_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notifications_type[]
    notIn?: $Enums.notifications_type[]
    not?: NestedEnumnotifications_typeFilter<$PrismaModel> | $Enums.notifications_type
  }

  export type notificationsOrderByRelevanceInput = {
    fields: notificationsOrderByRelevanceFieldEnum | notificationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    read_at?: SortOrder
    type?: SortOrder
    reference_id?: SortOrder
    reference_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
  }

  export type notificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    reference_id?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    read_at?: SortOrder
    type?: SortOrder
    reference_id?: SortOrder
    reference_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    is_read?: SortOrder
    read_at?: SortOrder
    type?: SortOrder
    reference_id?: SortOrder
    reference_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
  }

  export type notificationsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    reference_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type Enumnotifications_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.notifications_type | Enumnotifications_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notifications_type[]
    notIn?: $Enums.notifications_type[]
    not?: NestedEnumnotifications_typeWithAggregatesFilter<$PrismaModel> | $Enums.notifications_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumnotifications_typeFilter<$PrismaModel>
    _max?: NestedEnumnotifications_typeFilter<$PrismaModel>
  }

  export type Enumpayments_payment_methodFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_payment_method | Enumpayments_payment_methodFieldRefInput<$PrismaModel>
    in?: $Enums.payments_payment_method[]
    notIn?: $Enums.payments_payment_method[]
    not?: NestedEnumpayments_payment_methodFilter<$PrismaModel> | $Enums.payments_payment_method
  }

  export type InvoicesScalarRelationFilter = {
    is?: invoicesWhereInput
    isNot?: invoicesWhereInput
  }

  export type paymentsOrderByRelevanceInput = {
    fields: paymentsOrderByRelevanceFieldEnum | paymentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    receipt_url?: SortOrder
    is_confirmed?: SortOrder
    confirmed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
    status?: SortOrder
    enc_phone?: SortOrder
    phone?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    receipt_url?: SortOrder
    is_confirmed?: SortOrder
    confirmed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
    status?: SortOrder
    enc_phone?: SortOrder
    phone?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    receipt_url?: SortOrder
    is_confirmed?: SortOrder
    confirmed_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
    status?: SortOrder
    enc_phone?: SortOrder
    phone?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
  }

  export type Enumpayments_payment_methodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_payment_method | Enumpayments_payment_methodFieldRefInput<$PrismaModel>
    in?: $Enums.payments_payment_method[]
    notIn?: $Enums.payments_payment_method[]
    not?: NestedEnumpayments_payment_methodWithAggregatesFilter<$PrismaModel> | $Enums.payments_payment_method
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayments_payment_methodFilter<$PrismaModel>
    _max?: NestedEnumpayments_payment_methodFilter<$PrismaModel>
  }

  export type Enumusers_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.users_role | Enumusers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.users_role[]
    notIn?: $Enums.users_role[]
    not?: NestedEnumusers_roleFilter<$PrismaModel> | $Enums.users_role
  }

  export type permissionsOrderByRelevanceInput = {
    fields: permissionsOrderByRelevanceFieldEnum | permissionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type permissionsCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    user_id?: SortOrder
    tbl?: SortOrder
    rec?: SortOrder
    general?: SortOrder
    create?: SortOrder
    read?: SortOrder
    update?: SortOrder
    delete?: SortOrder
    custom_action?: SortOrder
    added_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
  }

  export type permissionsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    rec?: SortOrder
    general?: SortOrder
    create?: SortOrder
    read?: SortOrder
    update?: SortOrder
    delete?: SortOrder
    added_by?: SortOrder
  }

  export type permissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    user_id?: SortOrder
    tbl?: SortOrder
    rec?: SortOrder
    general?: SortOrder
    create?: SortOrder
    read?: SortOrder
    update?: SortOrder
    delete?: SortOrder
    custom_action?: SortOrder
    added_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
  }

  export type permissionsMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    user_id?: SortOrder
    tbl?: SortOrder
    rec?: SortOrder
    general?: SortOrder
    create?: SortOrder
    read?: SortOrder
    update?: SortOrder
    delete?: SortOrder
    custom_action?: SortOrder
    added_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
  }

  export type permissionsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    rec?: SortOrder
    general?: SortOrder
    create?: SortOrder
    read?: SortOrder
    update?: SortOrder
    delete?: SortOrder
    added_by?: SortOrder
  }

  export type Enumusers_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.users_role | Enumusers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.users_role[]
    notIn?: $Enums.users_role[]
    not?: NestedEnumusers_roleWithAggregatesFilter<$PrismaModel> | $Enums.users_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusers_roleFilter<$PrismaModel>
    _max?: NestedEnumusers_roleFilter<$PrismaModel>
  }

  export type Enumquotes_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.quotes_status | Enumquotes_statusFieldRefInput<$PrismaModel>
    in?: $Enums.quotes_status[]
    notIn?: $Enums.quotes_status[]
    not?: NestedEnumquotes_statusFilter<$PrismaModel> | $Enums.quotes_status
  }

  export type Rate_cardsScalarRelationFilter = {
    is?: rate_cardsWhereInput
    isNot?: rate_cardsWhereInput
  }

  export type quotesOrderByRelevanceInput = {
    fields: quotesOrderByRelevanceFieldEnum | quotesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type quotesCountOrderByAggregateInput = {
    id?: SortOrder
    rate_card_id?: SortOrder
    client_id?: SortOrder
    status?: SortOrder
    expiration_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
  }

  export type quotesAvgOrderByAggregateInput = {
    id?: SortOrder
    rate_card_id?: SortOrder
    client_id?: SortOrder
  }

  export type quotesMaxOrderByAggregateInput = {
    id?: SortOrder
    rate_card_id?: SortOrder
    client_id?: SortOrder
    status?: SortOrder
    expiration_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
  }

  export type quotesMinOrderByAggregateInput = {
    id?: SortOrder
    rate_card_id?: SortOrder
    client_id?: SortOrder
    status?: SortOrder
    expiration_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
  }

  export type quotesSumOrderByAggregateInput = {
    id?: SortOrder
    rate_card_id?: SortOrder
    client_id?: SortOrder
  }

  export type Enumquotes_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.quotes_status | Enumquotes_statusFieldRefInput<$PrismaModel>
    in?: $Enums.quotes_status[]
    notIn?: $Enums.quotes_status[]
    not?: NestedEnumquotes_statusWithAggregatesFilter<$PrismaModel> | $Enums.quotes_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumquotes_statusFilter<$PrismaModel>
    _max?: NestedEnumquotes_statusFilter<$PrismaModel>
  }

  export type Enumrack_rates_travel_periodFilter<$PrismaModel = never> = {
    equals?: $Enums.rack_rates_travel_period | Enumrack_rates_travel_periodFieldRefInput<$PrismaModel>
    in?: $Enums.rack_rates_travel_period[]
    notIn?: $Enums.rack_rates_travel_period[]
    not?: NestedEnumrack_rates_travel_periodFilter<$PrismaModel> | $Enums.rack_rates_travel_period
  }

  export type Enumrack_rates_meal_planFilter<$PrismaModel = never> = {
    equals?: $Enums.rack_rates_meal_plan | Enumrack_rates_meal_planFieldRefInput<$PrismaModel>
    in?: $Enums.rack_rates_meal_plan[]
    notIn?: $Enums.rack_rates_meal_plan[]
    not?: NestedEnumrack_rates_meal_planFilter<$PrismaModel> | $Enums.rack_rates_meal_plan
  }

  export type Enumrack_rates_room_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.rack_rates_room_category | Enumrack_rates_room_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.rack_rates_room_category[]
    notIn?: $Enums.rack_rates_room_category[]
    not?: NestedEnumrack_rates_room_categoryFilter<$PrismaModel> | $Enums.rack_rates_room_category
  }

  export type rack_ratesOrderByRelevanceInput = {
    fields: rack_ratesOrderByRelevanceFieldEnum | rack_ratesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type rack_ratesCountOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    currency?: SortOrder
    travel_period?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    pdf_url?: SortOrder
    isProcessed?: SortOrder
    processed_date?: SortOrder
    hotel_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
    status?: SortOrder
  }

  export type rack_ratesAvgOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    hotel_id?: SortOrder
  }

  export type rack_ratesMaxOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    currency?: SortOrder
    travel_period?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    pdf_url?: SortOrder
    isProcessed?: SortOrder
    processed_date?: SortOrder
    hotel_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
    status?: SortOrder
  }

  export type rack_ratesMinOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    currency?: SortOrder
    travel_period?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    pdf_url?: SortOrder
    isProcessed?: SortOrder
    processed_date?: SortOrder
    hotel_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
    status?: SortOrder
  }

  export type rack_ratesSumOrderByAggregateInput = {
    id?: SortOrder
    rate?: SortOrder
    hotel_id?: SortOrder
  }

  export type Enumrack_rates_travel_periodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rack_rates_travel_period | Enumrack_rates_travel_periodFieldRefInput<$PrismaModel>
    in?: $Enums.rack_rates_travel_period[]
    notIn?: $Enums.rack_rates_travel_period[]
    not?: NestedEnumrack_rates_travel_periodWithAggregatesFilter<$PrismaModel> | $Enums.rack_rates_travel_period
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrack_rates_travel_periodFilter<$PrismaModel>
    _max?: NestedEnumrack_rates_travel_periodFilter<$PrismaModel>
  }

  export type Enumrack_rates_meal_planWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rack_rates_meal_plan | Enumrack_rates_meal_planFieldRefInput<$PrismaModel>
    in?: $Enums.rack_rates_meal_plan[]
    notIn?: $Enums.rack_rates_meal_plan[]
    not?: NestedEnumrack_rates_meal_planWithAggregatesFilter<$PrismaModel> | $Enums.rack_rates_meal_plan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrack_rates_meal_planFilter<$PrismaModel>
    _max?: NestedEnumrack_rates_meal_planFilter<$PrismaModel>
  }

  export type Enumrack_rates_room_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rack_rates_room_category | Enumrack_rates_room_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.rack_rates_room_category[]
    notIn?: $Enums.rack_rates_room_category[]
    not?: NestedEnumrack_rates_room_categoryWithAggregatesFilter<$PrismaModel> | $Enums.rack_rates_room_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrack_rates_room_categoryFilter<$PrismaModel>
    _max?: NestedEnumrack_rates_room_categoryFilter<$PrismaModel>
  }

  export type Enumrate_cards_travel_periodFilter<$PrismaModel = never> = {
    equals?: $Enums.rate_cards_travel_period | Enumrate_cards_travel_periodFieldRefInput<$PrismaModel>
    in?: $Enums.rate_cards_travel_period[]
    notIn?: $Enums.rate_cards_travel_period[]
    not?: NestedEnumrate_cards_travel_periodFilter<$PrismaModel> | $Enums.rate_cards_travel_period
  }

  export type Enumrate_cards_meal_planFilter<$PrismaModel = never> = {
    equals?: $Enums.rate_cards_meal_plan | Enumrate_cards_meal_planFieldRefInput<$PrismaModel>
    in?: $Enums.rate_cards_meal_plan[]
    notIn?: $Enums.rate_cards_meal_plan[]
    not?: NestedEnumrate_cards_meal_planFilter<$PrismaModel> | $Enums.rate_cards_meal_plan
  }

  export type Enumrate_cards_room_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.rate_cards_room_category | Enumrate_cards_room_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.rate_cards_room_category[]
    notIn?: $Enums.rate_cards_room_category[]
    not?: NestedEnumrate_cards_room_categoryFilter<$PrismaModel> | $Enums.rate_cards_room_category
  }

  export type Rack_ratesScalarRelationFilter = {
    is?: rack_ratesWhereInput
    isNot?: rack_ratesWhereInput
  }

  export type rate_cardsOrderByRelevanceInput = {
    fields: rate_cardsOrderByRelevanceFieldEnum | rate_cardsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type rate_cardsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    base_rate?: SortOrder
    commission_rate?: SortOrder
    markup_rate?: SortOrder
    discount_amount?: SortOrder
    discount_percent?: SortOrder
    final_rate?: SortOrder
    currency?: SortOrder
    travel_period?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    commission?: SortOrder
    is_active?: SortOrder
    rack_rate_id?: SortOrder
    hotel_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    created_by?: SortOrder
    public_id?: SortOrder
    status?: SortOrder
  }

  export type rate_cardsAvgOrderByAggregateInput = {
    id?: SortOrder
    base_rate?: SortOrder
    commission_rate?: SortOrder
    markup_rate?: SortOrder
    discount_amount?: SortOrder
    discount_percent?: SortOrder
    final_rate?: SortOrder
    commission?: SortOrder
    rack_rate_id?: SortOrder
    hotel_id?: SortOrder
    created_by?: SortOrder
  }

  export type rate_cardsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    base_rate?: SortOrder
    commission_rate?: SortOrder
    markup_rate?: SortOrder
    discount_amount?: SortOrder
    discount_percent?: SortOrder
    final_rate?: SortOrder
    currency?: SortOrder
    travel_period?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    commission?: SortOrder
    is_active?: SortOrder
    rack_rate_id?: SortOrder
    hotel_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    created_by?: SortOrder
    public_id?: SortOrder
    status?: SortOrder
  }

  export type rate_cardsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    base_rate?: SortOrder
    commission_rate?: SortOrder
    markup_rate?: SortOrder
    discount_amount?: SortOrder
    discount_percent?: SortOrder
    final_rate?: SortOrder
    currency?: SortOrder
    travel_period?: SortOrder
    meal_plan?: SortOrder
    room_category?: SortOrder
    commission?: SortOrder
    is_active?: SortOrder
    rack_rate_id?: SortOrder
    hotel_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    created_by?: SortOrder
    public_id?: SortOrder
    status?: SortOrder
  }

  export type rate_cardsSumOrderByAggregateInput = {
    id?: SortOrder
    base_rate?: SortOrder
    commission_rate?: SortOrder
    markup_rate?: SortOrder
    discount_amount?: SortOrder
    discount_percent?: SortOrder
    final_rate?: SortOrder
    commission?: SortOrder
    rack_rate_id?: SortOrder
    hotel_id?: SortOrder
    created_by?: SortOrder
  }

  export type Enumrate_cards_travel_periodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rate_cards_travel_period | Enumrate_cards_travel_periodFieldRefInput<$PrismaModel>
    in?: $Enums.rate_cards_travel_period[]
    notIn?: $Enums.rate_cards_travel_period[]
    not?: NestedEnumrate_cards_travel_periodWithAggregatesFilter<$PrismaModel> | $Enums.rate_cards_travel_period
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrate_cards_travel_periodFilter<$PrismaModel>
    _max?: NestedEnumrate_cards_travel_periodFilter<$PrismaModel>
  }

  export type Enumrate_cards_meal_planWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rate_cards_meal_plan | Enumrate_cards_meal_planFieldRefInput<$PrismaModel>
    in?: $Enums.rate_cards_meal_plan[]
    notIn?: $Enums.rate_cards_meal_plan[]
    not?: NestedEnumrate_cards_meal_planWithAggregatesFilter<$PrismaModel> | $Enums.rate_cards_meal_plan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrate_cards_meal_planFilter<$PrismaModel>
    _max?: NestedEnumrate_cards_meal_planFilter<$PrismaModel>
  }

  export type Enumrate_cards_room_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rate_cards_room_category | Enumrate_cards_room_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.rate_cards_room_category[]
    notIn?: $Enums.rate_cards_room_category[]
    not?: NestedEnumrate_cards_room_categoryWithAggregatesFilter<$PrismaModel> | $Enums.rate_cards_room_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrate_cards_room_categoryFilter<$PrismaModel>
    _max?: NestedEnumrate_cards_room_categoryFilter<$PrismaModel>
  }

  export type remindersOrderByRelevanceInput = {
    fields: remindersOrderByRelevanceFieldEnum | remindersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type remindersCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    reminder_date?: SortOrder
    message?: SortOrder
    is_sent?: SortOrder
    sent_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
  }

  export type remindersAvgOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
  }

  export type remindersMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    reminder_date?: SortOrder
    message?: SortOrder
    is_sent?: SortOrder
    sent_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
  }

  export type remindersMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    reminder_date?: SortOrder
    message?: SortOrder
    is_sent?: SortOrder
    sent_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
  }

  export type remindersSumOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
  }

  export type Enumseasons_period_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.seasons_period_type | Enumseasons_period_typeFieldRefInput<$PrismaModel>
    in?: $Enums.seasons_period_type[]
    notIn?: $Enums.seasons_period_type[]
    not?: NestedEnumseasons_period_typeFilter<$PrismaModel> | $Enums.seasons_period_type
  }

  export type Hotel_policiesScalarRelationFilter = {
    is?: hotel_policiesWhereInput
    isNot?: hotel_policiesWhereInput
  }

  export type seasonsOrderByRelevanceInput = {
    fields: seasonsOrderByRelevanceFieldEnum | seasonsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type seasonsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    period_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    hotel_policy_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
    updated_at?: SortOrder
  }

  export type seasonsAvgOrderByAggregateInput = {
    id?: SortOrder
    hotel_policy_id?: SortOrder
  }

  export type seasonsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    period_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    hotel_policy_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
    updated_at?: SortOrder
  }

  export type seasonsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    period_type?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    hotel_policy_id?: SortOrder
    created_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
    updated_at?: SortOrder
  }

  export type seasonsSumOrderByAggregateInput = {
    id?: SortOrder
    hotel_policy_id?: SortOrder
  }

  export type Enumseasons_period_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.seasons_period_type | Enumseasons_period_typeFieldRefInput<$PrismaModel>
    in?: $Enums.seasons_period_type[]
    notIn?: $Enums.seasons_period_type[]
    not?: NestedEnumseasons_period_typeWithAggregatesFilter<$PrismaModel> | $Enums.seasons_period_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumseasons_period_typeFilter<$PrismaModel>
    _max?: NestedEnumseasons_period_typeFilter<$PrismaModel>
  }

  export type sessionsOrderByRelevanceInput = {
    fields: sessionsOrderByRelevanceFieldEnum | sessionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    session_token?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
    expires_at?: SortOrder
  }

  export type sessionsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    session_token?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
    expires_at?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    session_token?: SortOrder
    user_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
    expires_at?: SortOrder
  }

  export type sessionsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type Enumtransportation_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.transportation_type | Enumtransportation_typeFieldRefInput<$PrismaModel>
    in?: $Enums.transportation_type[]
    notIn?: $Enums.transportation_type[]
    not?: NestedEnumtransportation_typeFilter<$PrismaModel> | $Enums.transportation_type
  }

  export type Enumtransportation_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.transportation_status | Enumtransportation_statusFieldRefInput<$PrismaModel>
    in?: $Enums.transportation_status[]
    notIn?: $Enums.transportation_status[]
    not?: NestedEnumtransportation_statusFilter<$PrismaModel> | $Enums.transportation_status
  }

  export type transportationOrderByRelevanceInput = {
    fields: transportationOrderByRelevanceFieldEnum | transportationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type transportationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    booking_ref?: SortOrder
    departure_date?: SortOrder
    return_date?: SortOrder
    departure_point?: SortOrder
    arrival_point?: SortOrder
    cost?: SortOrder
    booking_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type transportationAvgOrderByAggregateInput = {
    id?: SortOrder
    cost?: SortOrder
    booking_id?: SortOrder
  }

  export type transportationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    booking_ref?: SortOrder
    departure_date?: SortOrder
    return_date?: SortOrder
    departure_point?: SortOrder
    arrival_point?: SortOrder
    cost?: SortOrder
    booking_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type transportationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    booking_ref?: SortOrder
    departure_date?: SortOrder
    return_date?: SortOrder
    departure_point?: SortOrder
    arrival_point?: SortOrder
    cost?: SortOrder
    booking_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
  }

  export type transportationSumOrderByAggregateInput = {
    id?: SortOrder
    cost?: SortOrder
    booking_id?: SortOrder
  }

  export type Enumtransportation_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.transportation_type | Enumtransportation_typeFieldRefInput<$PrismaModel>
    in?: $Enums.transportation_type[]
    notIn?: $Enums.transportation_type[]
    not?: NestedEnumtransportation_typeWithAggregatesFilter<$PrismaModel> | $Enums.transportation_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtransportation_typeFilter<$PrismaModel>
    _max?: NestedEnumtransportation_typeFilter<$PrismaModel>
  }

  export type Enumtransportation_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.transportation_status | Enumtransportation_statusFieldRefInput<$PrismaModel>
    in?: $Enums.transportation_status[]
    notIn?: $Enums.transportation_status[]
    not?: NestedEnumtransportation_statusWithAggregatesFilter<$PrismaModel> | $Enums.transportation_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtransportation_statusFilter<$PrismaModel>
    _max?: NestedEnumtransportation_statusFilter<$PrismaModel>
  }

  export type Enumusers_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.users_status | Enumusers_statusFieldRefInput<$PrismaModel>
    in?: $Enums.users_status[]
    notIn?: $Enums.users_status[]
    not?: NestedEnumusers_statusFilter<$PrismaModel> | $Enums.users_status
  }

  export type AccountsListRelationFilter = {
    every?: accountsWhereInput
    some?: accountsWhereInput
    none?: accountsWhereInput
  }

  export type Events_logListRelationFilter = {
    every?: events_logWhereInput
    some?: events_logWhereInput
    none?: events_logWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type SessionsListRelationFilter = {
    every?: sessionsWhereInput
    some?: sessionsWhereInput
    none?: sessionsWhereInput
  }

  export type Users_branchesListRelationFilter = {
    every?: users_branchesWhereInput
    some?: users_branchesWhereInput
    none?: users_branchesWhereInput
  }

  export type accountsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type events_logOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type users_branchesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelevanceInput = {
    fields: usersOrderByRelevanceFieldEnum | usersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
    password_expiry?: SortOrder
    two_factor_enabled?: SortOrder
    national_id?: SortOrder
    phone?: SortOrder
    branch_id?: SortOrder
    image?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    branch_id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
    password_expiry?: SortOrder
    two_factor_enabled?: SortOrder
    national_id?: SortOrder
    phone?: SortOrder
    branch_id?: SortOrder
    image?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified?: SortOrder
    password?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
    public_id?: SortOrder
    password_expiry?: SortOrder
    two_factor_enabled?: SortOrder
    national_id?: SortOrder
    phone?: SortOrder
    branch_id?: SortOrder
    image?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    branch_id?: SortOrder
  }

  export type Enumusers_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.users_status | Enumusers_statusFieldRefInput<$PrismaModel>
    in?: $Enums.users_status[]
    notIn?: $Enums.users_status[]
    not?: NestedEnumusers_statusWithAggregatesFilter<$PrismaModel> | $Enums.users_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusers_statusFilter<$PrismaModel>
    _max?: NestedEnumusers_statusFilter<$PrismaModel>
  }

  export type ClientsListRelationFilter = {
    every?: clientsWhereInput
    some?: clientsWhereInput
    none?: clientsWhereInput
  }

  export type clientsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type branchesOrderByRelevanceInput = {
    fields: branchesOrderByRelevanceFieldEnum | branchesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type branchesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
  }

  export type branchesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type branchesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
  }

  export type branchesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
  }

  export type branchesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BranchesScalarRelationFilter = {
    is?: branchesWhereInput
    isNot?: branchesWhereInput
  }

  export type users_branchesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    branch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
  }

  export type users_branchesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    branch_id?: SortOrder
  }

  export type users_branchesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    branch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
  }

  export type users_branchesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    branch_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    deleted_at?: SortOrder
    status?: SortOrder
  }

  export type users_branchesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    branch_id?: SortOrder
  }

  export type events_logOrderByRelevanceInput = {
    fields: events_logOrderByRelevanceFieldEnum | events_logOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type events_logCountOrderByAggregateInput = {
    id?: SortOrder
    tbl?: SortOrder
    fld?: SortOrder
    details?: SortOrder
    event_date?: SortOrder
    event_by?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
  }

  export type events_logAvgOrderByAggregateInput = {
    id?: SortOrder
    fld?: SortOrder
    event_by?: SortOrder
  }

  export type events_logMaxOrderByAggregateInput = {
    id?: SortOrder
    tbl?: SortOrder
    fld?: SortOrder
    details?: SortOrder
    event_date?: SortOrder
    event_by?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
  }

  export type events_logMinOrderByAggregateInput = {
    id?: SortOrder
    tbl?: SortOrder
    fld?: SortOrder
    details?: SortOrder
    event_date?: SortOrder
    event_by?: SortOrder
    status?: SortOrder
    deleted_at?: SortOrder
  }

  export type events_logSumOrderByAggregateInput = {
    id?: SortOrder
    fld?: SortOrder
    event_by?: SortOrder
  }

  export type usersCreateNestedOneWithoutAccountsInput = {
    create?: XOR<usersCreateWithoutAccountsInput, usersUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAccountsInput
    connect?: usersWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type usersUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<usersCreateWithoutAccountsInput, usersUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAccountsInput
    upsert?: usersUpsertWithoutAccountsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAccountsInput, usersUpdateWithoutAccountsInput>, usersUncheckedUpdateWithoutAccountsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usersCreateNestedOneWithoutBookingsInput = {
    create?: XOR<usersCreateWithoutBookingsInput, usersUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutBookingsInput
    connect?: usersWhereUniqueInput
  }

  export type clientsCreateNestedOneWithoutBookingsInput = {
    create?: XOR<clientsCreateWithoutBookingsInput, clientsUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: clientsCreateOrConnectWithoutBookingsInput
    connect?: clientsWhereUniqueInput
  }

  export type hotelsCreateNestedOneWithoutBookingsInput = {
    create?: XOR<hotelsCreateWithoutBookingsInput, hotelsUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: hotelsCreateOrConnectWithoutBookingsInput
    connect?: hotelsWhereUniqueInput
  }

  export type invoicesCreateNestedOneWithoutBookingInput = {
    create?: XOR<invoicesCreateWithoutBookingInput, invoicesUncheckedCreateWithoutBookingInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutBookingInput
    connect?: invoicesWhereUniqueInput
  }

  export type quotesCreateNestedOneWithoutBookingInput = {
    create?: XOR<quotesCreateWithoutBookingInput, quotesUncheckedCreateWithoutBookingInput>
    connectOrCreate?: quotesCreateOrConnectWithoutBookingInput
    connect?: quotesWhereUniqueInput
  }

  export type cancellationsCreateNestedManyWithoutBookingInput = {
    create?: XOR<cancellationsCreateWithoutBookingInput, cancellationsUncheckedCreateWithoutBookingInput> | cancellationsCreateWithoutBookingInput[] | cancellationsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: cancellationsCreateOrConnectWithoutBookingInput | cancellationsCreateOrConnectWithoutBookingInput[]
    createMany?: cancellationsCreateManyBookingInputEnvelope
    connect?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
  }

  export type transportationCreateNestedManyWithoutBookingsInput = {
    create?: XOR<transportationCreateWithoutBookingsInput, transportationUncheckedCreateWithoutBookingsInput> | transportationCreateWithoutBookingsInput[] | transportationUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: transportationCreateOrConnectWithoutBookingsInput | transportationCreateOrConnectWithoutBookingsInput[]
    createMany?: transportationCreateManyBookingsInputEnvelope
    connect?: transportationWhereUniqueInput | transportationWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutBookingsInput = {
    create?: XOR<paymentsCreateWithoutBookingsInput, paymentsUncheckedCreateWithoutBookingsInput> | paymentsCreateWithoutBookingsInput[] | paymentsUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutBookingsInput | paymentsCreateOrConnectWithoutBookingsInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type cancellationsUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<cancellationsCreateWithoutBookingInput, cancellationsUncheckedCreateWithoutBookingInput> | cancellationsCreateWithoutBookingInput[] | cancellationsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: cancellationsCreateOrConnectWithoutBookingInput | cancellationsCreateOrConnectWithoutBookingInput[]
    createMany?: cancellationsCreateManyBookingInputEnvelope
    connect?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
  }

  export type transportationUncheckedCreateNestedManyWithoutBookingsInput = {
    create?: XOR<transportationCreateWithoutBookingsInput, transportationUncheckedCreateWithoutBookingsInput> | transportationCreateWithoutBookingsInput[] | transportationUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: transportationCreateOrConnectWithoutBookingsInput | transportationCreateOrConnectWithoutBookingsInput[]
    createMany?: transportationCreateManyBookingsInputEnvelope
    connect?: transportationWhereUniqueInput | transportationWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutBookingsInput = {
    create?: XOR<paymentsCreateWithoutBookingsInput, paymentsUncheckedCreateWithoutBookingsInput> | paymentsCreateWithoutBookingsInput[] | paymentsUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutBookingsInput | paymentsCreateOrConnectWithoutBookingsInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type Enumbookings_meal_planFieldUpdateOperationsInput = {
    set?: $Enums.bookings_meal_plan
  }

  export type Enumbookings_room_categoryFieldUpdateOperationsInput = {
    set?: $Enums.bookings_room_category
  }

  export type Enumbookings_statusFieldUpdateOperationsInput = {
    set?: $Enums.bookings_status
  }

  export type usersUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<usersCreateWithoutBookingsInput, usersUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutBookingsInput
    upsert?: usersUpsertWithoutBookingsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutBookingsInput, usersUpdateWithoutBookingsInput>, usersUncheckedUpdateWithoutBookingsInput>
  }

  export type clientsUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<clientsCreateWithoutBookingsInput, clientsUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: clientsCreateOrConnectWithoutBookingsInput
    upsert?: clientsUpsertWithoutBookingsInput
    connect?: clientsWhereUniqueInput
    update?: XOR<XOR<clientsUpdateToOneWithWhereWithoutBookingsInput, clientsUpdateWithoutBookingsInput>, clientsUncheckedUpdateWithoutBookingsInput>
  }

  export type hotelsUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<hotelsCreateWithoutBookingsInput, hotelsUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: hotelsCreateOrConnectWithoutBookingsInput
    upsert?: hotelsUpsertWithoutBookingsInput
    connect?: hotelsWhereUniqueInput
    update?: XOR<XOR<hotelsUpdateToOneWithWhereWithoutBookingsInput, hotelsUpdateWithoutBookingsInput>, hotelsUncheckedUpdateWithoutBookingsInput>
  }

  export type invoicesUpdateOneWithoutBookingNestedInput = {
    create?: XOR<invoicesCreateWithoutBookingInput, invoicesUncheckedCreateWithoutBookingInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutBookingInput
    upsert?: invoicesUpsertWithoutBookingInput
    disconnect?: invoicesWhereInput | boolean
    delete?: invoicesWhereInput | boolean
    connect?: invoicesWhereUniqueInput
    update?: XOR<XOR<invoicesUpdateToOneWithWhereWithoutBookingInput, invoicesUpdateWithoutBookingInput>, invoicesUncheckedUpdateWithoutBookingInput>
  }

  export type quotesUpdateOneRequiredWithoutBookingNestedInput = {
    create?: XOR<quotesCreateWithoutBookingInput, quotesUncheckedCreateWithoutBookingInput>
    connectOrCreate?: quotesCreateOrConnectWithoutBookingInput
    upsert?: quotesUpsertWithoutBookingInput
    connect?: quotesWhereUniqueInput
    update?: XOR<XOR<quotesUpdateToOneWithWhereWithoutBookingInput, quotesUpdateWithoutBookingInput>, quotesUncheckedUpdateWithoutBookingInput>
  }

  export type cancellationsUpdateManyWithoutBookingNestedInput = {
    create?: XOR<cancellationsCreateWithoutBookingInput, cancellationsUncheckedCreateWithoutBookingInput> | cancellationsCreateWithoutBookingInput[] | cancellationsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: cancellationsCreateOrConnectWithoutBookingInput | cancellationsCreateOrConnectWithoutBookingInput[]
    upsert?: cancellationsUpsertWithWhereUniqueWithoutBookingInput | cancellationsUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: cancellationsCreateManyBookingInputEnvelope
    set?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    disconnect?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    delete?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    connect?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    update?: cancellationsUpdateWithWhereUniqueWithoutBookingInput | cancellationsUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: cancellationsUpdateManyWithWhereWithoutBookingInput | cancellationsUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: cancellationsScalarWhereInput | cancellationsScalarWhereInput[]
  }

  export type transportationUpdateManyWithoutBookingsNestedInput = {
    create?: XOR<transportationCreateWithoutBookingsInput, transportationUncheckedCreateWithoutBookingsInput> | transportationCreateWithoutBookingsInput[] | transportationUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: transportationCreateOrConnectWithoutBookingsInput | transportationCreateOrConnectWithoutBookingsInput[]
    upsert?: transportationUpsertWithWhereUniqueWithoutBookingsInput | transportationUpsertWithWhereUniqueWithoutBookingsInput[]
    createMany?: transportationCreateManyBookingsInputEnvelope
    set?: transportationWhereUniqueInput | transportationWhereUniqueInput[]
    disconnect?: transportationWhereUniqueInput | transportationWhereUniqueInput[]
    delete?: transportationWhereUniqueInput | transportationWhereUniqueInput[]
    connect?: transportationWhereUniqueInput | transportationWhereUniqueInput[]
    update?: transportationUpdateWithWhereUniqueWithoutBookingsInput | transportationUpdateWithWhereUniqueWithoutBookingsInput[]
    updateMany?: transportationUpdateManyWithWhereWithoutBookingsInput | transportationUpdateManyWithWhereWithoutBookingsInput[]
    deleteMany?: transportationScalarWhereInput | transportationScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutBookingsNestedInput = {
    create?: XOR<paymentsCreateWithoutBookingsInput, paymentsUncheckedCreateWithoutBookingsInput> | paymentsCreateWithoutBookingsInput[] | paymentsUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutBookingsInput | paymentsCreateOrConnectWithoutBookingsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutBookingsInput | paymentsUpsertWithWhereUniqueWithoutBookingsInput[]
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutBookingsInput | paymentsUpdateWithWhereUniqueWithoutBookingsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutBookingsInput | paymentsUpdateManyWithWhereWithoutBookingsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type cancellationsUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<cancellationsCreateWithoutBookingInput, cancellationsUncheckedCreateWithoutBookingInput> | cancellationsCreateWithoutBookingInput[] | cancellationsUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: cancellationsCreateOrConnectWithoutBookingInput | cancellationsCreateOrConnectWithoutBookingInput[]
    upsert?: cancellationsUpsertWithWhereUniqueWithoutBookingInput | cancellationsUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: cancellationsCreateManyBookingInputEnvelope
    set?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    disconnect?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    delete?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    connect?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    update?: cancellationsUpdateWithWhereUniqueWithoutBookingInput | cancellationsUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: cancellationsUpdateManyWithWhereWithoutBookingInput | cancellationsUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: cancellationsScalarWhereInput | cancellationsScalarWhereInput[]
  }

  export type transportationUncheckedUpdateManyWithoutBookingsNestedInput = {
    create?: XOR<transportationCreateWithoutBookingsInput, transportationUncheckedCreateWithoutBookingsInput> | transportationCreateWithoutBookingsInput[] | transportationUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: transportationCreateOrConnectWithoutBookingsInput | transportationCreateOrConnectWithoutBookingsInput[]
    upsert?: transportationUpsertWithWhereUniqueWithoutBookingsInput | transportationUpsertWithWhereUniqueWithoutBookingsInput[]
    createMany?: transportationCreateManyBookingsInputEnvelope
    set?: transportationWhereUniqueInput | transportationWhereUniqueInput[]
    disconnect?: transportationWhereUniqueInput | transportationWhereUniqueInput[]
    delete?: transportationWhereUniqueInput | transportationWhereUniqueInput[]
    connect?: transportationWhereUniqueInput | transportationWhereUniqueInput[]
    update?: transportationUpdateWithWhereUniqueWithoutBookingsInput | transportationUpdateWithWhereUniqueWithoutBookingsInput[]
    updateMany?: transportationUpdateManyWithWhereWithoutBookingsInput | transportationUpdateManyWithWhereWithoutBookingsInput[]
    deleteMany?: transportationScalarWhereInput | transportationScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutBookingsNestedInput = {
    create?: XOR<paymentsCreateWithoutBookingsInput, paymentsUncheckedCreateWithoutBookingsInput> | paymentsCreateWithoutBookingsInput[] | paymentsUncheckedCreateWithoutBookingsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutBookingsInput | paymentsCreateOrConnectWithoutBookingsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutBookingsInput | paymentsUpsertWithWhereUniqueWithoutBookingsInput[]
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutBookingsInput | paymentsUpdateWithWhereUniqueWithoutBookingsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutBookingsInput | paymentsUpdateManyWithWhereWithoutBookingsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type bookingsCreateNestedOneWithoutCancellationsInput = {
    create?: XOR<bookingsCreateWithoutCancellationsInput, bookingsUncheckedCreateWithoutCancellationsInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutCancellationsInput
    connect?: bookingsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCancellationsInput = {
    create?: XOR<usersCreateWithoutCancellationsInput, usersUncheckedCreateWithoutCancellationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCancellationsInput
    connect?: usersWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Enumshared_statusFieldUpdateOperationsInput = {
    set?: $Enums.shared_status
  }

  export type bookingsUpdateOneRequiredWithoutCancellationsNestedInput = {
    create?: XOR<bookingsCreateWithoutCancellationsInput, bookingsUncheckedCreateWithoutCancellationsInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutCancellationsInput
    upsert?: bookingsUpsertWithoutCancellationsInput
    connect?: bookingsWhereUniqueInput
    update?: XOR<XOR<bookingsUpdateToOneWithWhereWithoutCancellationsInput, bookingsUpdateWithoutCancellationsInput>, bookingsUncheckedUpdateWithoutCancellationsInput>
  }

  export type usersUpdateOneRequiredWithoutCancellationsNestedInput = {
    create?: XOR<usersCreateWithoutCancellationsInput, usersUncheckedCreateWithoutCancellationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCancellationsInput
    upsert?: usersUpsertWithoutCancellationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCancellationsInput, usersUpdateWithoutCancellationsInput>, usersUncheckedUpdateWithoutCancellationsInput>
  }

  export type bookingsCreateNestedManyWithoutClientInput = {
    create?: XOR<bookingsCreateWithoutClientInput, bookingsUncheckedCreateWithoutClientInput> | bookingsCreateWithoutClientInput[] | bookingsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutClientInput | bookingsCreateOrConnectWithoutClientInput[]
    createMany?: bookingsCreateManyClientInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type branchesCreateNestedOneWithoutClientsInput = {
    create?: XOR<branchesCreateWithoutClientsInput, branchesUncheckedCreateWithoutClientsInput>
    connectOrCreate?: branchesCreateOrConnectWithoutClientsInput
    connect?: branchesWhereUniqueInput
  }

  export type invoicesCreateNestedManyWithoutClientInput = {
    create?: XOR<invoicesCreateWithoutClientInput, invoicesUncheckedCreateWithoutClientInput> | invoicesCreateWithoutClientInput[] | invoicesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutClientInput | invoicesCreateOrConnectWithoutClientInput[]
    createMany?: invoicesCreateManyClientInputEnvelope
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
  }

  export type quotesCreateNestedManyWithoutClientInput = {
    create?: XOR<quotesCreateWithoutClientInput, quotesUncheckedCreateWithoutClientInput> | quotesCreateWithoutClientInput[] | quotesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: quotesCreateOrConnectWithoutClientInput | quotesCreateOrConnectWithoutClientInput[]
    createMany?: quotesCreateManyClientInputEnvelope
    connect?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
  }

  export type bookingsUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<bookingsCreateWithoutClientInput, bookingsUncheckedCreateWithoutClientInput> | bookingsCreateWithoutClientInput[] | bookingsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutClientInput | bookingsCreateOrConnectWithoutClientInput[]
    createMany?: bookingsCreateManyClientInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type invoicesUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<invoicesCreateWithoutClientInput, invoicesUncheckedCreateWithoutClientInput> | invoicesCreateWithoutClientInput[] | invoicesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutClientInput | invoicesCreateOrConnectWithoutClientInput[]
    createMany?: invoicesCreateManyClientInputEnvelope
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
  }

  export type quotesUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<quotesCreateWithoutClientInput, quotesUncheckedCreateWithoutClientInput> | quotesCreateWithoutClientInput[] | quotesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: quotesCreateOrConnectWithoutClientInput | quotesCreateOrConnectWithoutClientInput[]
    createMany?: quotesCreateManyClientInputEnvelope
    connect?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
  }

  export type bookingsUpdateManyWithoutClientNestedInput = {
    create?: XOR<bookingsCreateWithoutClientInput, bookingsUncheckedCreateWithoutClientInput> | bookingsCreateWithoutClientInput[] | bookingsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutClientInput | bookingsCreateOrConnectWithoutClientInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutClientInput | bookingsUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: bookingsCreateManyClientInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutClientInput | bookingsUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutClientInput | bookingsUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type branchesUpdateOneWithoutClientsNestedInput = {
    create?: XOR<branchesCreateWithoutClientsInput, branchesUncheckedCreateWithoutClientsInput>
    connectOrCreate?: branchesCreateOrConnectWithoutClientsInput
    upsert?: branchesUpsertWithoutClientsInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutClientsInput, branchesUpdateWithoutClientsInput>, branchesUncheckedUpdateWithoutClientsInput>
  }

  export type invoicesUpdateManyWithoutClientNestedInput = {
    create?: XOR<invoicesCreateWithoutClientInput, invoicesUncheckedCreateWithoutClientInput> | invoicesCreateWithoutClientInput[] | invoicesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutClientInput | invoicesCreateOrConnectWithoutClientInput[]
    upsert?: invoicesUpsertWithWhereUniqueWithoutClientInput | invoicesUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: invoicesCreateManyClientInputEnvelope
    set?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    disconnect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    delete?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    update?: invoicesUpdateWithWhereUniqueWithoutClientInput | invoicesUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: invoicesUpdateManyWithWhereWithoutClientInput | invoicesUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
  }

  export type quotesUpdateManyWithoutClientNestedInput = {
    create?: XOR<quotesCreateWithoutClientInput, quotesUncheckedCreateWithoutClientInput> | quotesCreateWithoutClientInput[] | quotesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: quotesCreateOrConnectWithoutClientInput | quotesCreateOrConnectWithoutClientInput[]
    upsert?: quotesUpsertWithWhereUniqueWithoutClientInput | quotesUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: quotesCreateManyClientInputEnvelope
    set?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    disconnect?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    delete?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    connect?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    update?: quotesUpdateWithWhereUniqueWithoutClientInput | quotesUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: quotesUpdateManyWithWhereWithoutClientInput | quotesUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: quotesScalarWhereInput | quotesScalarWhereInput[]
  }

  export type bookingsUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<bookingsCreateWithoutClientInput, bookingsUncheckedCreateWithoutClientInput> | bookingsCreateWithoutClientInput[] | bookingsUncheckedCreateWithoutClientInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutClientInput | bookingsCreateOrConnectWithoutClientInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutClientInput | bookingsUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: bookingsCreateManyClientInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutClientInput | bookingsUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutClientInput | bookingsUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type invoicesUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<invoicesCreateWithoutClientInput, invoicesUncheckedCreateWithoutClientInput> | invoicesCreateWithoutClientInput[] | invoicesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutClientInput | invoicesCreateOrConnectWithoutClientInput[]
    upsert?: invoicesUpsertWithWhereUniqueWithoutClientInput | invoicesUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: invoicesCreateManyClientInputEnvelope
    set?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    disconnect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    delete?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    update?: invoicesUpdateWithWhereUniqueWithoutClientInput | invoicesUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: invoicesUpdateManyWithWhereWithoutClientInput | invoicesUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
  }

  export type quotesUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<quotesCreateWithoutClientInput, quotesUncheckedCreateWithoutClientInput> | quotesCreateWithoutClientInput[] | quotesUncheckedCreateWithoutClientInput[]
    connectOrCreate?: quotesCreateOrConnectWithoutClientInput | quotesCreateOrConnectWithoutClientInput[]
    upsert?: quotesUpsertWithWhereUniqueWithoutClientInput | quotesUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: quotesCreateManyClientInputEnvelope
    set?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    disconnect?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    delete?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    connect?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    update?: quotesUpdateWithWhereUniqueWithoutClientInput | quotesUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: quotesUpdateManyWithWhereWithoutClientInput | quotesUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: quotesScalarWhereInput | quotesScalarWhereInput[]
  }

  export type hotelsCreateNestedOneWithoutHotel_policiesInput = {
    create?: XOR<hotelsCreateWithoutHotel_policiesInput, hotelsUncheckedCreateWithoutHotel_policiesInput>
    connectOrCreate?: hotelsCreateOrConnectWithoutHotel_policiesInput
    connect?: hotelsWhereUniqueInput
  }

  export type seasonsCreateNestedManyWithoutHotel_policiesInput = {
    create?: XOR<seasonsCreateWithoutHotel_policiesInput, seasonsUncheckedCreateWithoutHotel_policiesInput> | seasonsCreateWithoutHotel_policiesInput[] | seasonsUncheckedCreateWithoutHotel_policiesInput[]
    connectOrCreate?: seasonsCreateOrConnectWithoutHotel_policiesInput | seasonsCreateOrConnectWithoutHotel_policiesInput[]
    createMany?: seasonsCreateManyHotel_policiesInputEnvelope
    connect?: seasonsWhereUniqueInput | seasonsWhereUniqueInput[]
  }

  export type seasonsUncheckedCreateNestedManyWithoutHotel_policiesInput = {
    create?: XOR<seasonsCreateWithoutHotel_policiesInput, seasonsUncheckedCreateWithoutHotel_policiesInput> | seasonsCreateWithoutHotel_policiesInput[] | seasonsUncheckedCreateWithoutHotel_policiesInput[]
    connectOrCreate?: seasonsCreateOrConnectWithoutHotel_policiesInput | seasonsCreateOrConnectWithoutHotel_policiesInput[]
    createMany?: seasonsCreateManyHotel_policiesInputEnvelope
    connect?: seasonsWhereUniqueInput | seasonsWhereUniqueInput[]
  }

  export type hotelsUpdateOneRequiredWithoutHotel_policiesNestedInput = {
    create?: XOR<hotelsCreateWithoutHotel_policiesInput, hotelsUncheckedCreateWithoutHotel_policiesInput>
    connectOrCreate?: hotelsCreateOrConnectWithoutHotel_policiesInput
    upsert?: hotelsUpsertWithoutHotel_policiesInput
    connect?: hotelsWhereUniqueInput
    update?: XOR<XOR<hotelsUpdateToOneWithWhereWithoutHotel_policiesInput, hotelsUpdateWithoutHotel_policiesInput>, hotelsUncheckedUpdateWithoutHotel_policiesInput>
  }

  export type seasonsUpdateManyWithoutHotel_policiesNestedInput = {
    create?: XOR<seasonsCreateWithoutHotel_policiesInput, seasonsUncheckedCreateWithoutHotel_policiesInput> | seasonsCreateWithoutHotel_policiesInput[] | seasonsUncheckedCreateWithoutHotel_policiesInput[]
    connectOrCreate?: seasonsCreateOrConnectWithoutHotel_policiesInput | seasonsCreateOrConnectWithoutHotel_policiesInput[]
    upsert?: seasonsUpsertWithWhereUniqueWithoutHotel_policiesInput | seasonsUpsertWithWhereUniqueWithoutHotel_policiesInput[]
    createMany?: seasonsCreateManyHotel_policiesInputEnvelope
    set?: seasonsWhereUniqueInput | seasonsWhereUniqueInput[]
    disconnect?: seasonsWhereUniqueInput | seasonsWhereUniqueInput[]
    delete?: seasonsWhereUniqueInput | seasonsWhereUniqueInput[]
    connect?: seasonsWhereUniqueInput | seasonsWhereUniqueInput[]
    update?: seasonsUpdateWithWhereUniqueWithoutHotel_policiesInput | seasonsUpdateWithWhereUniqueWithoutHotel_policiesInput[]
    updateMany?: seasonsUpdateManyWithWhereWithoutHotel_policiesInput | seasonsUpdateManyWithWhereWithoutHotel_policiesInput[]
    deleteMany?: seasonsScalarWhereInput | seasonsScalarWhereInput[]
  }

  export type seasonsUncheckedUpdateManyWithoutHotel_policiesNestedInput = {
    create?: XOR<seasonsCreateWithoutHotel_policiesInput, seasonsUncheckedCreateWithoutHotel_policiesInput> | seasonsCreateWithoutHotel_policiesInput[] | seasonsUncheckedCreateWithoutHotel_policiesInput[]
    connectOrCreate?: seasonsCreateOrConnectWithoutHotel_policiesInput | seasonsCreateOrConnectWithoutHotel_policiesInput[]
    upsert?: seasonsUpsertWithWhereUniqueWithoutHotel_policiesInput | seasonsUpsertWithWhereUniqueWithoutHotel_policiesInput[]
    createMany?: seasonsCreateManyHotel_policiesInputEnvelope
    set?: seasonsWhereUniqueInput | seasonsWhereUniqueInput[]
    disconnect?: seasonsWhereUniqueInput | seasonsWhereUniqueInput[]
    delete?: seasonsWhereUniqueInput | seasonsWhereUniqueInput[]
    connect?: seasonsWhereUniqueInput | seasonsWhereUniqueInput[]
    update?: seasonsUpdateWithWhereUniqueWithoutHotel_policiesInput | seasonsUpdateWithWhereUniqueWithoutHotel_policiesInput[]
    updateMany?: seasonsUpdateManyWithWhereWithoutHotel_policiesInput | seasonsUpdateManyWithWhereWithoutHotel_policiesInput[]
    deleteMany?: seasonsScalarWhereInput | seasonsScalarWhereInput[]
  }

  export type bookingsCreateNestedManyWithoutHotelInput = {
    create?: XOR<bookingsCreateWithoutHotelInput, bookingsUncheckedCreateWithoutHotelInput> | bookingsCreateWithoutHotelInput[] | bookingsUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutHotelInput | bookingsCreateOrConnectWithoutHotelInput[]
    createMany?: bookingsCreateManyHotelInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type hotel_policiesCreateNestedManyWithoutHotelInput = {
    create?: XOR<hotel_policiesCreateWithoutHotelInput, hotel_policiesUncheckedCreateWithoutHotelInput> | hotel_policiesCreateWithoutHotelInput[] | hotel_policiesUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: hotel_policiesCreateOrConnectWithoutHotelInput | hotel_policiesCreateOrConnectWithoutHotelInput[]
    createMany?: hotel_policiesCreateManyHotelInputEnvelope
    connect?: hotel_policiesWhereUniqueInput | hotel_policiesWhereUniqueInput[]
  }

  export type rack_ratesCreateNestedManyWithoutHotelInput = {
    create?: XOR<rack_ratesCreateWithoutHotelInput, rack_ratesUncheckedCreateWithoutHotelInput> | rack_ratesCreateWithoutHotelInput[] | rack_ratesUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: rack_ratesCreateOrConnectWithoutHotelInput | rack_ratesCreateOrConnectWithoutHotelInput[]
    createMany?: rack_ratesCreateManyHotelInputEnvelope
    connect?: rack_ratesWhereUniqueInput | rack_ratesWhereUniqueInput[]
  }

  export type rate_cardsCreateNestedManyWithoutHotelsInput = {
    create?: XOR<rate_cardsCreateWithoutHotelsInput, rate_cardsUncheckedCreateWithoutHotelsInput> | rate_cardsCreateWithoutHotelsInput[] | rate_cardsUncheckedCreateWithoutHotelsInput[]
    connectOrCreate?: rate_cardsCreateOrConnectWithoutHotelsInput | rate_cardsCreateOrConnectWithoutHotelsInput[]
    createMany?: rate_cardsCreateManyHotelsInputEnvelope
    connect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
  }

  export type bookingsUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<bookingsCreateWithoutHotelInput, bookingsUncheckedCreateWithoutHotelInput> | bookingsCreateWithoutHotelInput[] | bookingsUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutHotelInput | bookingsCreateOrConnectWithoutHotelInput[]
    createMany?: bookingsCreateManyHotelInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type hotel_policiesUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<hotel_policiesCreateWithoutHotelInput, hotel_policiesUncheckedCreateWithoutHotelInput> | hotel_policiesCreateWithoutHotelInput[] | hotel_policiesUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: hotel_policiesCreateOrConnectWithoutHotelInput | hotel_policiesCreateOrConnectWithoutHotelInput[]
    createMany?: hotel_policiesCreateManyHotelInputEnvelope
    connect?: hotel_policiesWhereUniqueInput | hotel_policiesWhereUniqueInput[]
  }

  export type rack_ratesUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<rack_ratesCreateWithoutHotelInput, rack_ratesUncheckedCreateWithoutHotelInput> | rack_ratesCreateWithoutHotelInput[] | rack_ratesUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: rack_ratesCreateOrConnectWithoutHotelInput | rack_ratesCreateOrConnectWithoutHotelInput[]
    createMany?: rack_ratesCreateManyHotelInputEnvelope
    connect?: rack_ratesWhereUniqueInput | rack_ratesWhereUniqueInput[]
  }

  export type rate_cardsUncheckedCreateNestedManyWithoutHotelsInput = {
    create?: XOR<rate_cardsCreateWithoutHotelsInput, rate_cardsUncheckedCreateWithoutHotelsInput> | rate_cardsCreateWithoutHotelsInput[] | rate_cardsUncheckedCreateWithoutHotelsInput[]
    connectOrCreate?: rate_cardsCreateOrConnectWithoutHotelsInput | rate_cardsCreateOrConnectWithoutHotelsInput[]
    createMany?: rate_cardsCreateManyHotelsInputEnvelope
    connect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type bookingsUpdateManyWithoutHotelNestedInput = {
    create?: XOR<bookingsCreateWithoutHotelInput, bookingsUncheckedCreateWithoutHotelInput> | bookingsCreateWithoutHotelInput[] | bookingsUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutHotelInput | bookingsCreateOrConnectWithoutHotelInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutHotelInput | bookingsUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: bookingsCreateManyHotelInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutHotelInput | bookingsUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutHotelInput | bookingsUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type hotel_policiesUpdateManyWithoutHotelNestedInput = {
    create?: XOR<hotel_policiesCreateWithoutHotelInput, hotel_policiesUncheckedCreateWithoutHotelInput> | hotel_policiesCreateWithoutHotelInput[] | hotel_policiesUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: hotel_policiesCreateOrConnectWithoutHotelInput | hotel_policiesCreateOrConnectWithoutHotelInput[]
    upsert?: hotel_policiesUpsertWithWhereUniqueWithoutHotelInput | hotel_policiesUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: hotel_policiesCreateManyHotelInputEnvelope
    set?: hotel_policiesWhereUniqueInput | hotel_policiesWhereUniqueInput[]
    disconnect?: hotel_policiesWhereUniqueInput | hotel_policiesWhereUniqueInput[]
    delete?: hotel_policiesWhereUniqueInput | hotel_policiesWhereUniqueInput[]
    connect?: hotel_policiesWhereUniqueInput | hotel_policiesWhereUniqueInput[]
    update?: hotel_policiesUpdateWithWhereUniqueWithoutHotelInput | hotel_policiesUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: hotel_policiesUpdateManyWithWhereWithoutHotelInput | hotel_policiesUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: hotel_policiesScalarWhereInput | hotel_policiesScalarWhereInput[]
  }

  export type rack_ratesUpdateManyWithoutHotelNestedInput = {
    create?: XOR<rack_ratesCreateWithoutHotelInput, rack_ratesUncheckedCreateWithoutHotelInput> | rack_ratesCreateWithoutHotelInput[] | rack_ratesUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: rack_ratesCreateOrConnectWithoutHotelInput | rack_ratesCreateOrConnectWithoutHotelInput[]
    upsert?: rack_ratesUpsertWithWhereUniqueWithoutHotelInput | rack_ratesUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: rack_ratesCreateManyHotelInputEnvelope
    set?: rack_ratesWhereUniqueInput | rack_ratesWhereUniqueInput[]
    disconnect?: rack_ratesWhereUniqueInput | rack_ratesWhereUniqueInput[]
    delete?: rack_ratesWhereUniqueInput | rack_ratesWhereUniqueInput[]
    connect?: rack_ratesWhereUniqueInput | rack_ratesWhereUniqueInput[]
    update?: rack_ratesUpdateWithWhereUniqueWithoutHotelInput | rack_ratesUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: rack_ratesUpdateManyWithWhereWithoutHotelInput | rack_ratesUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: rack_ratesScalarWhereInput | rack_ratesScalarWhereInput[]
  }

  export type rate_cardsUpdateManyWithoutHotelsNestedInput = {
    create?: XOR<rate_cardsCreateWithoutHotelsInput, rate_cardsUncheckedCreateWithoutHotelsInput> | rate_cardsCreateWithoutHotelsInput[] | rate_cardsUncheckedCreateWithoutHotelsInput[]
    connectOrCreate?: rate_cardsCreateOrConnectWithoutHotelsInput | rate_cardsCreateOrConnectWithoutHotelsInput[]
    upsert?: rate_cardsUpsertWithWhereUniqueWithoutHotelsInput | rate_cardsUpsertWithWhereUniqueWithoutHotelsInput[]
    createMany?: rate_cardsCreateManyHotelsInputEnvelope
    set?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    disconnect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    delete?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    connect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    update?: rate_cardsUpdateWithWhereUniqueWithoutHotelsInput | rate_cardsUpdateWithWhereUniqueWithoutHotelsInput[]
    updateMany?: rate_cardsUpdateManyWithWhereWithoutHotelsInput | rate_cardsUpdateManyWithWhereWithoutHotelsInput[]
    deleteMany?: rate_cardsScalarWhereInput | rate_cardsScalarWhereInput[]
  }

  export type bookingsUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<bookingsCreateWithoutHotelInput, bookingsUncheckedCreateWithoutHotelInput> | bookingsCreateWithoutHotelInput[] | bookingsUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutHotelInput | bookingsCreateOrConnectWithoutHotelInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutHotelInput | bookingsUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: bookingsCreateManyHotelInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutHotelInput | bookingsUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutHotelInput | bookingsUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type hotel_policiesUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<hotel_policiesCreateWithoutHotelInput, hotel_policiesUncheckedCreateWithoutHotelInput> | hotel_policiesCreateWithoutHotelInput[] | hotel_policiesUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: hotel_policiesCreateOrConnectWithoutHotelInput | hotel_policiesCreateOrConnectWithoutHotelInput[]
    upsert?: hotel_policiesUpsertWithWhereUniqueWithoutHotelInput | hotel_policiesUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: hotel_policiesCreateManyHotelInputEnvelope
    set?: hotel_policiesWhereUniqueInput | hotel_policiesWhereUniqueInput[]
    disconnect?: hotel_policiesWhereUniqueInput | hotel_policiesWhereUniqueInput[]
    delete?: hotel_policiesWhereUniqueInput | hotel_policiesWhereUniqueInput[]
    connect?: hotel_policiesWhereUniqueInput | hotel_policiesWhereUniqueInput[]
    update?: hotel_policiesUpdateWithWhereUniqueWithoutHotelInput | hotel_policiesUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: hotel_policiesUpdateManyWithWhereWithoutHotelInput | hotel_policiesUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: hotel_policiesScalarWhereInput | hotel_policiesScalarWhereInput[]
  }

  export type rack_ratesUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<rack_ratesCreateWithoutHotelInput, rack_ratesUncheckedCreateWithoutHotelInput> | rack_ratesCreateWithoutHotelInput[] | rack_ratesUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: rack_ratesCreateOrConnectWithoutHotelInput | rack_ratesCreateOrConnectWithoutHotelInput[]
    upsert?: rack_ratesUpsertWithWhereUniqueWithoutHotelInput | rack_ratesUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: rack_ratesCreateManyHotelInputEnvelope
    set?: rack_ratesWhereUniqueInput | rack_ratesWhereUniqueInput[]
    disconnect?: rack_ratesWhereUniqueInput | rack_ratesWhereUniqueInput[]
    delete?: rack_ratesWhereUniqueInput | rack_ratesWhereUniqueInput[]
    connect?: rack_ratesWhereUniqueInput | rack_ratesWhereUniqueInput[]
    update?: rack_ratesUpdateWithWhereUniqueWithoutHotelInput | rack_ratesUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: rack_ratesUpdateManyWithWhereWithoutHotelInput | rack_ratesUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: rack_ratesScalarWhereInput | rack_ratesScalarWhereInput[]
  }

  export type rate_cardsUncheckedUpdateManyWithoutHotelsNestedInput = {
    create?: XOR<rate_cardsCreateWithoutHotelsInput, rate_cardsUncheckedCreateWithoutHotelsInput> | rate_cardsCreateWithoutHotelsInput[] | rate_cardsUncheckedCreateWithoutHotelsInput[]
    connectOrCreate?: rate_cardsCreateOrConnectWithoutHotelsInput | rate_cardsCreateOrConnectWithoutHotelsInput[]
    upsert?: rate_cardsUpsertWithWhereUniqueWithoutHotelsInput | rate_cardsUpsertWithWhereUniqueWithoutHotelsInput[]
    createMany?: rate_cardsCreateManyHotelsInputEnvelope
    set?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    disconnect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    delete?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    connect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    update?: rate_cardsUpdateWithWhereUniqueWithoutHotelsInput | rate_cardsUpdateWithWhereUniqueWithoutHotelsInput[]
    updateMany?: rate_cardsUpdateManyWithWhereWithoutHotelsInput | rate_cardsUpdateManyWithWhereWithoutHotelsInput[]
    deleteMany?: rate_cardsScalarWhereInput | rate_cardsScalarWhereInput[]
  }

  export type bookingsCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<bookingsCreateWithoutInvoiceInput, bookingsUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutInvoiceInput
    connect?: bookingsWhereUniqueInput
  }

  export type clientsCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<clientsCreateWithoutInvoicesInput, clientsUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: clientsCreateOrConnectWithoutInvoicesInput
    connect?: clientsWhereUniqueInput
  }

  export type quotesCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<quotesCreateWithoutInvoiceInput, quotesUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: quotesCreateOrConnectWithoutInvoiceInput
    connect?: quotesWhereUniqueInput
  }

  export type paymentsCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<paymentsCreateWithoutInvoiceInput, paymentsUncheckedCreateWithoutInvoiceInput> | paymentsCreateWithoutInvoiceInput[] | paymentsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutInvoiceInput | paymentsCreateOrConnectWithoutInvoiceInput[]
    createMany?: paymentsCreateManyInvoiceInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type remindersCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<remindersCreateWithoutInvoicesInput, remindersUncheckedCreateWithoutInvoicesInput> | remindersCreateWithoutInvoicesInput[] | remindersUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: remindersCreateOrConnectWithoutInvoicesInput | remindersCreateOrConnectWithoutInvoicesInput[]
    createMany?: remindersCreateManyInvoicesInputEnvelope
    connect?: remindersWhereUniqueInput | remindersWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<usersCreateWithoutInvoicesInput, usersUncheckedCreateWithoutInvoicesInput> | usersCreateWithoutInvoicesInput[] | usersUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutInvoicesInput | usersCreateOrConnectWithoutInvoicesInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type bookingsUncheckedCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<bookingsCreateWithoutInvoiceInput, bookingsUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutInvoiceInput
    connect?: bookingsWhereUniqueInput
  }

  export type paymentsUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<paymentsCreateWithoutInvoiceInput, paymentsUncheckedCreateWithoutInvoiceInput> | paymentsCreateWithoutInvoiceInput[] | paymentsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutInvoiceInput | paymentsCreateOrConnectWithoutInvoiceInput[]
    createMany?: paymentsCreateManyInvoiceInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type remindersUncheckedCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<remindersCreateWithoutInvoicesInput, remindersUncheckedCreateWithoutInvoicesInput> | remindersCreateWithoutInvoicesInput[] | remindersUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: remindersCreateOrConnectWithoutInvoicesInput | remindersCreateOrConnectWithoutInvoicesInput[]
    createMany?: remindersCreateManyInvoicesInputEnvelope
    connect?: remindersWhereUniqueInput | remindersWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutInvoicesInput = {
    create?: XOR<usersCreateWithoutInvoicesInput, usersUncheckedCreateWithoutInvoicesInput> | usersCreateWithoutInvoicesInput[] | usersUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutInvoicesInput | usersCreateOrConnectWithoutInvoicesInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type Enuminvoices_statusFieldUpdateOperationsInput = {
    set?: $Enums.invoices_status
  }

  export type bookingsUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<bookingsCreateWithoutInvoiceInput, bookingsUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutInvoiceInput
    upsert?: bookingsUpsertWithoutInvoiceInput
    disconnect?: bookingsWhereInput | boolean
    delete?: bookingsWhereInput | boolean
    connect?: bookingsWhereUniqueInput
    update?: XOR<XOR<bookingsUpdateToOneWithWhereWithoutInvoiceInput, bookingsUpdateWithoutInvoiceInput>, bookingsUncheckedUpdateWithoutInvoiceInput>
  }

  export type clientsUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<clientsCreateWithoutInvoicesInput, clientsUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: clientsCreateOrConnectWithoutInvoicesInput
    upsert?: clientsUpsertWithoutInvoicesInput
    connect?: clientsWhereUniqueInput
    update?: XOR<XOR<clientsUpdateToOneWithWhereWithoutInvoicesInput, clientsUpdateWithoutInvoicesInput>, clientsUncheckedUpdateWithoutInvoicesInput>
  }

  export type quotesUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<quotesCreateWithoutInvoiceInput, quotesUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: quotesCreateOrConnectWithoutInvoiceInput
    upsert?: quotesUpsertWithoutInvoiceInput
    connect?: quotesWhereUniqueInput
    update?: XOR<XOR<quotesUpdateToOneWithWhereWithoutInvoiceInput, quotesUpdateWithoutInvoiceInput>, quotesUncheckedUpdateWithoutInvoiceInput>
  }

  export type paymentsUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<paymentsCreateWithoutInvoiceInput, paymentsUncheckedCreateWithoutInvoiceInput> | paymentsCreateWithoutInvoiceInput[] | paymentsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutInvoiceInput | paymentsCreateOrConnectWithoutInvoiceInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutInvoiceInput | paymentsUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: paymentsCreateManyInvoiceInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutInvoiceInput | paymentsUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutInvoiceInput | paymentsUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type remindersUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<remindersCreateWithoutInvoicesInput, remindersUncheckedCreateWithoutInvoicesInput> | remindersCreateWithoutInvoicesInput[] | remindersUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: remindersCreateOrConnectWithoutInvoicesInput | remindersCreateOrConnectWithoutInvoicesInput[]
    upsert?: remindersUpsertWithWhereUniqueWithoutInvoicesInput | remindersUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: remindersCreateManyInvoicesInputEnvelope
    set?: remindersWhereUniqueInput | remindersWhereUniqueInput[]
    disconnect?: remindersWhereUniqueInput | remindersWhereUniqueInput[]
    delete?: remindersWhereUniqueInput | remindersWhereUniqueInput[]
    connect?: remindersWhereUniqueInput | remindersWhereUniqueInput[]
    update?: remindersUpdateWithWhereUniqueWithoutInvoicesInput | remindersUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: remindersUpdateManyWithWhereWithoutInvoicesInput | remindersUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: remindersScalarWhereInput | remindersScalarWhereInput[]
  }

  export type usersUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<usersCreateWithoutInvoicesInput, usersUncheckedCreateWithoutInvoicesInput> | usersCreateWithoutInvoicesInput[] | usersUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutInvoicesInput | usersCreateOrConnectWithoutInvoicesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutInvoicesInput | usersUpsertWithWhereUniqueWithoutInvoicesInput[]
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutInvoicesInput | usersUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutInvoicesInput | usersUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type bookingsUncheckedUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<bookingsCreateWithoutInvoiceInput, bookingsUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutInvoiceInput
    upsert?: bookingsUpsertWithoutInvoiceInput
    disconnect?: bookingsWhereInput | boolean
    delete?: bookingsWhereInput | boolean
    connect?: bookingsWhereUniqueInput
    update?: XOR<XOR<bookingsUpdateToOneWithWhereWithoutInvoiceInput, bookingsUpdateWithoutInvoiceInput>, bookingsUncheckedUpdateWithoutInvoiceInput>
  }

  export type paymentsUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<paymentsCreateWithoutInvoiceInput, paymentsUncheckedCreateWithoutInvoiceInput> | paymentsCreateWithoutInvoiceInput[] | paymentsUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutInvoiceInput | paymentsCreateOrConnectWithoutInvoiceInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutInvoiceInput | paymentsUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: paymentsCreateManyInvoiceInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutInvoiceInput | paymentsUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutInvoiceInput | paymentsUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type remindersUncheckedUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<remindersCreateWithoutInvoicesInput, remindersUncheckedCreateWithoutInvoicesInput> | remindersCreateWithoutInvoicesInput[] | remindersUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: remindersCreateOrConnectWithoutInvoicesInput | remindersCreateOrConnectWithoutInvoicesInput[]
    upsert?: remindersUpsertWithWhereUniqueWithoutInvoicesInput | remindersUpsertWithWhereUniqueWithoutInvoicesInput[]
    createMany?: remindersCreateManyInvoicesInputEnvelope
    set?: remindersWhereUniqueInput | remindersWhereUniqueInput[]
    disconnect?: remindersWhereUniqueInput | remindersWhereUniqueInput[]
    delete?: remindersWhereUniqueInput | remindersWhereUniqueInput[]
    connect?: remindersWhereUniqueInput | remindersWhereUniqueInput[]
    update?: remindersUpdateWithWhereUniqueWithoutInvoicesInput | remindersUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: remindersUpdateManyWithWhereWithoutInvoicesInput | remindersUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: remindersScalarWhereInput | remindersScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutInvoicesNestedInput = {
    create?: XOR<usersCreateWithoutInvoicesInput, usersUncheckedCreateWithoutInvoicesInput> | usersCreateWithoutInvoicesInput[] | usersUncheckedCreateWithoutInvoicesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutInvoicesInput | usersCreateOrConnectWithoutInvoicesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutInvoicesInput | usersUpsertWithWhereUniqueWithoutInvoicesInput[]
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutInvoicesInput | usersUpdateWithWhereUniqueWithoutInvoicesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutInvoicesInput | usersUpdateManyWithWhereWithoutInvoicesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    connect?: usersWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type Enumnotifications_typeFieldUpdateOperationsInput = {
    set?: $Enums.notifications_type
  }

  export type usersUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    upsert?: usersUpsertWithoutNotificationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotificationsInput, usersUpdateWithoutNotificationsInput>, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type invoicesCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<invoicesCreateWithoutPaymentsInput, invoicesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutPaymentsInput
    connect?: invoicesWhereUniqueInput
  }

  export type bookingsCreateNestedManyWithoutPaymentsInput = {
    create?: XOR<bookingsCreateWithoutPaymentsInput, bookingsUncheckedCreateWithoutPaymentsInput> | bookingsCreateWithoutPaymentsInput[] | bookingsUncheckedCreateWithoutPaymentsInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutPaymentsInput | bookingsCreateOrConnectWithoutPaymentsInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type bookingsUncheckedCreateNestedManyWithoutPaymentsInput = {
    create?: XOR<bookingsCreateWithoutPaymentsInput, bookingsUncheckedCreateWithoutPaymentsInput> | bookingsCreateWithoutPaymentsInput[] | bookingsUncheckedCreateWithoutPaymentsInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutPaymentsInput | bookingsCreateOrConnectWithoutPaymentsInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type Enumpayments_payment_methodFieldUpdateOperationsInput = {
    set?: $Enums.payments_payment_method
  }

  export type invoicesUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<invoicesCreateWithoutPaymentsInput, invoicesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutPaymentsInput
    upsert?: invoicesUpsertWithoutPaymentsInput
    connect?: invoicesWhereUniqueInput
    update?: XOR<XOR<invoicesUpdateToOneWithWhereWithoutPaymentsInput, invoicesUpdateWithoutPaymentsInput>, invoicesUncheckedUpdateWithoutPaymentsInput>
  }

  export type bookingsUpdateManyWithoutPaymentsNestedInput = {
    create?: XOR<bookingsCreateWithoutPaymentsInput, bookingsUncheckedCreateWithoutPaymentsInput> | bookingsCreateWithoutPaymentsInput[] | bookingsUncheckedCreateWithoutPaymentsInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutPaymentsInput | bookingsCreateOrConnectWithoutPaymentsInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutPaymentsInput | bookingsUpsertWithWhereUniqueWithoutPaymentsInput[]
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutPaymentsInput | bookingsUpdateWithWhereUniqueWithoutPaymentsInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutPaymentsInput | bookingsUpdateManyWithWhereWithoutPaymentsInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type bookingsUncheckedUpdateManyWithoutPaymentsNestedInput = {
    create?: XOR<bookingsCreateWithoutPaymentsInput, bookingsUncheckedCreateWithoutPaymentsInput> | bookingsCreateWithoutPaymentsInput[] | bookingsUncheckedCreateWithoutPaymentsInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutPaymentsInput | bookingsCreateOrConnectWithoutPaymentsInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutPaymentsInput | bookingsUpsertWithWhereUniqueWithoutPaymentsInput[]
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutPaymentsInput | bookingsUpdateWithWhereUniqueWithoutPaymentsInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutPaymentsInput | bookingsUpdateManyWithWhereWithoutPaymentsInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type Enumusers_roleFieldUpdateOperationsInput = {
    set?: $Enums.users_role
  }

  export type bookingsCreateNestedOneWithoutQuoteInput = {
    create?: XOR<bookingsCreateWithoutQuoteInput, bookingsUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutQuoteInput
    connect?: bookingsWhereUniqueInput
  }

  export type invoicesCreateNestedOneWithoutQuoteInput = {
    create?: XOR<invoicesCreateWithoutQuoteInput, invoicesUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutQuoteInput
    connect?: invoicesWhereUniqueInput
  }

  export type clientsCreateNestedOneWithoutQuotesInput = {
    create?: XOR<clientsCreateWithoutQuotesInput, clientsUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: clientsCreateOrConnectWithoutQuotesInput
    connect?: clientsWhereUniqueInput
  }

  export type rate_cardsCreateNestedOneWithoutQuotesInput = {
    create?: XOR<rate_cardsCreateWithoutQuotesInput, rate_cardsUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: rate_cardsCreateOrConnectWithoutQuotesInput
    connect?: rate_cardsWhereUniqueInput
  }

  export type bookingsUncheckedCreateNestedOneWithoutQuoteInput = {
    create?: XOR<bookingsCreateWithoutQuoteInput, bookingsUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutQuoteInput
    connect?: bookingsWhereUniqueInput
  }

  export type invoicesUncheckedCreateNestedOneWithoutQuoteInput = {
    create?: XOR<invoicesCreateWithoutQuoteInput, invoicesUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutQuoteInput
    connect?: invoicesWhereUniqueInput
  }

  export type Enumquotes_statusFieldUpdateOperationsInput = {
    set?: $Enums.quotes_status
  }

  export type bookingsUpdateOneWithoutQuoteNestedInput = {
    create?: XOR<bookingsCreateWithoutQuoteInput, bookingsUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutQuoteInput
    upsert?: bookingsUpsertWithoutQuoteInput
    disconnect?: bookingsWhereInput | boolean
    delete?: bookingsWhereInput | boolean
    connect?: bookingsWhereUniqueInput
    update?: XOR<XOR<bookingsUpdateToOneWithWhereWithoutQuoteInput, bookingsUpdateWithoutQuoteInput>, bookingsUncheckedUpdateWithoutQuoteInput>
  }

  export type invoicesUpdateOneWithoutQuoteNestedInput = {
    create?: XOR<invoicesCreateWithoutQuoteInput, invoicesUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutQuoteInput
    upsert?: invoicesUpsertWithoutQuoteInput
    disconnect?: invoicesWhereInput | boolean
    delete?: invoicesWhereInput | boolean
    connect?: invoicesWhereUniqueInput
    update?: XOR<XOR<invoicesUpdateToOneWithWhereWithoutQuoteInput, invoicesUpdateWithoutQuoteInput>, invoicesUncheckedUpdateWithoutQuoteInput>
  }

  export type clientsUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<clientsCreateWithoutQuotesInput, clientsUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: clientsCreateOrConnectWithoutQuotesInput
    upsert?: clientsUpsertWithoutQuotesInput
    connect?: clientsWhereUniqueInput
    update?: XOR<XOR<clientsUpdateToOneWithWhereWithoutQuotesInput, clientsUpdateWithoutQuotesInput>, clientsUncheckedUpdateWithoutQuotesInput>
  }

  export type rate_cardsUpdateOneRequiredWithoutQuotesNestedInput = {
    create?: XOR<rate_cardsCreateWithoutQuotesInput, rate_cardsUncheckedCreateWithoutQuotesInput>
    connectOrCreate?: rate_cardsCreateOrConnectWithoutQuotesInput
    upsert?: rate_cardsUpsertWithoutQuotesInput
    connect?: rate_cardsWhereUniqueInput
    update?: XOR<XOR<rate_cardsUpdateToOneWithWhereWithoutQuotesInput, rate_cardsUpdateWithoutQuotesInput>, rate_cardsUncheckedUpdateWithoutQuotesInput>
  }

  export type bookingsUncheckedUpdateOneWithoutQuoteNestedInput = {
    create?: XOR<bookingsCreateWithoutQuoteInput, bookingsUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutQuoteInput
    upsert?: bookingsUpsertWithoutQuoteInput
    disconnect?: bookingsWhereInput | boolean
    delete?: bookingsWhereInput | boolean
    connect?: bookingsWhereUniqueInput
    update?: XOR<XOR<bookingsUpdateToOneWithWhereWithoutQuoteInput, bookingsUpdateWithoutQuoteInput>, bookingsUncheckedUpdateWithoutQuoteInput>
  }

  export type invoicesUncheckedUpdateOneWithoutQuoteNestedInput = {
    create?: XOR<invoicesCreateWithoutQuoteInput, invoicesUncheckedCreateWithoutQuoteInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutQuoteInput
    upsert?: invoicesUpsertWithoutQuoteInput
    disconnect?: invoicesWhereInput | boolean
    delete?: invoicesWhereInput | boolean
    connect?: invoicesWhereUniqueInput
    update?: XOR<XOR<invoicesUpdateToOneWithWhereWithoutQuoteInput, invoicesUpdateWithoutQuoteInput>, invoicesUncheckedUpdateWithoutQuoteInput>
  }

  export type hotelsCreateNestedOneWithoutRack_ratesInput = {
    create?: XOR<hotelsCreateWithoutRack_ratesInput, hotelsUncheckedCreateWithoutRack_ratesInput>
    connectOrCreate?: hotelsCreateOrConnectWithoutRack_ratesInput
    connect?: hotelsWhereUniqueInput
  }

  export type rate_cardsCreateNestedManyWithoutRack_ratesInput = {
    create?: XOR<rate_cardsCreateWithoutRack_ratesInput, rate_cardsUncheckedCreateWithoutRack_ratesInput> | rate_cardsCreateWithoutRack_ratesInput[] | rate_cardsUncheckedCreateWithoutRack_ratesInput[]
    connectOrCreate?: rate_cardsCreateOrConnectWithoutRack_ratesInput | rate_cardsCreateOrConnectWithoutRack_ratesInput[]
    createMany?: rate_cardsCreateManyRack_ratesInputEnvelope
    connect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
  }

  export type rate_cardsUncheckedCreateNestedManyWithoutRack_ratesInput = {
    create?: XOR<rate_cardsCreateWithoutRack_ratesInput, rate_cardsUncheckedCreateWithoutRack_ratesInput> | rate_cardsCreateWithoutRack_ratesInput[] | rate_cardsUncheckedCreateWithoutRack_ratesInput[]
    connectOrCreate?: rate_cardsCreateOrConnectWithoutRack_ratesInput | rate_cardsCreateOrConnectWithoutRack_ratesInput[]
    createMany?: rate_cardsCreateManyRack_ratesInputEnvelope
    connect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
  }

  export type Enumrack_rates_travel_periodFieldUpdateOperationsInput = {
    set?: $Enums.rack_rates_travel_period
  }

  export type Enumrack_rates_meal_planFieldUpdateOperationsInput = {
    set?: $Enums.rack_rates_meal_plan
  }

  export type Enumrack_rates_room_categoryFieldUpdateOperationsInput = {
    set?: $Enums.rack_rates_room_category
  }

  export type hotelsUpdateOneRequiredWithoutRack_ratesNestedInput = {
    create?: XOR<hotelsCreateWithoutRack_ratesInput, hotelsUncheckedCreateWithoutRack_ratesInput>
    connectOrCreate?: hotelsCreateOrConnectWithoutRack_ratesInput
    upsert?: hotelsUpsertWithoutRack_ratesInput
    connect?: hotelsWhereUniqueInput
    update?: XOR<XOR<hotelsUpdateToOneWithWhereWithoutRack_ratesInput, hotelsUpdateWithoutRack_ratesInput>, hotelsUncheckedUpdateWithoutRack_ratesInput>
  }

  export type rate_cardsUpdateManyWithoutRack_ratesNestedInput = {
    create?: XOR<rate_cardsCreateWithoutRack_ratesInput, rate_cardsUncheckedCreateWithoutRack_ratesInput> | rate_cardsCreateWithoutRack_ratesInput[] | rate_cardsUncheckedCreateWithoutRack_ratesInput[]
    connectOrCreate?: rate_cardsCreateOrConnectWithoutRack_ratesInput | rate_cardsCreateOrConnectWithoutRack_ratesInput[]
    upsert?: rate_cardsUpsertWithWhereUniqueWithoutRack_ratesInput | rate_cardsUpsertWithWhereUniqueWithoutRack_ratesInput[]
    createMany?: rate_cardsCreateManyRack_ratesInputEnvelope
    set?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    disconnect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    delete?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    connect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    update?: rate_cardsUpdateWithWhereUniqueWithoutRack_ratesInput | rate_cardsUpdateWithWhereUniqueWithoutRack_ratesInput[]
    updateMany?: rate_cardsUpdateManyWithWhereWithoutRack_ratesInput | rate_cardsUpdateManyWithWhereWithoutRack_ratesInput[]
    deleteMany?: rate_cardsScalarWhereInput | rate_cardsScalarWhereInput[]
  }

  export type rate_cardsUncheckedUpdateManyWithoutRack_ratesNestedInput = {
    create?: XOR<rate_cardsCreateWithoutRack_ratesInput, rate_cardsUncheckedCreateWithoutRack_ratesInput> | rate_cardsCreateWithoutRack_ratesInput[] | rate_cardsUncheckedCreateWithoutRack_ratesInput[]
    connectOrCreate?: rate_cardsCreateOrConnectWithoutRack_ratesInput | rate_cardsCreateOrConnectWithoutRack_ratesInput[]
    upsert?: rate_cardsUpsertWithWhereUniqueWithoutRack_ratesInput | rate_cardsUpsertWithWhereUniqueWithoutRack_ratesInput[]
    createMany?: rate_cardsCreateManyRack_ratesInputEnvelope
    set?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    disconnect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    delete?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    connect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    update?: rate_cardsUpdateWithWhereUniqueWithoutRack_ratesInput | rate_cardsUpdateWithWhereUniqueWithoutRack_ratesInput[]
    updateMany?: rate_cardsUpdateManyWithWhereWithoutRack_ratesInput | rate_cardsUpdateManyWithWhereWithoutRack_ratesInput[]
    deleteMany?: rate_cardsScalarWhereInput | rate_cardsScalarWhereInput[]
  }

  export type quotesCreateNestedManyWithoutRate_cardInput = {
    create?: XOR<quotesCreateWithoutRate_cardInput, quotesUncheckedCreateWithoutRate_cardInput> | quotesCreateWithoutRate_cardInput[] | quotesUncheckedCreateWithoutRate_cardInput[]
    connectOrCreate?: quotesCreateOrConnectWithoutRate_cardInput | quotesCreateOrConnectWithoutRate_cardInput[]
    createMany?: quotesCreateManyRate_cardInputEnvelope
    connect?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutRate_cardsInput = {
    create?: XOR<usersCreateWithoutRate_cardsInput, usersUncheckedCreateWithoutRate_cardsInput>
    connectOrCreate?: usersCreateOrConnectWithoutRate_cardsInput
    connect?: usersWhereUniqueInput
  }

  export type hotelsCreateNestedOneWithoutRate_cardsInput = {
    create?: XOR<hotelsCreateWithoutRate_cardsInput, hotelsUncheckedCreateWithoutRate_cardsInput>
    connectOrCreate?: hotelsCreateOrConnectWithoutRate_cardsInput
    connect?: hotelsWhereUniqueInput
  }

  export type rack_ratesCreateNestedOneWithoutRate_cardsInput = {
    create?: XOR<rack_ratesCreateWithoutRate_cardsInput, rack_ratesUncheckedCreateWithoutRate_cardsInput>
    connectOrCreate?: rack_ratesCreateOrConnectWithoutRate_cardsInput
    connect?: rack_ratesWhereUniqueInput
  }

  export type quotesUncheckedCreateNestedManyWithoutRate_cardInput = {
    create?: XOR<quotesCreateWithoutRate_cardInput, quotesUncheckedCreateWithoutRate_cardInput> | quotesCreateWithoutRate_cardInput[] | quotesUncheckedCreateWithoutRate_cardInput[]
    connectOrCreate?: quotesCreateOrConnectWithoutRate_cardInput | quotesCreateOrConnectWithoutRate_cardInput[]
    createMany?: quotesCreateManyRate_cardInputEnvelope
    connect?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
  }

  export type Enumrate_cards_travel_periodFieldUpdateOperationsInput = {
    set?: $Enums.rate_cards_travel_period
  }

  export type Enumrate_cards_meal_planFieldUpdateOperationsInput = {
    set?: $Enums.rate_cards_meal_plan
  }

  export type Enumrate_cards_room_categoryFieldUpdateOperationsInput = {
    set?: $Enums.rate_cards_room_category
  }

  export type quotesUpdateManyWithoutRate_cardNestedInput = {
    create?: XOR<quotesCreateWithoutRate_cardInput, quotesUncheckedCreateWithoutRate_cardInput> | quotesCreateWithoutRate_cardInput[] | quotesUncheckedCreateWithoutRate_cardInput[]
    connectOrCreate?: quotesCreateOrConnectWithoutRate_cardInput | quotesCreateOrConnectWithoutRate_cardInput[]
    upsert?: quotesUpsertWithWhereUniqueWithoutRate_cardInput | quotesUpsertWithWhereUniqueWithoutRate_cardInput[]
    createMany?: quotesCreateManyRate_cardInputEnvelope
    set?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    disconnect?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    delete?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    connect?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    update?: quotesUpdateWithWhereUniqueWithoutRate_cardInput | quotesUpdateWithWhereUniqueWithoutRate_cardInput[]
    updateMany?: quotesUpdateManyWithWhereWithoutRate_cardInput | quotesUpdateManyWithWhereWithoutRate_cardInput[]
    deleteMany?: quotesScalarWhereInput | quotesScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutRate_cardsNestedInput = {
    create?: XOR<usersCreateWithoutRate_cardsInput, usersUncheckedCreateWithoutRate_cardsInput>
    connectOrCreate?: usersCreateOrConnectWithoutRate_cardsInput
    upsert?: usersUpsertWithoutRate_cardsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRate_cardsInput, usersUpdateWithoutRate_cardsInput>, usersUncheckedUpdateWithoutRate_cardsInput>
  }

  export type hotelsUpdateOneRequiredWithoutRate_cardsNestedInput = {
    create?: XOR<hotelsCreateWithoutRate_cardsInput, hotelsUncheckedCreateWithoutRate_cardsInput>
    connectOrCreate?: hotelsCreateOrConnectWithoutRate_cardsInput
    upsert?: hotelsUpsertWithoutRate_cardsInput
    connect?: hotelsWhereUniqueInput
    update?: XOR<XOR<hotelsUpdateToOneWithWhereWithoutRate_cardsInput, hotelsUpdateWithoutRate_cardsInput>, hotelsUncheckedUpdateWithoutRate_cardsInput>
  }

  export type rack_ratesUpdateOneRequiredWithoutRate_cardsNestedInput = {
    create?: XOR<rack_ratesCreateWithoutRate_cardsInput, rack_ratesUncheckedCreateWithoutRate_cardsInput>
    connectOrCreate?: rack_ratesCreateOrConnectWithoutRate_cardsInput
    upsert?: rack_ratesUpsertWithoutRate_cardsInput
    connect?: rack_ratesWhereUniqueInput
    update?: XOR<XOR<rack_ratesUpdateToOneWithWhereWithoutRate_cardsInput, rack_ratesUpdateWithoutRate_cardsInput>, rack_ratesUncheckedUpdateWithoutRate_cardsInput>
  }

  export type quotesUncheckedUpdateManyWithoutRate_cardNestedInput = {
    create?: XOR<quotesCreateWithoutRate_cardInput, quotesUncheckedCreateWithoutRate_cardInput> | quotesCreateWithoutRate_cardInput[] | quotesUncheckedCreateWithoutRate_cardInput[]
    connectOrCreate?: quotesCreateOrConnectWithoutRate_cardInput | quotesCreateOrConnectWithoutRate_cardInput[]
    upsert?: quotesUpsertWithWhereUniqueWithoutRate_cardInput | quotesUpsertWithWhereUniqueWithoutRate_cardInput[]
    createMany?: quotesCreateManyRate_cardInputEnvelope
    set?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    disconnect?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    delete?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    connect?: quotesWhereUniqueInput | quotesWhereUniqueInput[]
    update?: quotesUpdateWithWhereUniqueWithoutRate_cardInput | quotesUpdateWithWhereUniqueWithoutRate_cardInput[]
    updateMany?: quotesUpdateManyWithWhereWithoutRate_cardInput | quotesUpdateManyWithWhereWithoutRate_cardInput[]
    deleteMany?: quotesScalarWhereInput | quotesScalarWhereInput[]
  }

  export type invoicesCreateNestedOneWithoutRemindersInput = {
    create?: XOR<invoicesCreateWithoutRemindersInput, invoicesUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutRemindersInput
    connect?: invoicesWhereUniqueInput
  }

  export type invoicesUpdateOneRequiredWithoutRemindersNestedInput = {
    create?: XOR<invoicesCreateWithoutRemindersInput, invoicesUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: invoicesCreateOrConnectWithoutRemindersInput
    upsert?: invoicesUpsertWithoutRemindersInput
    connect?: invoicesWhereUniqueInput
    update?: XOR<XOR<invoicesUpdateToOneWithWhereWithoutRemindersInput, invoicesUpdateWithoutRemindersInput>, invoicesUncheckedUpdateWithoutRemindersInput>
  }

  export type hotel_policiesCreateNestedOneWithoutSeasonsInput = {
    create?: XOR<hotel_policiesCreateWithoutSeasonsInput, hotel_policiesUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: hotel_policiesCreateOrConnectWithoutSeasonsInput
    connect?: hotel_policiesWhereUniqueInput
  }

  export type Enumseasons_period_typeFieldUpdateOperationsInput = {
    set?: $Enums.seasons_period_type
  }

  export type hotel_policiesUpdateOneRequiredWithoutSeasonsNestedInput = {
    create?: XOR<hotel_policiesCreateWithoutSeasonsInput, hotel_policiesUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: hotel_policiesCreateOrConnectWithoutSeasonsInput
    upsert?: hotel_policiesUpsertWithoutSeasonsInput
    connect?: hotel_policiesWhereUniqueInput
    update?: XOR<XOR<hotel_policiesUpdateToOneWithWhereWithoutSeasonsInput, hotel_policiesUpdateWithoutSeasonsInput>, hotel_policiesUncheckedUpdateWithoutSeasonsInput>
  }

  export type usersCreateNestedOneWithoutSessionsInput = {
    create?: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionsInput
    upsert?: usersUpsertWithoutSessionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSessionsInput, usersUpdateWithoutSessionsInput>, usersUncheckedUpdateWithoutSessionsInput>
  }

  export type bookingsCreateNestedOneWithoutTransportationInput = {
    create?: XOR<bookingsCreateWithoutTransportationInput, bookingsUncheckedCreateWithoutTransportationInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutTransportationInput
    connect?: bookingsWhereUniqueInput
  }

  export type Enumtransportation_typeFieldUpdateOperationsInput = {
    set?: $Enums.transportation_type
  }

  export type Enumtransportation_statusFieldUpdateOperationsInput = {
    set?: $Enums.transportation_status
  }

  export type bookingsUpdateOneRequiredWithoutTransportationNestedInput = {
    create?: XOR<bookingsCreateWithoutTransportationInput, bookingsUncheckedCreateWithoutTransportationInput>
    connectOrCreate?: bookingsCreateOrConnectWithoutTransportationInput
    upsert?: bookingsUpsertWithoutTransportationInput
    connect?: bookingsWhereUniqueInput
    update?: XOR<XOR<bookingsUpdateToOneWithWhereWithoutTransportationInput, bookingsUpdateWithoutTransportationInput>, bookingsUncheckedUpdateWithoutTransportationInput>
  }

  export type accountsCreateNestedManyWithoutUserInput = {
    create?: XOR<accountsCreateWithoutUserInput, accountsUncheckedCreateWithoutUserInput> | accountsCreateWithoutUserInput[] | accountsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutUserInput | accountsCreateOrConnectWithoutUserInput[]
    createMany?: accountsCreateManyUserInputEnvelope
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
  }

  export type bookingsCreateNestedManyWithoutUserInput = {
    create?: XOR<bookingsCreateWithoutUserInput, bookingsUncheckedCreateWithoutUserInput> | bookingsCreateWithoutUserInput[] | bookingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutUserInput | bookingsCreateOrConnectWithoutUserInput[]
    createMany?: bookingsCreateManyUserInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type cancellationsCreateNestedManyWithoutUserInput = {
    create?: XOR<cancellationsCreateWithoutUserInput, cancellationsUncheckedCreateWithoutUserInput> | cancellationsCreateWithoutUserInput[] | cancellationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: cancellationsCreateOrConnectWithoutUserInput | cancellationsCreateOrConnectWithoutUserInput[]
    createMany?: cancellationsCreateManyUserInputEnvelope
    connect?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
  }

  export type events_logCreateNestedManyWithoutUsersInput = {
    create?: XOR<events_logCreateWithoutUsersInput, events_logUncheckedCreateWithoutUsersInput> | events_logCreateWithoutUsersInput[] | events_logUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: events_logCreateOrConnectWithoutUsersInput | events_logCreateOrConnectWithoutUsersInput[]
    createMany?: events_logCreateManyUsersInputEnvelope
    connect?: events_logWhereUniqueInput | events_logWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type rate_cardsCreateNestedManyWithoutUsersInput = {
    create?: XOR<rate_cardsCreateWithoutUsersInput, rate_cardsUncheckedCreateWithoutUsersInput> | rate_cardsCreateWithoutUsersInput[] | rate_cardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: rate_cardsCreateOrConnectWithoutUsersInput | rate_cardsCreateOrConnectWithoutUsersInput[]
    createMany?: rate_cardsCreateManyUsersInputEnvelope
    connect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
  }

  export type sessionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type branchesCreateNestedOneWithoutUsersInput = {
    create?: XOR<branchesCreateWithoutUsersInput, branchesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: branchesCreateOrConnectWithoutUsersInput
    connect?: branchesWhereUniqueInput
  }

  export type users_branchesCreateNestedManyWithoutUserInput = {
    create?: XOR<users_branchesCreateWithoutUserInput, users_branchesUncheckedCreateWithoutUserInput> | users_branchesCreateWithoutUserInput[] | users_branchesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: users_branchesCreateOrConnectWithoutUserInput | users_branchesCreateOrConnectWithoutUserInput[]
    createMany?: users_branchesCreateManyUserInputEnvelope
    connect?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
  }

  export type invoicesCreateNestedManyWithoutUsersInput = {
    create?: XOR<invoicesCreateWithoutUsersInput, invoicesUncheckedCreateWithoutUsersInput> | invoicesCreateWithoutUsersInput[] | invoicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutUsersInput | invoicesCreateOrConnectWithoutUsersInput[]
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
  }

  export type accountsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<accountsCreateWithoutUserInput, accountsUncheckedCreateWithoutUserInput> | accountsCreateWithoutUserInput[] | accountsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutUserInput | accountsCreateOrConnectWithoutUserInput[]
    createMany?: accountsCreateManyUserInputEnvelope
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
  }

  export type bookingsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<bookingsCreateWithoutUserInput, bookingsUncheckedCreateWithoutUserInput> | bookingsCreateWithoutUserInput[] | bookingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutUserInput | bookingsCreateOrConnectWithoutUserInput[]
    createMany?: bookingsCreateManyUserInputEnvelope
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
  }

  export type cancellationsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<cancellationsCreateWithoutUserInput, cancellationsUncheckedCreateWithoutUserInput> | cancellationsCreateWithoutUserInput[] | cancellationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: cancellationsCreateOrConnectWithoutUserInput | cancellationsCreateOrConnectWithoutUserInput[]
    createMany?: cancellationsCreateManyUserInputEnvelope
    connect?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
  }

  export type events_logUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<events_logCreateWithoutUsersInput, events_logUncheckedCreateWithoutUsersInput> | events_logCreateWithoutUsersInput[] | events_logUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: events_logCreateOrConnectWithoutUsersInput | events_logCreateOrConnectWithoutUsersInput[]
    createMany?: events_logCreateManyUsersInputEnvelope
    connect?: events_logWhereUniqueInput | events_logWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type rate_cardsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<rate_cardsCreateWithoutUsersInput, rate_cardsUncheckedCreateWithoutUsersInput> | rate_cardsCreateWithoutUsersInput[] | rate_cardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: rate_cardsCreateOrConnectWithoutUsersInput | rate_cardsCreateOrConnectWithoutUsersInput[]
    createMany?: rate_cardsCreateManyUsersInputEnvelope
    connect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
  }

  export type sessionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type users_branchesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<users_branchesCreateWithoutUserInput, users_branchesUncheckedCreateWithoutUserInput> | users_branchesCreateWithoutUserInput[] | users_branchesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: users_branchesCreateOrConnectWithoutUserInput | users_branchesCreateOrConnectWithoutUserInput[]
    createMany?: users_branchesCreateManyUserInputEnvelope
    connect?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
  }

  export type invoicesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<invoicesCreateWithoutUsersInput, invoicesUncheckedCreateWithoutUsersInput> | invoicesCreateWithoutUsersInput[] | invoicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutUsersInput | invoicesCreateOrConnectWithoutUsersInput[]
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
  }

  export type Enumusers_statusFieldUpdateOperationsInput = {
    set?: $Enums.users_status
  }

  export type accountsUpdateManyWithoutUserNestedInput = {
    create?: XOR<accountsCreateWithoutUserInput, accountsUncheckedCreateWithoutUserInput> | accountsCreateWithoutUserInput[] | accountsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutUserInput | accountsCreateOrConnectWithoutUserInput[]
    upsert?: accountsUpsertWithWhereUniqueWithoutUserInput | accountsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: accountsCreateManyUserInputEnvelope
    set?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    disconnect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    delete?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    update?: accountsUpdateWithWhereUniqueWithoutUserInput | accountsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: accountsUpdateManyWithWhereWithoutUserInput | accountsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: accountsScalarWhereInput | accountsScalarWhereInput[]
  }

  export type bookingsUpdateManyWithoutUserNestedInput = {
    create?: XOR<bookingsCreateWithoutUserInput, bookingsUncheckedCreateWithoutUserInput> | bookingsCreateWithoutUserInput[] | bookingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutUserInput | bookingsCreateOrConnectWithoutUserInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutUserInput | bookingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: bookingsCreateManyUserInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutUserInput | bookingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutUserInput | bookingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type cancellationsUpdateManyWithoutUserNestedInput = {
    create?: XOR<cancellationsCreateWithoutUserInput, cancellationsUncheckedCreateWithoutUserInput> | cancellationsCreateWithoutUserInput[] | cancellationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: cancellationsCreateOrConnectWithoutUserInput | cancellationsCreateOrConnectWithoutUserInput[]
    upsert?: cancellationsUpsertWithWhereUniqueWithoutUserInput | cancellationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: cancellationsCreateManyUserInputEnvelope
    set?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    disconnect?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    delete?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    connect?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    update?: cancellationsUpdateWithWhereUniqueWithoutUserInput | cancellationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: cancellationsUpdateManyWithWhereWithoutUserInput | cancellationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: cancellationsScalarWhereInput | cancellationsScalarWhereInput[]
  }

  export type events_logUpdateManyWithoutUsersNestedInput = {
    create?: XOR<events_logCreateWithoutUsersInput, events_logUncheckedCreateWithoutUsersInput> | events_logCreateWithoutUsersInput[] | events_logUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: events_logCreateOrConnectWithoutUsersInput | events_logCreateOrConnectWithoutUsersInput[]
    upsert?: events_logUpsertWithWhereUniqueWithoutUsersInput | events_logUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: events_logCreateManyUsersInputEnvelope
    set?: events_logWhereUniqueInput | events_logWhereUniqueInput[]
    disconnect?: events_logWhereUniqueInput | events_logWhereUniqueInput[]
    delete?: events_logWhereUniqueInput | events_logWhereUniqueInput[]
    connect?: events_logWhereUniqueInput | events_logWhereUniqueInput[]
    update?: events_logUpdateWithWhereUniqueWithoutUsersInput | events_logUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: events_logUpdateManyWithWhereWithoutUsersInput | events_logUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: events_logScalarWhereInput | events_logScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsersInput | notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsersInput | notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsersInput | notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type rate_cardsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<rate_cardsCreateWithoutUsersInput, rate_cardsUncheckedCreateWithoutUsersInput> | rate_cardsCreateWithoutUsersInput[] | rate_cardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: rate_cardsCreateOrConnectWithoutUsersInput | rate_cardsCreateOrConnectWithoutUsersInput[]
    upsert?: rate_cardsUpsertWithWhereUniqueWithoutUsersInput | rate_cardsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: rate_cardsCreateManyUsersInputEnvelope
    set?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    disconnect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    delete?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    connect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    update?: rate_cardsUpdateWithWhereUniqueWithoutUsersInput | rate_cardsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: rate_cardsUpdateManyWithWhereWithoutUsersInput | rate_cardsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: rate_cardsScalarWhereInput | rate_cardsScalarWhereInput[]
  }

  export type sessionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutUsersInput | sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutUsersInput | sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutUsersInput | sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type branchesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<branchesCreateWithoutUsersInput, branchesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: branchesCreateOrConnectWithoutUsersInput
    upsert?: branchesUpsertWithoutUsersInput
    disconnect?: branchesWhereInput | boolean
    delete?: branchesWhereInput | boolean
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutUsersInput, branchesUpdateWithoutUsersInput>, branchesUncheckedUpdateWithoutUsersInput>
  }

  export type users_branchesUpdateManyWithoutUserNestedInput = {
    create?: XOR<users_branchesCreateWithoutUserInput, users_branchesUncheckedCreateWithoutUserInput> | users_branchesCreateWithoutUserInput[] | users_branchesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: users_branchesCreateOrConnectWithoutUserInput | users_branchesCreateOrConnectWithoutUserInput[]
    upsert?: users_branchesUpsertWithWhereUniqueWithoutUserInput | users_branchesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: users_branchesCreateManyUserInputEnvelope
    set?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    disconnect?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    delete?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    connect?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    update?: users_branchesUpdateWithWhereUniqueWithoutUserInput | users_branchesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: users_branchesUpdateManyWithWhereWithoutUserInput | users_branchesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: users_branchesScalarWhereInput | users_branchesScalarWhereInput[]
  }

  export type invoicesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<invoicesCreateWithoutUsersInput, invoicesUncheckedCreateWithoutUsersInput> | invoicesCreateWithoutUsersInput[] | invoicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutUsersInput | invoicesCreateOrConnectWithoutUsersInput[]
    upsert?: invoicesUpsertWithWhereUniqueWithoutUsersInput | invoicesUpsertWithWhereUniqueWithoutUsersInput[]
    set?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    disconnect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    delete?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    update?: invoicesUpdateWithWhereUniqueWithoutUsersInput | invoicesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: invoicesUpdateManyWithWhereWithoutUsersInput | invoicesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
  }

  export type accountsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<accountsCreateWithoutUserInput, accountsUncheckedCreateWithoutUserInput> | accountsCreateWithoutUserInput[] | accountsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: accountsCreateOrConnectWithoutUserInput | accountsCreateOrConnectWithoutUserInput[]
    upsert?: accountsUpsertWithWhereUniqueWithoutUserInput | accountsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: accountsCreateManyUserInputEnvelope
    set?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    disconnect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    delete?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    connect?: accountsWhereUniqueInput | accountsWhereUniqueInput[]
    update?: accountsUpdateWithWhereUniqueWithoutUserInput | accountsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: accountsUpdateManyWithWhereWithoutUserInput | accountsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: accountsScalarWhereInput | accountsScalarWhereInput[]
  }

  export type bookingsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<bookingsCreateWithoutUserInput, bookingsUncheckedCreateWithoutUserInput> | bookingsCreateWithoutUserInput[] | bookingsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: bookingsCreateOrConnectWithoutUserInput | bookingsCreateOrConnectWithoutUserInput[]
    upsert?: bookingsUpsertWithWhereUniqueWithoutUserInput | bookingsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: bookingsCreateManyUserInputEnvelope
    set?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    disconnect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    delete?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    connect?: bookingsWhereUniqueInput | bookingsWhereUniqueInput[]
    update?: bookingsUpdateWithWhereUniqueWithoutUserInput | bookingsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: bookingsUpdateManyWithWhereWithoutUserInput | bookingsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
  }

  export type cancellationsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<cancellationsCreateWithoutUserInput, cancellationsUncheckedCreateWithoutUserInput> | cancellationsCreateWithoutUserInput[] | cancellationsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: cancellationsCreateOrConnectWithoutUserInput | cancellationsCreateOrConnectWithoutUserInput[]
    upsert?: cancellationsUpsertWithWhereUniqueWithoutUserInput | cancellationsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: cancellationsCreateManyUserInputEnvelope
    set?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    disconnect?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    delete?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    connect?: cancellationsWhereUniqueInput | cancellationsWhereUniqueInput[]
    update?: cancellationsUpdateWithWhereUniqueWithoutUserInput | cancellationsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: cancellationsUpdateManyWithWhereWithoutUserInput | cancellationsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: cancellationsScalarWhereInput | cancellationsScalarWhereInput[]
  }

  export type events_logUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<events_logCreateWithoutUsersInput, events_logUncheckedCreateWithoutUsersInput> | events_logCreateWithoutUsersInput[] | events_logUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: events_logCreateOrConnectWithoutUsersInput | events_logCreateOrConnectWithoutUsersInput[]
    upsert?: events_logUpsertWithWhereUniqueWithoutUsersInput | events_logUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: events_logCreateManyUsersInputEnvelope
    set?: events_logWhereUniqueInput | events_logWhereUniqueInput[]
    disconnect?: events_logWhereUniqueInput | events_logWhereUniqueInput[]
    delete?: events_logWhereUniqueInput | events_logWhereUniqueInput[]
    connect?: events_logWhereUniqueInput | events_logWhereUniqueInput[]
    update?: events_logUpdateWithWhereUniqueWithoutUsersInput | events_logUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: events_logUpdateManyWithWhereWithoutUsersInput | events_logUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: events_logScalarWhereInput | events_logScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput> | notificationsCreateWithoutUsersInput[] | notificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutUsersInput | notificationsCreateOrConnectWithoutUsersInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutUsersInput | notificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notificationsCreateManyUsersInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutUsersInput | notificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutUsersInput | notificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type rate_cardsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<rate_cardsCreateWithoutUsersInput, rate_cardsUncheckedCreateWithoutUsersInput> | rate_cardsCreateWithoutUsersInput[] | rate_cardsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: rate_cardsCreateOrConnectWithoutUsersInput | rate_cardsCreateOrConnectWithoutUsersInput[]
    upsert?: rate_cardsUpsertWithWhereUniqueWithoutUsersInput | rate_cardsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: rate_cardsCreateManyUsersInputEnvelope
    set?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    disconnect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    delete?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    connect?: rate_cardsWhereUniqueInput | rate_cardsWhereUniqueInput[]
    update?: rate_cardsUpdateWithWhereUniqueWithoutUsersInput | rate_cardsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: rate_cardsUpdateManyWithWhereWithoutUsersInput | rate_cardsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: rate_cardsScalarWhereInput | rate_cardsScalarWhereInput[]
  }

  export type sessionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutUsersInput | sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutUsersInput | sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutUsersInput | sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type users_branchesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<users_branchesCreateWithoutUserInput, users_branchesUncheckedCreateWithoutUserInput> | users_branchesCreateWithoutUserInput[] | users_branchesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: users_branchesCreateOrConnectWithoutUserInput | users_branchesCreateOrConnectWithoutUserInput[]
    upsert?: users_branchesUpsertWithWhereUniqueWithoutUserInput | users_branchesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: users_branchesCreateManyUserInputEnvelope
    set?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    disconnect?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    delete?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    connect?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    update?: users_branchesUpdateWithWhereUniqueWithoutUserInput | users_branchesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: users_branchesUpdateManyWithWhereWithoutUserInput | users_branchesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: users_branchesScalarWhereInput | users_branchesScalarWhereInput[]
  }

  export type invoicesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<invoicesCreateWithoutUsersInput, invoicesUncheckedCreateWithoutUsersInput> | invoicesCreateWithoutUsersInput[] | invoicesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: invoicesCreateOrConnectWithoutUsersInput | invoicesCreateOrConnectWithoutUsersInput[]
    upsert?: invoicesUpsertWithWhereUniqueWithoutUsersInput | invoicesUpsertWithWhereUniqueWithoutUsersInput[]
    set?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    disconnect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    delete?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    connect?: invoicesWhereUniqueInput | invoicesWhereUniqueInput[]
    update?: invoicesUpdateWithWhereUniqueWithoutUsersInput | invoicesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: invoicesUpdateManyWithWhereWithoutUsersInput | invoicesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
  }

  export type clientsCreateNestedManyWithoutBranchInput = {
    create?: XOR<clientsCreateWithoutBranchInput, clientsUncheckedCreateWithoutBranchInput> | clientsCreateWithoutBranchInput[] | clientsUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: clientsCreateOrConnectWithoutBranchInput | clientsCreateOrConnectWithoutBranchInput[]
    createMany?: clientsCreateManyBranchInputEnvelope
    connect?: clientsWhereUniqueInput | clientsWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutBranchInput = {
    create?: XOR<usersCreateWithoutBranchInput, usersUncheckedCreateWithoutBranchInput> | usersCreateWithoutBranchInput[] | usersUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: usersCreateOrConnectWithoutBranchInput | usersCreateOrConnectWithoutBranchInput[]
    createMany?: usersCreateManyBranchInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type users_branchesCreateNestedManyWithoutBranchInput = {
    create?: XOR<users_branchesCreateWithoutBranchInput, users_branchesUncheckedCreateWithoutBranchInput> | users_branchesCreateWithoutBranchInput[] | users_branchesUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: users_branchesCreateOrConnectWithoutBranchInput | users_branchesCreateOrConnectWithoutBranchInput[]
    createMany?: users_branchesCreateManyBranchInputEnvelope
    connect?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
  }

  export type clientsUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<clientsCreateWithoutBranchInput, clientsUncheckedCreateWithoutBranchInput> | clientsCreateWithoutBranchInput[] | clientsUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: clientsCreateOrConnectWithoutBranchInput | clientsCreateOrConnectWithoutBranchInput[]
    createMany?: clientsCreateManyBranchInputEnvelope
    connect?: clientsWhereUniqueInput | clientsWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<usersCreateWithoutBranchInput, usersUncheckedCreateWithoutBranchInput> | usersCreateWithoutBranchInput[] | usersUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: usersCreateOrConnectWithoutBranchInput | usersCreateOrConnectWithoutBranchInput[]
    createMany?: usersCreateManyBranchInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type users_branchesUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<users_branchesCreateWithoutBranchInput, users_branchesUncheckedCreateWithoutBranchInput> | users_branchesCreateWithoutBranchInput[] | users_branchesUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: users_branchesCreateOrConnectWithoutBranchInput | users_branchesCreateOrConnectWithoutBranchInput[]
    createMany?: users_branchesCreateManyBranchInputEnvelope
    connect?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
  }

  export type clientsUpdateManyWithoutBranchNestedInput = {
    create?: XOR<clientsCreateWithoutBranchInput, clientsUncheckedCreateWithoutBranchInput> | clientsCreateWithoutBranchInput[] | clientsUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: clientsCreateOrConnectWithoutBranchInput | clientsCreateOrConnectWithoutBranchInput[]
    upsert?: clientsUpsertWithWhereUniqueWithoutBranchInput | clientsUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: clientsCreateManyBranchInputEnvelope
    set?: clientsWhereUniqueInput | clientsWhereUniqueInput[]
    disconnect?: clientsWhereUniqueInput | clientsWhereUniqueInput[]
    delete?: clientsWhereUniqueInput | clientsWhereUniqueInput[]
    connect?: clientsWhereUniqueInput | clientsWhereUniqueInput[]
    update?: clientsUpdateWithWhereUniqueWithoutBranchInput | clientsUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: clientsUpdateManyWithWhereWithoutBranchInput | clientsUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: clientsScalarWhereInput | clientsScalarWhereInput[]
  }

  export type usersUpdateManyWithoutBranchNestedInput = {
    create?: XOR<usersCreateWithoutBranchInput, usersUncheckedCreateWithoutBranchInput> | usersCreateWithoutBranchInput[] | usersUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: usersCreateOrConnectWithoutBranchInput | usersCreateOrConnectWithoutBranchInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutBranchInput | usersUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: usersCreateManyBranchInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutBranchInput | usersUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: usersUpdateManyWithWhereWithoutBranchInput | usersUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type users_branchesUpdateManyWithoutBranchNestedInput = {
    create?: XOR<users_branchesCreateWithoutBranchInput, users_branchesUncheckedCreateWithoutBranchInput> | users_branchesCreateWithoutBranchInput[] | users_branchesUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: users_branchesCreateOrConnectWithoutBranchInput | users_branchesCreateOrConnectWithoutBranchInput[]
    upsert?: users_branchesUpsertWithWhereUniqueWithoutBranchInput | users_branchesUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: users_branchesCreateManyBranchInputEnvelope
    set?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    disconnect?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    delete?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    connect?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    update?: users_branchesUpdateWithWhereUniqueWithoutBranchInput | users_branchesUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: users_branchesUpdateManyWithWhereWithoutBranchInput | users_branchesUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: users_branchesScalarWhereInput | users_branchesScalarWhereInput[]
  }

  export type clientsUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<clientsCreateWithoutBranchInput, clientsUncheckedCreateWithoutBranchInput> | clientsCreateWithoutBranchInput[] | clientsUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: clientsCreateOrConnectWithoutBranchInput | clientsCreateOrConnectWithoutBranchInput[]
    upsert?: clientsUpsertWithWhereUniqueWithoutBranchInput | clientsUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: clientsCreateManyBranchInputEnvelope
    set?: clientsWhereUniqueInput | clientsWhereUniqueInput[]
    disconnect?: clientsWhereUniqueInput | clientsWhereUniqueInput[]
    delete?: clientsWhereUniqueInput | clientsWhereUniqueInput[]
    connect?: clientsWhereUniqueInput | clientsWhereUniqueInput[]
    update?: clientsUpdateWithWhereUniqueWithoutBranchInput | clientsUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: clientsUpdateManyWithWhereWithoutBranchInput | clientsUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: clientsScalarWhereInput | clientsScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<usersCreateWithoutBranchInput, usersUncheckedCreateWithoutBranchInput> | usersCreateWithoutBranchInput[] | usersUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: usersCreateOrConnectWithoutBranchInput | usersCreateOrConnectWithoutBranchInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutBranchInput | usersUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: usersCreateManyBranchInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutBranchInput | usersUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: usersUpdateManyWithWhereWithoutBranchInput | usersUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type users_branchesUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<users_branchesCreateWithoutBranchInput, users_branchesUncheckedCreateWithoutBranchInput> | users_branchesCreateWithoutBranchInput[] | users_branchesUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: users_branchesCreateOrConnectWithoutBranchInput | users_branchesCreateOrConnectWithoutBranchInput[]
    upsert?: users_branchesUpsertWithWhereUniqueWithoutBranchInput | users_branchesUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: users_branchesCreateManyBranchInputEnvelope
    set?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    disconnect?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    delete?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    connect?: users_branchesWhereUniqueInput | users_branchesWhereUniqueInput[]
    update?: users_branchesUpdateWithWhereUniqueWithoutBranchInput | users_branchesUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: users_branchesUpdateManyWithWhereWithoutBranchInput | users_branchesUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: users_branchesScalarWhereInput | users_branchesScalarWhereInput[]
  }

  export type branchesCreateNestedOneWithoutUsers_branchesInput = {
    create?: XOR<branchesCreateWithoutUsers_branchesInput, branchesUncheckedCreateWithoutUsers_branchesInput>
    connectOrCreate?: branchesCreateOrConnectWithoutUsers_branchesInput
    connect?: branchesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUsers_branchesInput = {
    create?: XOR<usersCreateWithoutUsers_branchesInput, usersUncheckedCreateWithoutUsers_branchesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUsers_branchesInput
    connect?: usersWhereUniqueInput
  }

  export type branchesUpdateOneRequiredWithoutUsers_branchesNestedInput = {
    create?: XOR<branchesCreateWithoutUsers_branchesInput, branchesUncheckedCreateWithoutUsers_branchesInput>
    connectOrCreate?: branchesCreateOrConnectWithoutUsers_branchesInput
    upsert?: branchesUpsertWithoutUsers_branchesInput
    connect?: branchesWhereUniqueInput
    update?: XOR<XOR<branchesUpdateToOneWithWhereWithoutUsers_branchesInput, branchesUpdateWithoutUsers_branchesInput>, branchesUncheckedUpdateWithoutUsers_branchesInput>
  }

  export type usersUpdateOneRequiredWithoutUsers_branchesNestedInput = {
    create?: XOR<usersCreateWithoutUsers_branchesInput, usersUncheckedCreateWithoutUsers_branchesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUsers_branchesInput
    upsert?: usersUpsertWithoutUsers_branchesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUsers_branchesInput, usersUpdateWithoutUsers_branchesInput>, usersUncheckedUpdateWithoutUsers_branchesInput>
  }

  export type usersCreateNestedOneWithoutEventsInput = {
    create?: XOR<usersCreateWithoutEventsInput, usersUncheckedCreateWithoutEventsInput>
    connectOrCreate?: usersCreateOrConnectWithoutEventsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<usersCreateWithoutEventsInput, usersUncheckedCreateWithoutEventsInput>
    connectOrCreate?: usersCreateOrConnectWithoutEventsInput
    upsert?: usersUpsertWithoutEventsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutEventsInput, usersUpdateWithoutEventsInput>, usersUncheckedUpdateWithoutEventsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumbookings_meal_planFilter<$PrismaModel = never> = {
    equals?: $Enums.bookings_meal_plan | Enumbookings_meal_planFieldRefInput<$PrismaModel>
    in?: $Enums.bookings_meal_plan[]
    notIn?: $Enums.bookings_meal_plan[]
    not?: NestedEnumbookings_meal_planFilter<$PrismaModel> | $Enums.bookings_meal_plan
  }

  export type NestedEnumbookings_room_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.bookings_room_category | Enumbookings_room_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.bookings_room_category[]
    notIn?: $Enums.bookings_room_category[]
    not?: NestedEnumbookings_room_categoryFilter<$PrismaModel> | $Enums.bookings_room_category
  }

  export type NestedEnumbookings_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.bookings_status | Enumbookings_statusFieldRefInput<$PrismaModel>
    in?: $Enums.bookings_status[]
    notIn?: $Enums.bookings_status[]
    not?: NestedEnumbookings_statusFilter<$PrismaModel> | $Enums.bookings_status
  }

  export type NestedEnumbookings_meal_planWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.bookings_meal_plan | Enumbookings_meal_planFieldRefInput<$PrismaModel>
    in?: $Enums.bookings_meal_plan[]
    notIn?: $Enums.bookings_meal_plan[]
    not?: NestedEnumbookings_meal_planWithAggregatesFilter<$PrismaModel> | $Enums.bookings_meal_plan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumbookings_meal_planFilter<$PrismaModel>
    _max?: NestedEnumbookings_meal_planFilter<$PrismaModel>
  }

  export type NestedEnumbookings_room_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.bookings_room_category | Enumbookings_room_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.bookings_room_category[]
    notIn?: $Enums.bookings_room_category[]
    not?: NestedEnumbookings_room_categoryWithAggregatesFilter<$PrismaModel> | $Enums.bookings_room_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumbookings_room_categoryFilter<$PrismaModel>
    _max?: NestedEnumbookings_room_categoryFilter<$PrismaModel>
  }

  export type NestedEnumbookings_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.bookings_status | Enumbookings_statusFieldRefInput<$PrismaModel>
    in?: $Enums.bookings_status[]
    notIn?: $Enums.bookings_status[]
    not?: NestedEnumbookings_statusWithAggregatesFilter<$PrismaModel> | $Enums.bookings_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumbookings_statusFilter<$PrismaModel>
    _max?: NestedEnumbookings_statusFilter<$PrismaModel>
  }

  export type NestedEnumshared_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.shared_status | Enumshared_statusFieldRefInput<$PrismaModel>
    in?: $Enums.shared_status[]
    notIn?: $Enums.shared_status[]
    not?: NestedEnumshared_statusFilter<$PrismaModel> | $Enums.shared_status
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumshared_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.shared_status | Enumshared_statusFieldRefInput<$PrismaModel>
    in?: $Enums.shared_status[]
    notIn?: $Enums.shared_status[]
    not?: NestedEnumshared_statusWithAggregatesFilter<$PrismaModel> | $Enums.shared_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumshared_statusFilter<$PrismaModel>
    _max?: NestedEnumshared_statusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnuminvoices_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.invoices_status | Enuminvoices_statusFieldRefInput<$PrismaModel>
    in?: $Enums.invoices_status[]
    notIn?: $Enums.invoices_status[]
    not?: NestedEnuminvoices_statusFilter<$PrismaModel> | $Enums.invoices_status
  }

  export type NestedEnuminvoices_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.invoices_status | Enuminvoices_statusFieldRefInput<$PrismaModel>
    in?: $Enums.invoices_status[]
    notIn?: $Enums.invoices_status[]
    not?: NestedEnuminvoices_statusWithAggregatesFilter<$PrismaModel> | $Enums.invoices_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnuminvoices_statusFilter<$PrismaModel>
    _max?: NestedEnuminvoices_statusFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumnotifications_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.notifications_type | Enumnotifications_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notifications_type[]
    notIn?: $Enums.notifications_type[]
    not?: NestedEnumnotifications_typeFilter<$PrismaModel> | $Enums.notifications_type
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumnotifications_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.notifications_type | Enumnotifications_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notifications_type[]
    notIn?: $Enums.notifications_type[]
    not?: NestedEnumnotifications_typeWithAggregatesFilter<$PrismaModel> | $Enums.notifications_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumnotifications_typeFilter<$PrismaModel>
    _max?: NestedEnumnotifications_typeFilter<$PrismaModel>
  }

  export type NestedEnumpayments_payment_methodFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_payment_method | Enumpayments_payment_methodFieldRefInput<$PrismaModel>
    in?: $Enums.payments_payment_method[]
    notIn?: $Enums.payments_payment_method[]
    not?: NestedEnumpayments_payment_methodFilter<$PrismaModel> | $Enums.payments_payment_method
  }

  export type NestedEnumpayments_payment_methodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payments_payment_method | Enumpayments_payment_methodFieldRefInput<$PrismaModel>
    in?: $Enums.payments_payment_method[]
    notIn?: $Enums.payments_payment_method[]
    not?: NestedEnumpayments_payment_methodWithAggregatesFilter<$PrismaModel> | $Enums.payments_payment_method
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumpayments_payment_methodFilter<$PrismaModel>
    _max?: NestedEnumpayments_payment_methodFilter<$PrismaModel>
  }

  export type NestedEnumusers_roleFilter<$PrismaModel = never> = {
    equals?: $Enums.users_role | Enumusers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.users_role[]
    notIn?: $Enums.users_role[]
    not?: NestedEnumusers_roleFilter<$PrismaModel> | $Enums.users_role
  }

  export type NestedEnumusers_roleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.users_role | Enumusers_roleFieldRefInput<$PrismaModel>
    in?: $Enums.users_role[]
    notIn?: $Enums.users_role[]
    not?: NestedEnumusers_roleWithAggregatesFilter<$PrismaModel> | $Enums.users_role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusers_roleFilter<$PrismaModel>
    _max?: NestedEnumusers_roleFilter<$PrismaModel>
  }

  export type NestedEnumquotes_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.quotes_status | Enumquotes_statusFieldRefInput<$PrismaModel>
    in?: $Enums.quotes_status[]
    notIn?: $Enums.quotes_status[]
    not?: NestedEnumquotes_statusFilter<$PrismaModel> | $Enums.quotes_status
  }

  export type NestedEnumquotes_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.quotes_status | Enumquotes_statusFieldRefInput<$PrismaModel>
    in?: $Enums.quotes_status[]
    notIn?: $Enums.quotes_status[]
    not?: NestedEnumquotes_statusWithAggregatesFilter<$PrismaModel> | $Enums.quotes_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumquotes_statusFilter<$PrismaModel>
    _max?: NestedEnumquotes_statusFilter<$PrismaModel>
  }

  export type NestedEnumrack_rates_travel_periodFilter<$PrismaModel = never> = {
    equals?: $Enums.rack_rates_travel_period | Enumrack_rates_travel_periodFieldRefInput<$PrismaModel>
    in?: $Enums.rack_rates_travel_period[]
    notIn?: $Enums.rack_rates_travel_period[]
    not?: NestedEnumrack_rates_travel_periodFilter<$PrismaModel> | $Enums.rack_rates_travel_period
  }

  export type NestedEnumrack_rates_meal_planFilter<$PrismaModel = never> = {
    equals?: $Enums.rack_rates_meal_plan | Enumrack_rates_meal_planFieldRefInput<$PrismaModel>
    in?: $Enums.rack_rates_meal_plan[]
    notIn?: $Enums.rack_rates_meal_plan[]
    not?: NestedEnumrack_rates_meal_planFilter<$PrismaModel> | $Enums.rack_rates_meal_plan
  }

  export type NestedEnumrack_rates_room_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.rack_rates_room_category | Enumrack_rates_room_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.rack_rates_room_category[]
    notIn?: $Enums.rack_rates_room_category[]
    not?: NestedEnumrack_rates_room_categoryFilter<$PrismaModel> | $Enums.rack_rates_room_category
  }

  export type NestedEnumrack_rates_travel_periodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rack_rates_travel_period | Enumrack_rates_travel_periodFieldRefInput<$PrismaModel>
    in?: $Enums.rack_rates_travel_period[]
    notIn?: $Enums.rack_rates_travel_period[]
    not?: NestedEnumrack_rates_travel_periodWithAggregatesFilter<$PrismaModel> | $Enums.rack_rates_travel_period
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrack_rates_travel_periodFilter<$PrismaModel>
    _max?: NestedEnumrack_rates_travel_periodFilter<$PrismaModel>
  }

  export type NestedEnumrack_rates_meal_planWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rack_rates_meal_plan | Enumrack_rates_meal_planFieldRefInput<$PrismaModel>
    in?: $Enums.rack_rates_meal_plan[]
    notIn?: $Enums.rack_rates_meal_plan[]
    not?: NestedEnumrack_rates_meal_planWithAggregatesFilter<$PrismaModel> | $Enums.rack_rates_meal_plan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrack_rates_meal_planFilter<$PrismaModel>
    _max?: NestedEnumrack_rates_meal_planFilter<$PrismaModel>
  }

  export type NestedEnumrack_rates_room_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rack_rates_room_category | Enumrack_rates_room_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.rack_rates_room_category[]
    notIn?: $Enums.rack_rates_room_category[]
    not?: NestedEnumrack_rates_room_categoryWithAggregatesFilter<$PrismaModel> | $Enums.rack_rates_room_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrack_rates_room_categoryFilter<$PrismaModel>
    _max?: NestedEnumrack_rates_room_categoryFilter<$PrismaModel>
  }

  export type NestedEnumrate_cards_travel_periodFilter<$PrismaModel = never> = {
    equals?: $Enums.rate_cards_travel_period | Enumrate_cards_travel_periodFieldRefInput<$PrismaModel>
    in?: $Enums.rate_cards_travel_period[]
    notIn?: $Enums.rate_cards_travel_period[]
    not?: NestedEnumrate_cards_travel_periodFilter<$PrismaModel> | $Enums.rate_cards_travel_period
  }

  export type NestedEnumrate_cards_meal_planFilter<$PrismaModel = never> = {
    equals?: $Enums.rate_cards_meal_plan | Enumrate_cards_meal_planFieldRefInput<$PrismaModel>
    in?: $Enums.rate_cards_meal_plan[]
    notIn?: $Enums.rate_cards_meal_plan[]
    not?: NestedEnumrate_cards_meal_planFilter<$PrismaModel> | $Enums.rate_cards_meal_plan
  }

  export type NestedEnumrate_cards_room_categoryFilter<$PrismaModel = never> = {
    equals?: $Enums.rate_cards_room_category | Enumrate_cards_room_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.rate_cards_room_category[]
    notIn?: $Enums.rate_cards_room_category[]
    not?: NestedEnumrate_cards_room_categoryFilter<$PrismaModel> | $Enums.rate_cards_room_category
  }

  export type NestedEnumrate_cards_travel_periodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rate_cards_travel_period | Enumrate_cards_travel_periodFieldRefInput<$PrismaModel>
    in?: $Enums.rate_cards_travel_period[]
    notIn?: $Enums.rate_cards_travel_period[]
    not?: NestedEnumrate_cards_travel_periodWithAggregatesFilter<$PrismaModel> | $Enums.rate_cards_travel_period
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrate_cards_travel_periodFilter<$PrismaModel>
    _max?: NestedEnumrate_cards_travel_periodFilter<$PrismaModel>
  }

  export type NestedEnumrate_cards_meal_planWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rate_cards_meal_plan | Enumrate_cards_meal_planFieldRefInput<$PrismaModel>
    in?: $Enums.rate_cards_meal_plan[]
    notIn?: $Enums.rate_cards_meal_plan[]
    not?: NestedEnumrate_cards_meal_planWithAggregatesFilter<$PrismaModel> | $Enums.rate_cards_meal_plan
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrate_cards_meal_planFilter<$PrismaModel>
    _max?: NestedEnumrate_cards_meal_planFilter<$PrismaModel>
  }

  export type NestedEnumrate_cards_room_categoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.rate_cards_room_category | Enumrate_cards_room_categoryFieldRefInput<$PrismaModel>
    in?: $Enums.rate_cards_room_category[]
    notIn?: $Enums.rate_cards_room_category[]
    not?: NestedEnumrate_cards_room_categoryWithAggregatesFilter<$PrismaModel> | $Enums.rate_cards_room_category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumrate_cards_room_categoryFilter<$PrismaModel>
    _max?: NestedEnumrate_cards_room_categoryFilter<$PrismaModel>
  }

  export type NestedEnumseasons_period_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.seasons_period_type | Enumseasons_period_typeFieldRefInput<$PrismaModel>
    in?: $Enums.seasons_period_type[]
    notIn?: $Enums.seasons_period_type[]
    not?: NestedEnumseasons_period_typeFilter<$PrismaModel> | $Enums.seasons_period_type
  }

  export type NestedEnumseasons_period_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.seasons_period_type | Enumseasons_period_typeFieldRefInput<$PrismaModel>
    in?: $Enums.seasons_period_type[]
    notIn?: $Enums.seasons_period_type[]
    not?: NestedEnumseasons_period_typeWithAggregatesFilter<$PrismaModel> | $Enums.seasons_period_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumseasons_period_typeFilter<$PrismaModel>
    _max?: NestedEnumseasons_period_typeFilter<$PrismaModel>
  }

  export type NestedEnumtransportation_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.transportation_type | Enumtransportation_typeFieldRefInput<$PrismaModel>
    in?: $Enums.transportation_type[]
    notIn?: $Enums.transportation_type[]
    not?: NestedEnumtransportation_typeFilter<$PrismaModel> | $Enums.transportation_type
  }

  export type NestedEnumtransportation_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.transportation_status | Enumtransportation_statusFieldRefInput<$PrismaModel>
    in?: $Enums.transportation_status[]
    notIn?: $Enums.transportation_status[]
    not?: NestedEnumtransportation_statusFilter<$PrismaModel> | $Enums.transportation_status
  }

  export type NestedEnumtransportation_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.transportation_type | Enumtransportation_typeFieldRefInput<$PrismaModel>
    in?: $Enums.transportation_type[]
    notIn?: $Enums.transportation_type[]
    not?: NestedEnumtransportation_typeWithAggregatesFilter<$PrismaModel> | $Enums.transportation_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtransportation_typeFilter<$PrismaModel>
    _max?: NestedEnumtransportation_typeFilter<$PrismaModel>
  }

  export type NestedEnumtransportation_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.transportation_status | Enumtransportation_statusFieldRefInput<$PrismaModel>
    in?: $Enums.transportation_status[]
    notIn?: $Enums.transportation_status[]
    not?: NestedEnumtransportation_statusWithAggregatesFilter<$PrismaModel> | $Enums.transportation_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtransportation_statusFilter<$PrismaModel>
    _max?: NestedEnumtransportation_statusFilter<$PrismaModel>
  }

  export type NestedEnumusers_statusFilter<$PrismaModel = never> = {
    equals?: $Enums.users_status | Enumusers_statusFieldRefInput<$PrismaModel>
    in?: $Enums.users_status[]
    notIn?: $Enums.users_status[]
    not?: NestedEnumusers_statusFilter<$PrismaModel> | $Enums.users_status
  }

  export type NestedEnumusers_statusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.users_status | Enumusers_statusFieldRefInput<$PrismaModel>
    in?: $Enums.users_status[]
    notIn?: $Enums.users_status[]
    not?: NestedEnumusers_statusWithAggregatesFilter<$PrismaModel> | $Enums.users_status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumusers_statusFilter<$PrismaModel>
    _max?: NestedEnumusers_statusFilter<$PrismaModel>
  }

  export type usersCreateWithoutAccountsInput = {
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    image?: string | null
    bookings?: bookingsCreateNestedManyWithoutUserInput
    cancellations?: cancellationsCreateNestedManyWithoutUserInput
    events?: events_logCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    branch?: branchesCreateNestedOneWithoutUsersInput
    users_branches?: users_branchesCreateNestedManyWithoutUserInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutAccountsInput = {
    id?: number
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    branch_id?: number | null
    image?: string | null
    bookings?: bookingsUncheckedCreateNestedManyWithoutUserInput
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutUserInput
    events?: events_logUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    users_branches?: users_branchesUncheckedCreateNestedManyWithoutUserInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutAccountsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAccountsInput, usersUncheckedCreateWithoutAccountsInput>
  }

  export type usersUpsertWithoutAccountsInput = {
    update: XOR<usersUpdateWithoutAccountsInput, usersUncheckedUpdateWithoutAccountsInput>
    create: XOR<usersCreateWithoutAccountsInput, usersUncheckedCreateWithoutAccountsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAccountsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAccountsInput, usersUncheckedUpdateWithoutAccountsInput>
  }

  export type usersUpdateWithoutAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: bookingsUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUpdateManyWithoutUserNestedInput
    events?: events_logUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    branch?: branchesUpdateOneWithoutUsersNestedInput
    users_branches?: users_branchesUpdateManyWithoutUserNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: bookingsUncheckedUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUncheckedUpdateManyWithoutUserNestedInput
    events?: events_logUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    users_branches?: users_branchesUncheckedUpdateManyWithoutUserNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutBookingsInput = {
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    image?: string | null
    accounts?: accountsCreateNestedManyWithoutUserInput
    cancellations?: cancellationsCreateNestedManyWithoutUserInput
    events?: events_logCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    branch?: branchesCreateNestedOneWithoutUsersInput
    users_branches?: users_branchesCreateNestedManyWithoutUserInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    branch_id?: number | null
    image?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutUserInput
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutUserInput
    events?: events_logUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    users_branches?: users_branchesUncheckedCreateNestedManyWithoutUserInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutBookingsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBookingsInput, usersUncheckedCreateWithoutBookingsInput>
  }

  export type clientsCreateWithoutBookingsInput = {
    name: string
    email: string
    phone: string
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone: string
    branch?: branchesCreateNestedOneWithoutClientsInput
    invoices?: invoicesCreateNestedManyWithoutClientInput
    quotes?: quotesCreateNestedManyWithoutClientInput
  }

  export type clientsUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    email: string
    phone: string
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone: string
    branch_id?: number | null
    invoices?: invoicesUncheckedCreateNestedManyWithoutClientInput
    quotes?: quotesUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientsCreateOrConnectWithoutBookingsInput = {
    where: clientsWhereUniqueInput
    create: XOR<clientsCreateWithoutBookingsInput, clientsUncheckedCreateWithoutBookingsInput>
  }

  export type hotelsCreateWithoutBookingsInput = {
    name: string
    location: string
    contact_email: string
    contact_phone: string
    commission_rate?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    enc_phone: string
    hotel_policies?: hotel_policiesCreateNestedManyWithoutHotelInput
    rack_rates?: rack_ratesCreateNestedManyWithoutHotelInput
    rate_cards?: rate_cardsCreateNestedManyWithoutHotelsInput
  }

  export type hotelsUncheckedCreateWithoutBookingsInput = {
    id?: number
    name: string
    location: string
    contact_email: string
    contact_phone: string
    commission_rate?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    enc_phone: string
    hotel_policies?: hotel_policiesUncheckedCreateNestedManyWithoutHotelInput
    rack_rates?: rack_ratesUncheckedCreateNestedManyWithoutHotelInput
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutHotelsInput
  }

  export type hotelsCreateOrConnectWithoutBookingsInput = {
    where: hotelsWhereUniqueInput
    create: XOR<hotelsCreateWithoutBookingsInput, hotelsUncheckedCreateWithoutBookingsInput>
  }

  export type invoicesCreateWithoutBookingInput = {
    invoice_number: string
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    client: clientsCreateNestedOneWithoutInvoicesInput
    quote: quotesCreateNestedOneWithoutInvoiceInput
    payments?: paymentsCreateNestedManyWithoutInvoiceInput
    reminders?: remindersCreateNestedManyWithoutInvoicesInput
    users?: usersCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutBookingInput = {
    id?: number
    invoice_number: string
    quote_id: number
    client_id: number
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoiceInput
    reminders?: remindersUncheckedCreateNestedManyWithoutInvoicesInput
    users?: usersUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutBookingInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutBookingInput, invoicesUncheckedCreateWithoutBookingInput>
  }

  export type quotesCreateWithoutBookingInput = {
    status?: $Enums.quotes_status
    expiration_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    invoice?: invoicesCreateNestedOneWithoutQuoteInput
    client: clientsCreateNestedOneWithoutQuotesInput
    rate_card: rate_cardsCreateNestedOneWithoutQuotesInput
  }

  export type quotesUncheckedCreateWithoutBookingInput = {
    id?: number
    rate_card_id: number
    client_id: number
    status?: $Enums.quotes_status
    expiration_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    invoice?: invoicesUncheckedCreateNestedOneWithoutQuoteInput
  }

  export type quotesCreateOrConnectWithoutBookingInput = {
    where: quotesWhereUniqueInput
    create: XOR<quotesCreateWithoutBookingInput, quotesUncheckedCreateWithoutBookingInput>
  }

  export type cancellationsCreateWithoutBookingInput = {
    cancellation_date?: Date | string
    reason?: string | null
    hotel_charges: number
    credit_note_url?: string | null
    refund_amount: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    user: usersCreateNestedOneWithoutCancellationsInput
  }

  export type cancellationsUncheckedCreateWithoutBookingInput = {
    id?: number
    cancellation_date?: Date | string
    reason?: string | null
    hotel_charges: number
    credit_note_url?: string | null
    refund_amount: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    processed_by: number
    status?: $Enums.shared_status
  }

  export type cancellationsCreateOrConnectWithoutBookingInput = {
    where: cancellationsWhereUniqueInput
    create: XOR<cancellationsCreateWithoutBookingInput, cancellationsUncheckedCreateWithoutBookingInput>
  }

  export type cancellationsCreateManyBookingInputEnvelope = {
    data: cancellationsCreateManyBookingInput | cancellationsCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type transportationCreateWithoutBookingsInput = {
    type: $Enums.transportation_type
    provider: string
    booking_ref?: string | null
    departure_date: Date | string
    return_date?: Date | string | null
    departure_point: string
    arrival_point: string
    cost: number
    status?: $Enums.transportation_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type transportationUncheckedCreateWithoutBookingsInput = {
    id?: number
    type: $Enums.transportation_type
    provider: string
    booking_ref?: string | null
    departure_date: Date | string
    return_date?: Date | string | null
    departure_point: string
    arrival_point: string
    cost: number
    status?: $Enums.transportation_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type transportationCreateOrConnectWithoutBookingsInput = {
    where: transportationWhereUniqueInput
    create: XOR<transportationCreateWithoutBookingsInput, transportationUncheckedCreateWithoutBookingsInput>
  }

  export type transportationCreateManyBookingsInputEnvelope = {
    data: transportationCreateManyBookingsInput | transportationCreateManyBookingsInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutBookingsInput = {
    amount: number
    payment_date?: Date | string
    payment_method: $Enums.payments_payment_method
    transaction_id?: string | null
    receipt_url?: string | null
    is_confirmed?: boolean
    confirmed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone?: string | null
    phone?: string | null
    invoice: invoicesCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutBookingsInput = {
    id?: number
    invoice_id: number
    amount: number
    payment_date?: Date | string
    payment_method: $Enums.payments_payment_method
    transaction_id?: string | null
    receipt_url?: string | null
    is_confirmed?: boolean
    confirmed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone?: string | null
    phone?: string | null
  }

  export type paymentsCreateOrConnectWithoutBookingsInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutBookingsInput, paymentsUncheckedCreateWithoutBookingsInput>
  }

  export type usersUpsertWithoutBookingsInput = {
    update: XOR<usersUpdateWithoutBookingsInput, usersUncheckedUpdateWithoutBookingsInput>
    create: XOR<usersCreateWithoutBookingsInput, usersUncheckedCreateWithoutBookingsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutBookingsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutBookingsInput, usersUncheckedUpdateWithoutBookingsInput>
  }

  export type usersUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUpdateManyWithoutUserNestedInput
    events?: events_logUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    branch?: branchesUpdateOneWithoutUsersNestedInput
    users_branches?: users_branchesUpdateManyWithoutUserNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUncheckedUpdateManyWithoutUserNestedInput
    events?: events_logUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    users_branches?: users_branchesUncheckedUpdateManyWithoutUserNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type clientsUpsertWithoutBookingsInput = {
    update: XOR<clientsUpdateWithoutBookingsInput, clientsUncheckedUpdateWithoutBookingsInput>
    create: XOR<clientsCreateWithoutBookingsInput, clientsUncheckedCreateWithoutBookingsInput>
    where?: clientsWhereInput
  }

  export type clientsUpdateToOneWithWhereWithoutBookingsInput = {
    where?: clientsWhereInput
    data: XOR<clientsUpdateWithoutBookingsInput, clientsUncheckedUpdateWithoutBookingsInput>
  }

  export type clientsUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    branch?: branchesUpdateOneWithoutClientsNestedInput
    invoices?: invoicesUpdateManyWithoutClientNestedInput
    quotes?: quotesUpdateManyWithoutClientNestedInput
  }

  export type clientsUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    invoices?: invoicesUncheckedUpdateManyWithoutClientNestedInput
    quotes?: quotesUncheckedUpdateManyWithoutClientNestedInput
  }

  export type hotelsUpsertWithoutBookingsInput = {
    update: XOR<hotelsUpdateWithoutBookingsInput, hotelsUncheckedUpdateWithoutBookingsInput>
    create: XOR<hotelsCreateWithoutBookingsInput, hotelsUncheckedCreateWithoutBookingsInput>
    where?: hotelsWhereInput
  }

  export type hotelsUpdateToOneWithWhereWithoutBookingsInput = {
    where?: hotelsWhereInput
    data: XOR<hotelsUpdateWithoutBookingsInput, hotelsUncheckedUpdateWithoutBookingsInput>
  }

  export type hotelsUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    hotel_policies?: hotel_policiesUpdateManyWithoutHotelNestedInput
    rack_rates?: rack_ratesUpdateManyWithoutHotelNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutHotelsNestedInput
  }

  export type hotelsUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    hotel_policies?: hotel_policiesUncheckedUpdateManyWithoutHotelNestedInput
    rack_rates?: rack_ratesUncheckedUpdateManyWithoutHotelNestedInput
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutHotelsNestedInput
  }

  export type invoicesUpsertWithoutBookingInput = {
    update: XOR<invoicesUpdateWithoutBookingInput, invoicesUncheckedUpdateWithoutBookingInput>
    create: XOR<invoicesCreateWithoutBookingInput, invoicesUncheckedCreateWithoutBookingInput>
    where?: invoicesWhereInput
  }

  export type invoicesUpdateToOneWithWhereWithoutBookingInput = {
    where?: invoicesWhereInput
    data: XOR<invoicesUpdateWithoutBookingInput, invoicesUncheckedUpdateWithoutBookingInput>
  }

  export type invoicesUpdateWithoutBookingInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    client?: clientsUpdateOneRequiredWithoutInvoicesNestedInput
    quote?: quotesUpdateOneRequiredWithoutInvoiceNestedInput
    payments?: paymentsUpdateManyWithoutInvoiceNestedInput
    reminders?: remindersUpdateManyWithoutInvoicesNestedInput
    users?: usersUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    payments?: paymentsUncheckedUpdateManyWithoutInvoiceNestedInput
    reminders?: remindersUncheckedUpdateManyWithoutInvoicesNestedInput
    users?: usersUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type quotesUpsertWithoutBookingInput = {
    update: XOR<quotesUpdateWithoutBookingInput, quotesUncheckedUpdateWithoutBookingInput>
    create: XOR<quotesCreateWithoutBookingInput, quotesUncheckedCreateWithoutBookingInput>
    where?: quotesWhereInput
  }

  export type quotesUpdateToOneWithWhereWithoutBookingInput = {
    where?: quotesWhereInput
    data: XOR<quotesUpdateWithoutBookingInput, quotesUncheckedUpdateWithoutBookingInput>
  }

  export type quotesUpdateWithoutBookingInput = {
    status?: Enumquotes_statusFieldUpdateOperationsInput | $Enums.quotes_status
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    invoice?: invoicesUpdateOneWithoutQuoteNestedInput
    client?: clientsUpdateOneRequiredWithoutQuotesNestedInput
    rate_card?: rate_cardsUpdateOneRequiredWithoutQuotesNestedInput
  }

  export type quotesUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate_card_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    status?: Enumquotes_statusFieldUpdateOperationsInput | $Enums.quotes_status
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    invoice?: invoicesUncheckedUpdateOneWithoutQuoteNestedInput
  }

  export type cancellationsUpsertWithWhereUniqueWithoutBookingInput = {
    where: cancellationsWhereUniqueInput
    update: XOR<cancellationsUpdateWithoutBookingInput, cancellationsUncheckedUpdateWithoutBookingInput>
    create: XOR<cancellationsCreateWithoutBookingInput, cancellationsUncheckedCreateWithoutBookingInput>
  }

  export type cancellationsUpdateWithWhereUniqueWithoutBookingInput = {
    where: cancellationsWhereUniqueInput
    data: XOR<cancellationsUpdateWithoutBookingInput, cancellationsUncheckedUpdateWithoutBookingInput>
  }

  export type cancellationsUpdateManyWithWhereWithoutBookingInput = {
    where: cancellationsScalarWhereInput
    data: XOR<cancellationsUpdateManyMutationInput, cancellationsUncheckedUpdateManyWithoutBookingInput>
  }

  export type cancellationsScalarWhereInput = {
    AND?: cancellationsScalarWhereInput | cancellationsScalarWhereInput[]
    OR?: cancellationsScalarWhereInput[]
    NOT?: cancellationsScalarWhereInput | cancellationsScalarWhereInput[]
    id?: IntFilter<"cancellations"> | number
    booking_id?: IntFilter<"cancellations"> | number
    cancellation_date?: DateTimeFilter<"cancellations"> | Date | string
    reason?: StringNullableFilter<"cancellations"> | string | null
    hotel_charges?: FloatFilter<"cancellations"> | number
    credit_note_url?: StringNullableFilter<"cancellations"> | string | null
    refund_amount?: FloatFilter<"cancellations"> | number
    created_at?: DateTimeFilter<"cancellations"> | Date | string
    updated_at?: DateTimeNullableFilter<"cancellations"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"cancellations"> | Date | string | null
    processed_by?: IntFilter<"cancellations"> | number
    status?: Enumshared_statusFilter<"cancellations"> | $Enums.shared_status
  }

  export type transportationUpsertWithWhereUniqueWithoutBookingsInput = {
    where: transportationWhereUniqueInput
    update: XOR<transportationUpdateWithoutBookingsInput, transportationUncheckedUpdateWithoutBookingsInput>
    create: XOR<transportationCreateWithoutBookingsInput, transportationUncheckedCreateWithoutBookingsInput>
  }

  export type transportationUpdateWithWhereUniqueWithoutBookingsInput = {
    where: transportationWhereUniqueInput
    data: XOR<transportationUpdateWithoutBookingsInput, transportationUncheckedUpdateWithoutBookingsInput>
  }

  export type transportationUpdateManyWithWhereWithoutBookingsInput = {
    where: transportationScalarWhereInput
    data: XOR<transportationUpdateManyMutationInput, transportationUncheckedUpdateManyWithoutBookingsInput>
  }

  export type transportationScalarWhereInput = {
    AND?: transportationScalarWhereInput | transportationScalarWhereInput[]
    OR?: transportationScalarWhereInput[]
    NOT?: transportationScalarWhereInput | transportationScalarWhereInput[]
    id?: IntFilter<"transportation"> | number
    type?: Enumtransportation_typeFilter<"transportation"> | $Enums.transportation_type
    provider?: StringFilter<"transportation"> | string
    booking_ref?: StringNullableFilter<"transportation"> | string | null
    departure_date?: DateTimeFilter<"transportation"> | Date | string
    return_date?: DateTimeNullableFilter<"transportation"> | Date | string | null
    departure_point?: StringFilter<"transportation"> | string
    arrival_point?: StringFilter<"transportation"> | string
    cost?: FloatFilter<"transportation"> | number
    booking_id?: IntFilter<"transportation"> | number
    status?: Enumtransportation_statusFilter<"transportation"> | $Enums.transportation_status
    created_at?: DateTimeFilter<"transportation"> | Date | string
    updated_at?: DateTimeNullableFilter<"transportation"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"transportation"> | Date | string | null
  }

  export type paymentsUpsertWithWhereUniqueWithoutBookingsInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutBookingsInput, paymentsUncheckedUpdateWithoutBookingsInput>
    create: XOR<paymentsCreateWithoutBookingsInput, paymentsUncheckedCreateWithoutBookingsInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutBookingsInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutBookingsInput, paymentsUncheckedUpdateWithoutBookingsInput>
  }

  export type paymentsUpdateManyWithWhereWithoutBookingsInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutBookingsInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    id?: IntFilter<"payments"> | number
    invoice_id?: IntFilter<"payments"> | number
    amount?: FloatFilter<"payments"> | number
    payment_date?: DateTimeFilter<"payments"> | Date | string
    payment_method?: Enumpayments_payment_methodFilter<"payments"> | $Enums.payments_payment_method
    transaction_id?: StringNullableFilter<"payments"> | string | null
    receipt_url?: StringNullableFilter<"payments"> | string | null
    is_confirmed?: BoolFilter<"payments"> | boolean
    confirmed_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    created_at?: DateTimeFilter<"payments"> | Date | string
    updated_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    public_id?: StringFilter<"payments"> | string
    status?: Enumshared_statusFilter<"payments"> | $Enums.shared_status
    enc_phone?: StringNullableFilter<"payments"> | string | null
    phone?: StringNullableFilter<"payments"> | string | null
  }

  export type bookingsCreateWithoutCancellationsInput = {
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    user: usersCreateNestedOneWithoutBookingsInput
    client: clientsCreateNestedOneWithoutBookingsInput
    hotel: hotelsCreateNestedOneWithoutBookingsInput
    invoice?: invoicesCreateNestedOneWithoutBookingInput
    quote: quotesCreateNestedOneWithoutBookingInput
    transportation?: transportationCreateNestedManyWithoutBookingsInput
    payments?: paymentsCreateNestedManyWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutCancellationsInput = {
    id?: number
    quote_id: number
    client_id: number
    hotel_id: number
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    agent_id: number
    invoiceid?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    transportation?: transportationUncheckedCreateNestedManyWithoutBookingsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingsInput
  }

  export type bookingsCreateOrConnectWithoutCancellationsInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutCancellationsInput, bookingsUncheckedCreateWithoutCancellationsInput>
  }

  export type usersCreateWithoutCancellationsInput = {
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    image?: string | null
    accounts?: accountsCreateNestedManyWithoutUserInput
    bookings?: bookingsCreateNestedManyWithoutUserInput
    events?: events_logCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    branch?: branchesCreateNestedOneWithoutUsersInput
    users_branches?: users_branchesCreateNestedManyWithoutUserInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCancellationsInput = {
    id?: number
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    branch_id?: number | null
    image?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutUserInput
    bookings?: bookingsUncheckedCreateNestedManyWithoutUserInput
    events?: events_logUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    users_branches?: users_branchesUncheckedCreateNestedManyWithoutUserInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutCancellationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCancellationsInput, usersUncheckedCreateWithoutCancellationsInput>
  }

  export type bookingsUpsertWithoutCancellationsInput = {
    update: XOR<bookingsUpdateWithoutCancellationsInput, bookingsUncheckedUpdateWithoutCancellationsInput>
    create: XOR<bookingsCreateWithoutCancellationsInput, bookingsUncheckedCreateWithoutCancellationsInput>
    where?: bookingsWhereInput
  }

  export type bookingsUpdateToOneWithWhereWithoutCancellationsInput = {
    where?: bookingsWhereInput
    data: XOR<bookingsUpdateWithoutCancellationsInput, bookingsUncheckedUpdateWithoutCancellationsInput>
  }

  export type bookingsUpdateWithoutCancellationsInput = {
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    user?: usersUpdateOneRequiredWithoutBookingsNestedInput
    client?: clientsUpdateOneRequiredWithoutBookingsNestedInput
    hotel?: hotelsUpdateOneRequiredWithoutBookingsNestedInput
    invoice?: invoicesUpdateOneWithoutBookingNestedInput
    quote?: quotesUpdateOneRequiredWithoutBookingNestedInput
    transportation?: transportationUpdateManyWithoutBookingsNestedInput
    payments?: paymentsUpdateManyWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutCancellationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    agent_id?: IntFieldUpdateOperationsInput | number
    invoiceid?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    transportation?: transportationUncheckedUpdateManyWithoutBookingsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingsNestedInput
  }

  export type usersUpsertWithoutCancellationsInput = {
    update: XOR<usersUpdateWithoutCancellationsInput, usersUncheckedUpdateWithoutCancellationsInput>
    create: XOR<usersCreateWithoutCancellationsInput, usersUncheckedCreateWithoutCancellationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCancellationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCancellationsInput, usersUncheckedUpdateWithoutCancellationsInput>
  }

  export type usersUpdateWithoutCancellationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutUserNestedInput
    bookings?: bookingsUpdateManyWithoutUserNestedInput
    events?: events_logUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    branch?: branchesUpdateOneWithoutUsersNestedInput
    users_branches?: users_branchesUpdateManyWithoutUserNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutCancellationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutUserNestedInput
    bookings?: bookingsUncheckedUpdateManyWithoutUserNestedInput
    events?: events_logUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    users_branches?: users_branchesUncheckedUpdateManyWithoutUserNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type bookingsCreateWithoutClientInput = {
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    user: usersCreateNestedOneWithoutBookingsInput
    hotel: hotelsCreateNestedOneWithoutBookingsInput
    invoice?: invoicesCreateNestedOneWithoutBookingInput
    quote: quotesCreateNestedOneWithoutBookingInput
    cancellations?: cancellationsCreateNestedManyWithoutBookingInput
    transportation?: transportationCreateNestedManyWithoutBookingsInput
    payments?: paymentsCreateNestedManyWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutClientInput = {
    id?: number
    quote_id: number
    hotel_id: number
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    agent_id: number
    invoiceid?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutBookingInput
    transportation?: transportationUncheckedCreateNestedManyWithoutBookingsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingsInput
  }

  export type bookingsCreateOrConnectWithoutClientInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutClientInput, bookingsUncheckedCreateWithoutClientInput>
  }

  export type bookingsCreateManyClientInputEnvelope = {
    data: bookingsCreateManyClientInput | bookingsCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type branchesCreateWithoutClientsInput = {
    name: string
    location: string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    users?: usersCreateNestedManyWithoutBranchInput
    users_branches?: users_branchesCreateNestedManyWithoutBranchInput
  }

  export type branchesUncheckedCreateWithoutClientsInput = {
    id?: number
    name: string
    location: string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    users?: usersUncheckedCreateNestedManyWithoutBranchInput
    users_branches?: users_branchesUncheckedCreateNestedManyWithoutBranchInput
  }

  export type branchesCreateOrConnectWithoutClientsInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutClientsInput, branchesUncheckedCreateWithoutClientsInput>
  }

  export type invoicesCreateWithoutClientInput = {
    invoice_number: string
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsCreateNestedOneWithoutInvoiceInput
    quote: quotesCreateNestedOneWithoutInvoiceInput
    payments?: paymentsCreateNestedManyWithoutInvoiceInput
    reminders?: remindersCreateNestedManyWithoutInvoicesInput
    users?: usersCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutClientInput = {
    id?: number
    invoice_number: string
    quote_id: number
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsUncheckedCreateNestedOneWithoutInvoiceInput
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoiceInput
    reminders?: remindersUncheckedCreateNestedManyWithoutInvoicesInput
    users?: usersUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutClientInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutClientInput, invoicesUncheckedCreateWithoutClientInput>
  }

  export type invoicesCreateManyClientInputEnvelope = {
    data: invoicesCreateManyClientInput | invoicesCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type quotesCreateWithoutClientInput = {
    status?: $Enums.quotes_status
    expiration_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsCreateNestedOneWithoutQuoteInput
    invoice?: invoicesCreateNestedOneWithoutQuoteInput
    rate_card: rate_cardsCreateNestedOneWithoutQuotesInput
  }

  export type quotesUncheckedCreateWithoutClientInput = {
    id?: number
    rate_card_id: number
    status?: $Enums.quotes_status
    expiration_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsUncheckedCreateNestedOneWithoutQuoteInput
    invoice?: invoicesUncheckedCreateNestedOneWithoutQuoteInput
  }

  export type quotesCreateOrConnectWithoutClientInput = {
    where: quotesWhereUniqueInput
    create: XOR<quotesCreateWithoutClientInput, quotesUncheckedCreateWithoutClientInput>
  }

  export type quotesCreateManyClientInputEnvelope = {
    data: quotesCreateManyClientInput | quotesCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type bookingsUpsertWithWhereUniqueWithoutClientInput = {
    where: bookingsWhereUniqueInput
    update: XOR<bookingsUpdateWithoutClientInput, bookingsUncheckedUpdateWithoutClientInput>
    create: XOR<bookingsCreateWithoutClientInput, bookingsUncheckedCreateWithoutClientInput>
  }

  export type bookingsUpdateWithWhereUniqueWithoutClientInput = {
    where: bookingsWhereUniqueInput
    data: XOR<bookingsUpdateWithoutClientInput, bookingsUncheckedUpdateWithoutClientInput>
  }

  export type bookingsUpdateManyWithWhereWithoutClientInput = {
    where: bookingsScalarWhereInput
    data: XOR<bookingsUpdateManyMutationInput, bookingsUncheckedUpdateManyWithoutClientInput>
  }

  export type bookingsScalarWhereInput = {
    AND?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
    OR?: bookingsScalarWhereInput[]
    NOT?: bookingsScalarWhereInput | bookingsScalarWhereInput[]
    id?: IntFilter<"bookings"> | number
    quote_id?: IntFilter<"bookings"> | number
    client_id?: IntFilter<"bookings"> | number
    hotel_id?: IntFilter<"bookings"> | number
    travel_date?: DateTimeFilter<"bookings"> | Date | string
    return_date?: DateTimeFilter<"bookings"> | Date | string
    meal_plan?: Enumbookings_meal_planFilter<"bookings"> | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFilter<"bookings"> | $Enums.bookings_room_category
    status?: Enumbookings_statusFilter<"bookings"> | $Enums.bookings_status
    voucher_url?: StringNullableFilter<"bookings"> | string | null
    agent_id?: IntFilter<"bookings"> | number
    invoiceid?: IntNullableFilter<"bookings"> | number | null
    created_at?: DateTimeFilter<"bookings"> | Date | string
    updated_at?: DateTimeNullableFilter<"bookings"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"bookings"> | Date | string | null
    public_id?: StringFilter<"bookings"> | string
  }

  export type branchesUpsertWithoutClientsInput = {
    update: XOR<branchesUpdateWithoutClientsInput, branchesUncheckedUpdateWithoutClientsInput>
    create: XOR<branchesCreateWithoutClientsInput, branchesUncheckedCreateWithoutClientsInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutClientsInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutClientsInput, branchesUncheckedUpdateWithoutClientsInput>
  }

  export type branchesUpdateWithoutClientsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    users?: usersUpdateManyWithoutBranchNestedInput
    users_branches?: users_branchesUpdateManyWithoutBranchNestedInput
  }

  export type branchesUncheckedUpdateWithoutClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    users?: usersUncheckedUpdateManyWithoutBranchNestedInput
    users_branches?: users_branchesUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type invoicesUpsertWithWhereUniqueWithoutClientInput = {
    where: invoicesWhereUniqueInput
    update: XOR<invoicesUpdateWithoutClientInput, invoicesUncheckedUpdateWithoutClientInput>
    create: XOR<invoicesCreateWithoutClientInput, invoicesUncheckedCreateWithoutClientInput>
  }

  export type invoicesUpdateWithWhereUniqueWithoutClientInput = {
    where: invoicesWhereUniqueInput
    data: XOR<invoicesUpdateWithoutClientInput, invoicesUncheckedUpdateWithoutClientInput>
  }

  export type invoicesUpdateManyWithWhereWithoutClientInput = {
    where: invoicesScalarWhereInput
    data: XOR<invoicesUpdateManyMutationInput, invoicesUncheckedUpdateManyWithoutClientInput>
  }

  export type invoicesScalarWhereInput = {
    AND?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
    OR?: invoicesScalarWhereInput[]
    NOT?: invoicesScalarWhereInput | invoicesScalarWhereInput[]
    id?: IntFilter<"invoices"> | number
    invoice_number?: StringFilter<"invoices"> | string
    quote_id?: IntFilter<"invoices"> | number
    client_id?: IntFilter<"invoices"> | number
    amount?: FloatFilter<"invoices"> | number
    tax_amount?: FloatFilter<"invoices"> | number
    total_amount?: FloatFilter<"invoices"> | number
    due_date?: DateTimeFilter<"invoices"> | Date | string
    status?: Enuminvoices_statusFilter<"invoices"> | $Enums.invoices_status
    created_at?: DateTimeFilter<"invoices"> | Date | string
    updated_at?: DateTimeNullableFilter<"invoices"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"invoices"> | Date | string | null
    public_id?: StringFilter<"invoices"> | string
  }

  export type quotesUpsertWithWhereUniqueWithoutClientInput = {
    where: quotesWhereUniqueInput
    update: XOR<quotesUpdateWithoutClientInput, quotesUncheckedUpdateWithoutClientInput>
    create: XOR<quotesCreateWithoutClientInput, quotesUncheckedCreateWithoutClientInput>
  }

  export type quotesUpdateWithWhereUniqueWithoutClientInput = {
    where: quotesWhereUniqueInput
    data: XOR<quotesUpdateWithoutClientInput, quotesUncheckedUpdateWithoutClientInput>
  }

  export type quotesUpdateManyWithWhereWithoutClientInput = {
    where: quotesScalarWhereInput
    data: XOR<quotesUpdateManyMutationInput, quotesUncheckedUpdateManyWithoutClientInput>
  }

  export type quotesScalarWhereInput = {
    AND?: quotesScalarWhereInput | quotesScalarWhereInput[]
    OR?: quotesScalarWhereInput[]
    NOT?: quotesScalarWhereInput | quotesScalarWhereInput[]
    id?: IntFilter<"quotes"> | number
    rate_card_id?: IntFilter<"quotes"> | number
    client_id?: IntFilter<"quotes"> | number
    status?: Enumquotes_statusFilter<"quotes"> | $Enums.quotes_status
    expiration_date?: DateTimeFilter<"quotes"> | Date | string
    created_at?: DateTimeFilter<"quotes"> | Date | string
    updated_at?: DateTimeNullableFilter<"quotes"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"quotes"> | Date | string | null
    public_id?: StringFilter<"quotes"> | string
  }

  export type hotelsCreateWithoutHotel_policiesInput = {
    name: string
    location: string
    contact_email: string
    contact_phone: string
    commission_rate?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    enc_phone: string
    bookings?: bookingsCreateNestedManyWithoutHotelInput
    rack_rates?: rack_ratesCreateNestedManyWithoutHotelInput
    rate_cards?: rate_cardsCreateNestedManyWithoutHotelsInput
  }

  export type hotelsUncheckedCreateWithoutHotel_policiesInput = {
    id?: number
    name: string
    location: string
    contact_email: string
    contact_phone: string
    commission_rate?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    enc_phone: string
    bookings?: bookingsUncheckedCreateNestedManyWithoutHotelInput
    rack_rates?: rack_ratesUncheckedCreateNestedManyWithoutHotelInput
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutHotelsInput
  }

  export type hotelsCreateOrConnectWithoutHotel_policiesInput = {
    where: hotelsWhereUniqueInput
    create: XOR<hotelsCreateWithoutHotel_policiesInput, hotelsUncheckedCreateWithoutHotel_policiesInput>
  }

  export type seasonsCreateWithoutHotel_policiesInput = {
    name: string
    period_type: $Enums.seasons_period_type
    start_date: Date | string
    end_date: Date | string
    created_at?: Date | string
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    updated_at?: Date | string | null
  }

  export type seasonsUncheckedCreateWithoutHotel_policiesInput = {
    id?: number
    name: string
    period_type: $Enums.seasons_period_type
    start_date: Date | string
    end_date: Date | string
    created_at?: Date | string
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    updated_at?: Date | string | null
  }

  export type seasonsCreateOrConnectWithoutHotel_policiesInput = {
    where: seasonsWhereUniqueInput
    create: XOR<seasonsCreateWithoutHotel_policiesInput, seasonsUncheckedCreateWithoutHotel_policiesInput>
  }

  export type seasonsCreateManyHotel_policiesInputEnvelope = {
    data: seasonsCreateManyHotel_policiesInput | seasonsCreateManyHotel_policiesInput[]
    skipDuplicates?: boolean
  }

  export type hotelsUpsertWithoutHotel_policiesInput = {
    update: XOR<hotelsUpdateWithoutHotel_policiesInput, hotelsUncheckedUpdateWithoutHotel_policiesInput>
    create: XOR<hotelsCreateWithoutHotel_policiesInput, hotelsUncheckedCreateWithoutHotel_policiesInput>
    where?: hotelsWhereInput
  }

  export type hotelsUpdateToOneWithWhereWithoutHotel_policiesInput = {
    where?: hotelsWhereInput
    data: XOR<hotelsUpdateWithoutHotel_policiesInput, hotelsUncheckedUpdateWithoutHotel_policiesInput>
  }

  export type hotelsUpdateWithoutHotel_policiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUpdateManyWithoutHotelNestedInput
    rack_rates?: rack_ratesUpdateManyWithoutHotelNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutHotelsNestedInput
  }

  export type hotelsUncheckedUpdateWithoutHotel_policiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUncheckedUpdateManyWithoutHotelNestedInput
    rack_rates?: rack_ratesUncheckedUpdateManyWithoutHotelNestedInput
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutHotelsNestedInput
  }

  export type seasonsUpsertWithWhereUniqueWithoutHotel_policiesInput = {
    where: seasonsWhereUniqueInput
    update: XOR<seasonsUpdateWithoutHotel_policiesInput, seasonsUncheckedUpdateWithoutHotel_policiesInput>
    create: XOR<seasonsCreateWithoutHotel_policiesInput, seasonsUncheckedCreateWithoutHotel_policiesInput>
  }

  export type seasonsUpdateWithWhereUniqueWithoutHotel_policiesInput = {
    where: seasonsWhereUniqueInput
    data: XOR<seasonsUpdateWithoutHotel_policiesInput, seasonsUncheckedUpdateWithoutHotel_policiesInput>
  }

  export type seasonsUpdateManyWithWhereWithoutHotel_policiesInput = {
    where: seasonsScalarWhereInput
    data: XOR<seasonsUpdateManyMutationInput, seasonsUncheckedUpdateManyWithoutHotel_policiesInput>
  }

  export type seasonsScalarWhereInput = {
    AND?: seasonsScalarWhereInput | seasonsScalarWhereInput[]
    OR?: seasonsScalarWhereInput[]
    NOT?: seasonsScalarWhereInput | seasonsScalarWhereInput[]
    id?: IntFilter<"seasons"> | number
    name?: StringFilter<"seasons"> | string
    period_type?: Enumseasons_period_typeFilter<"seasons"> | $Enums.seasons_period_type
    start_date?: DateTimeFilter<"seasons"> | Date | string
    end_date?: DateTimeFilter<"seasons"> | Date | string
    hotel_policy_id?: IntFilter<"seasons"> | number
    created_at?: DateTimeFilter<"seasons"> | Date | string
    deleted_at?: DateTimeNullableFilter<"seasons"> | Date | string | null
    status?: Enumshared_statusFilter<"seasons"> | $Enums.shared_status
    updated_at?: DateTimeNullableFilter<"seasons"> | Date | string | null
  }

  export type bookingsCreateWithoutHotelInput = {
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    user: usersCreateNestedOneWithoutBookingsInput
    client: clientsCreateNestedOneWithoutBookingsInput
    invoice?: invoicesCreateNestedOneWithoutBookingInput
    quote: quotesCreateNestedOneWithoutBookingInput
    cancellations?: cancellationsCreateNestedManyWithoutBookingInput
    transportation?: transportationCreateNestedManyWithoutBookingsInput
    payments?: paymentsCreateNestedManyWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutHotelInput = {
    id?: number
    quote_id: number
    client_id: number
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    agent_id: number
    invoiceid?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutBookingInput
    transportation?: transportationUncheckedCreateNestedManyWithoutBookingsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingsInput
  }

  export type bookingsCreateOrConnectWithoutHotelInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutHotelInput, bookingsUncheckedCreateWithoutHotelInput>
  }

  export type bookingsCreateManyHotelInputEnvelope = {
    data: bookingsCreateManyHotelInput | bookingsCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type hotel_policiesCreateWithoutHotelInput = {
    cancellation: string
    payment_terms: string
    commission_terms: string
    deleted_at?: Date | string | null
    created_at?: Date | string
    status?: $Enums.shared_status
    updated_at?: Date | string | null
    seasons?: seasonsCreateNestedManyWithoutHotel_policiesInput
  }

  export type hotel_policiesUncheckedCreateWithoutHotelInput = {
    id?: number
    cancellation: string
    payment_terms: string
    commission_terms: string
    deleted_at?: Date | string | null
    created_at?: Date | string
    status?: $Enums.shared_status
    updated_at?: Date | string | null
    seasons?: seasonsUncheckedCreateNestedManyWithoutHotel_policiesInput
  }

  export type hotel_policiesCreateOrConnectWithoutHotelInput = {
    where: hotel_policiesWhereUniqueInput
    create: XOR<hotel_policiesCreateWithoutHotelInput, hotel_policiesUncheckedCreateWithoutHotelInput>
  }

  export type hotel_policiesCreateManyHotelInputEnvelope = {
    data: hotel_policiesCreateManyHotelInput | hotel_policiesCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type rack_ratesCreateWithoutHotelInput = {
    rate: number
    currency?: string
    travel_period: $Enums.rack_rates_travel_period
    meal_plan: $Enums.rack_rates_meal_plan
    room_category: $Enums.rack_rates_room_category
    pdf_url?: string | null
    isProcessed?: boolean
    processed_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    rate_cards?: rate_cardsCreateNestedManyWithoutRack_ratesInput
  }

  export type rack_ratesUncheckedCreateWithoutHotelInput = {
    id?: number
    rate: number
    currency?: string
    travel_period: $Enums.rack_rates_travel_period
    meal_plan: $Enums.rack_rates_meal_plan
    room_category: $Enums.rack_rates_room_category
    pdf_url?: string | null
    isProcessed?: boolean
    processed_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutRack_ratesInput
  }

  export type rack_ratesCreateOrConnectWithoutHotelInput = {
    where: rack_ratesWhereUniqueInput
    create: XOR<rack_ratesCreateWithoutHotelInput, rack_ratesUncheckedCreateWithoutHotelInput>
  }

  export type rack_ratesCreateManyHotelInputEnvelope = {
    data: rack_ratesCreateManyHotelInput | rack_ratesCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type rate_cardsCreateWithoutHotelsInput = {
    name: string
    base_rate: number
    commission_rate?: number | null
    markup_rate?: number | null
    discount_amount?: number | null
    discount_percent?: number | null
    final_rate: number
    currency?: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    quotes?: quotesCreateNestedManyWithoutRate_cardInput
    users: usersCreateNestedOneWithoutRate_cardsInput
    rack_rates: rack_ratesCreateNestedOneWithoutRate_cardsInput
  }

  export type rate_cardsUncheckedCreateWithoutHotelsInput = {
    id?: number
    name: string
    base_rate: number
    commission_rate?: number | null
    markup_rate?: number | null
    discount_amount?: number | null
    discount_percent?: number | null
    final_rate: number
    currency?: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission?: number | null
    is_active?: boolean
    rack_rate_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    created_by: number
    public_id: string
    status?: $Enums.shared_status
    quotes?: quotesUncheckedCreateNestedManyWithoutRate_cardInput
  }

  export type rate_cardsCreateOrConnectWithoutHotelsInput = {
    where: rate_cardsWhereUniqueInput
    create: XOR<rate_cardsCreateWithoutHotelsInput, rate_cardsUncheckedCreateWithoutHotelsInput>
  }

  export type rate_cardsCreateManyHotelsInputEnvelope = {
    data: rate_cardsCreateManyHotelsInput | rate_cardsCreateManyHotelsInput[]
    skipDuplicates?: boolean
  }

  export type bookingsUpsertWithWhereUniqueWithoutHotelInput = {
    where: bookingsWhereUniqueInput
    update: XOR<bookingsUpdateWithoutHotelInput, bookingsUncheckedUpdateWithoutHotelInput>
    create: XOR<bookingsCreateWithoutHotelInput, bookingsUncheckedCreateWithoutHotelInput>
  }

  export type bookingsUpdateWithWhereUniqueWithoutHotelInput = {
    where: bookingsWhereUniqueInput
    data: XOR<bookingsUpdateWithoutHotelInput, bookingsUncheckedUpdateWithoutHotelInput>
  }

  export type bookingsUpdateManyWithWhereWithoutHotelInput = {
    where: bookingsScalarWhereInput
    data: XOR<bookingsUpdateManyMutationInput, bookingsUncheckedUpdateManyWithoutHotelInput>
  }

  export type hotel_policiesUpsertWithWhereUniqueWithoutHotelInput = {
    where: hotel_policiesWhereUniqueInput
    update: XOR<hotel_policiesUpdateWithoutHotelInput, hotel_policiesUncheckedUpdateWithoutHotelInput>
    create: XOR<hotel_policiesCreateWithoutHotelInput, hotel_policiesUncheckedCreateWithoutHotelInput>
  }

  export type hotel_policiesUpdateWithWhereUniqueWithoutHotelInput = {
    where: hotel_policiesWhereUniqueInput
    data: XOR<hotel_policiesUpdateWithoutHotelInput, hotel_policiesUncheckedUpdateWithoutHotelInput>
  }

  export type hotel_policiesUpdateManyWithWhereWithoutHotelInput = {
    where: hotel_policiesScalarWhereInput
    data: XOR<hotel_policiesUpdateManyMutationInput, hotel_policiesUncheckedUpdateManyWithoutHotelInput>
  }

  export type hotel_policiesScalarWhereInput = {
    AND?: hotel_policiesScalarWhereInput | hotel_policiesScalarWhereInput[]
    OR?: hotel_policiesScalarWhereInput[]
    NOT?: hotel_policiesScalarWhereInput | hotel_policiesScalarWhereInput[]
    id?: IntFilter<"hotel_policies"> | number
    cancellation?: StringFilter<"hotel_policies"> | string
    payment_terms?: StringFilter<"hotel_policies"> | string
    commission_terms?: StringFilter<"hotel_policies"> | string
    hotel_id?: IntFilter<"hotel_policies"> | number
    deleted_at?: DateTimeNullableFilter<"hotel_policies"> | Date | string | null
    created_at?: DateTimeFilter<"hotel_policies"> | Date | string
    status?: Enumshared_statusFilter<"hotel_policies"> | $Enums.shared_status
    updated_at?: DateTimeNullableFilter<"hotel_policies"> | Date | string | null
  }

  export type rack_ratesUpsertWithWhereUniqueWithoutHotelInput = {
    where: rack_ratesWhereUniqueInput
    update: XOR<rack_ratesUpdateWithoutHotelInput, rack_ratesUncheckedUpdateWithoutHotelInput>
    create: XOR<rack_ratesCreateWithoutHotelInput, rack_ratesUncheckedCreateWithoutHotelInput>
  }

  export type rack_ratesUpdateWithWhereUniqueWithoutHotelInput = {
    where: rack_ratesWhereUniqueInput
    data: XOR<rack_ratesUpdateWithoutHotelInput, rack_ratesUncheckedUpdateWithoutHotelInput>
  }

  export type rack_ratesUpdateManyWithWhereWithoutHotelInput = {
    where: rack_ratesScalarWhereInput
    data: XOR<rack_ratesUpdateManyMutationInput, rack_ratesUncheckedUpdateManyWithoutHotelInput>
  }

  export type rack_ratesScalarWhereInput = {
    AND?: rack_ratesScalarWhereInput | rack_ratesScalarWhereInput[]
    OR?: rack_ratesScalarWhereInput[]
    NOT?: rack_ratesScalarWhereInput | rack_ratesScalarWhereInput[]
    id?: IntFilter<"rack_rates"> | number
    rate?: FloatFilter<"rack_rates"> | number
    currency?: StringFilter<"rack_rates"> | string
    travel_period?: Enumrack_rates_travel_periodFilter<"rack_rates"> | $Enums.rack_rates_travel_period
    meal_plan?: Enumrack_rates_meal_planFilter<"rack_rates"> | $Enums.rack_rates_meal_plan
    room_category?: Enumrack_rates_room_categoryFilter<"rack_rates"> | $Enums.rack_rates_room_category
    pdf_url?: StringNullableFilter<"rack_rates"> | string | null
    isProcessed?: BoolFilter<"rack_rates"> | boolean
    processed_date?: DateTimeNullableFilter<"rack_rates"> | Date | string | null
    hotel_id?: IntFilter<"rack_rates"> | number
    created_at?: DateTimeFilter<"rack_rates"> | Date | string
    updated_at?: DateTimeNullableFilter<"rack_rates"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"rack_rates"> | Date | string | null
    public_id?: StringFilter<"rack_rates"> | string
    status?: Enumshared_statusFilter<"rack_rates"> | $Enums.shared_status
  }

  export type rate_cardsUpsertWithWhereUniqueWithoutHotelsInput = {
    where: rate_cardsWhereUniqueInput
    update: XOR<rate_cardsUpdateWithoutHotelsInput, rate_cardsUncheckedUpdateWithoutHotelsInput>
    create: XOR<rate_cardsCreateWithoutHotelsInput, rate_cardsUncheckedCreateWithoutHotelsInput>
  }

  export type rate_cardsUpdateWithWhereUniqueWithoutHotelsInput = {
    where: rate_cardsWhereUniqueInput
    data: XOR<rate_cardsUpdateWithoutHotelsInput, rate_cardsUncheckedUpdateWithoutHotelsInput>
  }

  export type rate_cardsUpdateManyWithWhereWithoutHotelsInput = {
    where: rate_cardsScalarWhereInput
    data: XOR<rate_cardsUpdateManyMutationInput, rate_cardsUncheckedUpdateManyWithoutHotelsInput>
  }

  export type rate_cardsScalarWhereInput = {
    AND?: rate_cardsScalarWhereInput | rate_cardsScalarWhereInput[]
    OR?: rate_cardsScalarWhereInput[]
    NOT?: rate_cardsScalarWhereInput | rate_cardsScalarWhereInput[]
    id?: IntFilter<"rate_cards"> | number
    name?: StringFilter<"rate_cards"> | string
    base_rate?: FloatFilter<"rate_cards"> | number
    commission_rate?: FloatNullableFilter<"rate_cards"> | number | null
    markup_rate?: FloatNullableFilter<"rate_cards"> | number | null
    discount_amount?: FloatNullableFilter<"rate_cards"> | number | null
    discount_percent?: FloatNullableFilter<"rate_cards"> | number | null
    final_rate?: FloatFilter<"rate_cards"> | number
    currency?: StringFilter<"rate_cards"> | string
    travel_period?: Enumrate_cards_travel_periodFilter<"rate_cards"> | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFilter<"rate_cards"> | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFilter<"rate_cards"> | $Enums.rate_cards_room_category
    commission?: FloatNullableFilter<"rate_cards"> | number | null
    is_active?: BoolFilter<"rate_cards"> | boolean
    rack_rate_id?: IntFilter<"rate_cards"> | number
    hotel_id?: IntFilter<"rate_cards"> | number
    created_at?: DateTimeFilter<"rate_cards"> | Date | string
    updated_at?: DateTimeNullableFilter<"rate_cards"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"rate_cards"> | Date | string | null
    created_by?: IntFilter<"rate_cards"> | number
    public_id?: StringFilter<"rate_cards"> | string
    status?: Enumshared_statusFilter<"rate_cards"> | $Enums.shared_status
  }

  export type bookingsCreateWithoutInvoiceInput = {
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    user: usersCreateNestedOneWithoutBookingsInput
    client: clientsCreateNestedOneWithoutBookingsInput
    hotel: hotelsCreateNestedOneWithoutBookingsInput
    quote: quotesCreateNestedOneWithoutBookingInput
    cancellations?: cancellationsCreateNestedManyWithoutBookingInput
    transportation?: transportationCreateNestedManyWithoutBookingsInput
    payments?: paymentsCreateNestedManyWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutInvoiceInput = {
    id?: number
    quote_id: number
    client_id: number
    hotel_id: number
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    agent_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutBookingInput
    transportation?: transportationUncheckedCreateNestedManyWithoutBookingsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingsInput
  }

  export type bookingsCreateOrConnectWithoutInvoiceInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutInvoiceInput, bookingsUncheckedCreateWithoutInvoiceInput>
  }

  export type clientsCreateWithoutInvoicesInput = {
    name: string
    email: string
    phone: string
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone: string
    bookings?: bookingsCreateNestedManyWithoutClientInput
    branch?: branchesCreateNestedOneWithoutClientsInput
    quotes?: quotesCreateNestedManyWithoutClientInput
  }

  export type clientsUncheckedCreateWithoutInvoicesInput = {
    id?: number
    name: string
    email: string
    phone: string
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone: string
    branch_id?: number | null
    bookings?: bookingsUncheckedCreateNestedManyWithoutClientInput
    quotes?: quotesUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientsCreateOrConnectWithoutInvoicesInput = {
    where: clientsWhereUniqueInput
    create: XOR<clientsCreateWithoutInvoicesInput, clientsUncheckedCreateWithoutInvoicesInput>
  }

  export type quotesCreateWithoutInvoiceInput = {
    status?: $Enums.quotes_status
    expiration_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsCreateNestedOneWithoutQuoteInput
    client: clientsCreateNestedOneWithoutQuotesInput
    rate_card: rate_cardsCreateNestedOneWithoutQuotesInput
  }

  export type quotesUncheckedCreateWithoutInvoiceInput = {
    id?: number
    rate_card_id: number
    client_id: number
    status?: $Enums.quotes_status
    expiration_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsUncheckedCreateNestedOneWithoutQuoteInput
  }

  export type quotesCreateOrConnectWithoutInvoiceInput = {
    where: quotesWhereUniqueInput
    create: XOR<quotesCreateWithoutInvoiceInput, quotesUncheckedCreateWithoutInvoiceInput>
  }

  export type paymentsCreateWithoutInvoiceInput = {
    amount: number
    payment_date?: Date | string
    payment_method: $Enums.payments_payment_method
    transaction_id?: string | null
    receipt_url?: string | null
    is_confirmed?: boolean
    confirmed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone?: string | null
    phone?: string | null
    bookings?: bookingsCreateNestedManyWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutInvoiceInput = {
    id?: number
    amount: number
    payment_date?: Date | string
    payment_method: $Enums.payments_payment_method
    transaction_id?: string | null
    receipt_url?: string | null
    is_confirmed?: boolean
    confirmed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone?: string | null
    phone?: string | null
    bookings?: bookingsUncheckedCreateNestedManyWithoutPaymentsInput
  }

  export type paymentsCreateOrConnectWithoutInvoiceInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutInvoiceInput, paymentsUncheckedCreateWithoutInvoiceInput>
  }

  export type paymentsCreateManyInvoiceInputEnvelope = {
    data: paymentsCreateManyInvoiceInput | paymentsCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type remindersCreateWithoutInvoicesInput = {
    reminder_date: Date | string
    message: string
    is_sent?: boolean
    sent_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type remindersUncheckedCreateWithoutInvoicesInput = {
    id?: number
    reminder_date: Date | string
    message: string
    is_sent?: boolean
    sent_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type remindersCreateOrConnectWithoutInvoicesInput = {
    where: remindersWhereUniqueInput
    create: XOR<remindersCreateWithoutInvoicesInput, remindersUncheckedCreateWithoutInvoicesInput>
  }

  export type remindersCreateManyInvoicesInputEnvelope = {
    data: remindersCreateManyInvoicesInput | remindersCreateManyInvoicesInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutInvoicesInput = {
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    image?: string | null
    accounts?: accountsCreateNestedManyWithoutUserInput
    bookings?: bookingsCreateNestedManyWithoutUserInput
    cancellations?: cancellationsCreateNestedManyWithoutUserInput
    events?: events_logCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    branch?: branchesCreateNestedOneWithoutUsersInput
    users_branches?: users_branchesCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutInvoicesInput = {
    id?: number
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    branch_id?: number | null
    image?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutUserInput
    bookings?: bookingsUncheckedCreateNestedManyWithoutUserInput
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutUserInput
    events?: events_logUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    users_branches?: users_branchesUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutInvoicesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutInvoicesInput, usersUncheckedCreateWithoutInvoicesInput>
  }

  export type bookingsUpsertWithoutInvoiceInput = {
    update: XOR<bookingsUpdateWithoutInvoiceInput, bookingsUncheckedUpdateWithoutInvoiceInput>
    create: XOR<bookingsCreateWithoutInvoiceInput, bookingsUncheckedCreateWithoutInvoiceInput>
    where?: bookingsWhereInput
  }

  export type bookingsUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: bookingsWhereInput
    data: XOR<bookingsUpdateWithoutInvoiceInput, bookingsUncheckedUpdateWithoutInvoiceInput>
  }

  export type bookingsUpdateWithoutInvoiceInput = {
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    user?: usersUpdateOneRequiredWithoutBookingsNestedInput
    client?: clientsUpdateOneRequiredWithoutBookingsNestedInput
    hotel?: hotelsUpdateOneRequiredWithoutBookingsNestedInput
    quote?: quotesUpdateOneRequiredWithoutBookingNestedInput
    cancellations?: cancellationsUpdateManyWithoutBookingNestedInput
    transportation?: transportationUpdateManyWithoutBookingsNestedInput
    payments?: paymentsUpdateManyWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    agent_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    cancellations?: cancellationsUncheckedUpdateManyWithoutBookingNestedInput
    transportation?: transportationUncheckedUpdateManyWithoutBookingsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingsNestedInput
  }

  export type clientsUpsertWithoutInvoicesInput = {
    update: XOR<clientsUpdateWithoutInvoicesInput, clientsUncheckedUpdateWithoutInvoicesInput>
    create: XOR<clientsCreateWithoutInvoicesInput, clientsUncheckedCreateWithoutInvoicesInput>
    where?: clientsWhereInput
  }

  export type clientsUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: clientsWhereInput
    data: XOR<clientsUpdateWithoutInvoicesInput, clientsUncheckedUpdateWithoutInvoicesInput>
  }

  export type clientsUpdateWithoutInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUpdateManyWithoutClientNestedInput
    branch?: branchesUpdateOneWithoutClientsNestedInput
    quotes?: quotesUpdateManyWithoutClientNestedInput
  }

  export type clientsUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    bookings?: bookingsUncheckedUpdateManyWithoutClientNestedInput
    quotes?: quotesUncheckedUpdateManyWithoutClientNestedInput
  }

  export type quotesUpsertWithoutInvoiceInput = {
    update: XOR<quotesUpdateWithoutInvoiceInput, quotesUncheckedUpdateWithoutInvoiceInput>
    create: XOR<quotesCreateWithoutInvoiceInput, quotesUncheckedCreateWithoutInvoiceInput>
    where?: quotesWhereInput
  }

  export type quotesUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: quotesWhereInput
    data: XOR<quotesUpdateWithoutInvoiceInput, quotesUncheckedUpdateWithoutInvoiceInput>
  }

  export type quotesUpdateWithoutInvoiceInput = {
    status?: Enumquotes_statusFieldUpdateOperationsInput | $Enums.quotes_status
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUpdateOneWithoutQuoteNestedInput
    client?: clientsUpdateOneRequiredWithoutQuotesNestedInput
    rate_card?: rate_cardsUpdateOneRequiredWithoutQuotesNestedInput
  }

  export type quotesUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate_card_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    status?: Enumquotes_statusFieldUpdateOperationsInput | $Enums.quotes_status
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUncheckedUpdateOneWithoutQuoteNestedInput
  }

  export type paymentsUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutInvoiceInput, paymentsUncheckedUpdateWithoutInvoiceInput>
    create: XOR<paymentsCreateWithoutInvoiceInput, paymentsUncheckedCreateWithoutInvoiceInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutInvoiceInput, paymentsUncheckedUpdateWithoutInvoiceInput>
  }

  export type paymentsUpdateManyWithWhereWithoutInvoiceInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type remindersUpsertWithWhereUniqueWithoutInvoicesInput = {
    where: remindersWhereUniqueInput
    update: XOR<remindersUpdateWithoutInvoicesInput, remindersUncheckedUpdateWithoutInvoicesInput>
    create: XOR<remindersCreateWithoutInvoicesInput, remindersUncheckedCreateWithoutInvoicesInput>
  }

  export type remindersUpdateWithWhereUniqueWithoutInvoicesInput = {
    where: remindersWhereUniqueInput
    data: XOR<remindersUpdateWithoutInvoicesInput, remindersUncheckedUpdateWithoutInvoicesInput>
  }

  export type remindersUpdateManyWithWhereWithoutInvoicesInput = {
    where: remindersScalarWhereInput
    data: XOR<remindersUpdateManyMutationInput, remindersUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type remindersScalarWhereInput = {
    AND?: remindersScalarWhereInput | remindersScalarWhereInput[]
    OR?: remindersScalarWhereInput[]
    NOT?: remindersScalarWhereInput | remindersScalarWhereInput[]
    id?: IntFilter<"reminders"> | number
    invoice_id?: IntFilter<"reminders"> | number
    reminder_date?: DateTimeFilter<"reminders"> | Date | string
    message?: StringFilter<"reminders"> | string
    is_sent?: BoolFilter<"reminders"> | boolean
    sent_at?: DateTimeNullableFilter<"reminders"> | Date | string | null
    created_at?: DateTimeFilter<"reminders"> | Date | string
    updated_at?: DateTimeNullableFilter<"reminders"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"reminders"> | Date | string | null
    status?: Enumshared_statusFilter<"reminders"> | $Enums.shared_status
  }

  export type usersUpsertWithWhereUniqueWithoutInvoicesInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutInvoicesInput, usersUncheckedUpdateWithoutInvoicesInput>
    create: XOR<usersCreateWithoutInvoicesInput, usersUncheckedCreateWithoutInvoicesInput>
  }

  export type usersUpdateWithWhereUniqueWithoutInvoicesInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutInvoicesInput, usersUncheckedUpdateWithoutInvoicesInput>
  }

  export type usersUpdateManyWithWhereWithoutInvoicesInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutInvoicesInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    id?: IntFilter<"users"> | number
    name?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    email_verified?: DateTimeNullableFilter<"users"> | Date | string | null
    password?: StringFilter<"users"> | string
    role?: Enumusers_roleFilter<"users"> | $Enums.users_role
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    status?: Enumusers_statusFilter<"users"> | $Enums.users_status
    deleted_at?: DateTimeNullableFilter<"users"> | Date | string | null
    public_id?: StringFilter<"users"> | string
    password_expiry?: DateTimeFilter<"users"> | Date | string
    two_factor_enabled?: BoolFilter<"users"> | boolean
    national_id?: StringNullableFilter<"users"> | string | null
    phone?: StringNullableFilter<"users"> | string | null
    branch_id?: IntNullableFilter<"users"> | number | null
    image?: StringNullableFilter<"users"> | string | null
  }

  export type usersCreateWithoutNotificationsInput = {
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    image?: string | null
    accounts?: accountsCreateNestedManyWithoutUserInput
    bookings?: bookingsCreateNestedManyWithoutUserInput
    cancellations?: cancellationsCreateNestedManyWithoutUserInput
    events?: events_logCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    branch?: branchesCreateNestedOneWithoutUsersInput
    users_branches?: users_branchesCreateNestedManyWithoutUserInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutNotificationsInput = {
    id?: number
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    branch_id?: number | null
    image?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutUserInput
    bookings?: bookingsUncheckedCreateNestedManyWithoutUserInput
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutUserInput
    events?: events_logUncheckedCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    users_branches?: users_branchesUncheckedCreateNestedManyWithoutUserInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutNotificationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
  }

  export type usersUpsertWithoutNotificationsInput = {
    update: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type usersUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutUserNestedInput
    bookings?: bookingsUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUpdateManyWithoutUserNestedInput
    events?: events_logUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    branch?: branchesUpdateOneWithoutUsersNestedInput
    users_branches?: users_branchesUpdateManyWithoutUserNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutUserNestedInput
    bookings?: bookingsUncheckedUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUncheckedUpdateManyWithoutUserNestedInput
    events?: events_logUncheckedUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    users_branches?: users_branchesUncheckedUpdateManyWithoutUserNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type invoicesCreateWithoutPaymentsInput = {
    invoice_number: string
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsCreateNestedOneWithoutInvoiceInput
    client: clientsCreateNestedOneWithoutInvoicesInput
    quote: quotesCreateNestedOneWithoutInvoiceInput
    reminders?: remindersCreateNestedManyWithoutInvoicesInput
    users?: usersCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutPaymentsInput = {
    id?: number
    invoice_number: string
    quote_id: number
    client_id: number
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsUncheckedCreateNestedOneWithoutInvoiceInput
    reminders?: remindersUncheckedCreateNestedManyWithoutInvoicesInput
    users?: usersUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutPaymentsInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutPaymentsInput, invoicesUncheckedCreateWithoutPaymentsInput>
  }

  export type bookingsCreateWithoutPaymentsInput = {
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    user: usersCreateNestedOneWithoutBookingsInput
    client: clientsCreateNestedOneWithoutBookingsInput
    hotel: hotelsCreateNestedOneWithoutBookingsInput
    invoice?: invoicesCreateNestedOneWithoutBookingInput
    quote: quotesCreateNestedOneWithoutBookingInput
    cancellations?: cancellationsCreateNestedManyWithoutBookingInput
    transportation?: transportationCreateNestedManyWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutPaymentsInput = {
    id?: number
    quote_id: number
    client_id: number
    hotel_id: number
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    agent_id: number
    invoiceid?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutBookingInput
    transportation?: transportationUncheckedCreateNestedManyWithoutBookingsInput
  }

  export type bookingsCreateOrConnectWithoutPaymentsInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutPaymentsInput, bookingsUncheckedCreateWithoutPaymentsInput>
  }

  export type invoicesUpsertWithoutPaymentsInput = {
    update: XOR<invoicesUpdateWithoutPaymentsInput, invoicesUncheckedUpdateWithoutPaymentsInput>
    create: XOR<invoicesCreateWithoutPaymentsInput, invoicesUncheckedCreateWithoutPaymentsInput>
    where?: invoicesWhereInput
  }

  export type invoicesUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: invoicesWhereInput
    data: XOR<invoicesUpdateWithoutPaymentsInput, invoicesUncheckedUpdateWithoutPaymentsInput>
  }

  export type invoicesUpdateWithoutPaymentsInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUpdateOneWithoutInvoiceNestedInput
    client?: clientsUpdateOneRequiredWithoutInvoicesNestedInput
    quote?: quotesUpdateOneRequiredWithoutInvoiceNestedInput
    reminders?: remindersUpdateManyWithoutInvoicesNestedInput
    users?: usersUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUncheckedUpdateOneWithoutInvoiceNestedInput
    reminders?: remindersUncheckedUpdateManyWithoutInvoicesNestedInput
    users?: usersUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type bookingsUpsertWithWhereUniqueWithoutPaymentsInput = {
    where: bookingsWhereUniqueInput
    update: XOR<bookingsUpdateWithoutPaymentsInput, bookingsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<bookingsCreateWithoutPaymentsInput, bookingsUncheckedCreateWithoutPaymentsInput>
  }

  export type bookingsUpdateWithWhereUniqueWithoutPaymentsInput = {
    where: bookingsWhereUniqueInput
    data: XOR<bookingsUpdateWithoutPaymentsInput, bookingsUncheckedUpdateWithoutPaymentsInput>
  }

  export type bookingsUpdateManyWithWhereWithoutPaymentsInput = {
    where: bookingsScalarWhereInput
    data: XOR<bookingsUpdateManyMutationInput, bookingsUncheckedUpdateManyWithoutPaymentsInput>
  }

  export type bookingsCreateWithoutQuoteInput = {
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    user: usersCreateNestedOneWithoutBookingsInput
    client: clientsCreateNestedOneWithoutBookingsInput
    hotel: hotelsCreateNestedOneWithoutBookingsInput
    invoice?: invoicesCreateNestedOneWithoutBookingInput
    cancellations?: cancellationsCreateNestedManyWithoutBookingInput
    transportation?: transportationCreateNestedManyWithoutBookingsInput
    payments?: paymentsCreateNestedManyWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutQuoteInput = {
    id?: number
    client_id: number
    hotel_id: number
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    agent_id: number
    invoiceid?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutBookingInput
    transportation?: transportationUncheckedCreateNestedManyWithoutBookingsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingsInput
  }

  export type bookingsCreateOrConnectWithoutQuoteInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutQuoteInput, bookingsUncheckedCreateWithoutQuoteInput>
  }

  export type invoicesCreateWithoutQuoteInput = {
    invoice_number: string
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsCreateNestedOneWithoutInvoiceInput
    client: clientsCreateNestedOneWithoutInvoicesInput
    payments?: paymentsCreateNestedManyWithoutInvoiceInput
    reminders?: remindersCreateNestedManyWithoutInvoicesInput
    users?: usersCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutQuoteInput = {
    id?: number
    invoice_number: string
    client_id: number
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsUncheckedCreateNestedOneWithoutInvoiceInput
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoiceInput
    reminders?: remindersUncheckedCreateNestedManyWithoutInvoicesInput
    users?: usersUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutQuoteInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutQuoteInput, invoicesUncheckedCreateWithoutQuoteInput>
  }

  export type clientsCreateWithoutQuotesInput = {
    name: string
    email: string
    phone: string
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone: string
    bookings?: bookingsCreateNestedManyWithoutClientInput
    branch?: branchesCreateNestedOneWithoutClientsInput
    invoices?: invoicesCreateNestedManyWithoutClientInput
  }

  export type clientsUncheckedCreateWithoutQuotesInput = {
    id?: number
    name: string
    email: string
    phone: string
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone: string
    branch_id?: number | null
    bookings?: bookingsUncheckedCreateNestedManyWithoutClientInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientsCreateOrConnectWithoutQuotesInput = {
    where: clientsWhereUniqueInput
    create: XOR<clientsCreateWithoutQuotesInput, clientsUncheckedCreateWithoutQuotesInput>
  }

  export type rate_cardsCreateWithoutQuotesInput = {
    name: string
    base_rate: number
    commission_rate?: number | null
    markup_rate?: number | null
    discount_amount?: number | null
    discount_percent?: number | null
    final_rate: number
    currency?: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    users: usersCreateNestedOneWithoutRate_cardsInput
    hotels: hotelsCreateNestedOneWithoutRate_cardsInput
    rack_rates: rack_ratesCreateNestedOneWithoutRate_cardsInput
  }

  export type rate_cardsUncheckedCreateWithoutQuotesInput = {
    id?: number
    name: string
    base_rate: number
    commission_rate?: number | null
    markup_rate?: number | null
    discount_amount?: number | null
    discount_percent?: number | null
    final_rate: number
    currency?: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission?: number | null
    is_active?: boolean
    rack_rate_id: number
    hotel_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    created_by: number
    public_id: string
    status?: $Enums.shared_status
  }

  export type rate_cardsCreateOrConnectWithoutQuotesInput = {
    where: rate_cardsWhereUniqueInput
    create: XOR<rate_cardsCreateWithoutQuotesInput, rate_cardsUncheckedCreateWithoutQuotesInput>
  }

  export type bookingsUpsertWithoutQuoteInput = {
    update: XOR<bookingsUpdateWithoutQuoteInput, bookingsUncheckedUpdateWithoutQuoteInput>
    create: XOR<bookingsCreateWithoutQuoteInput, bookingsUncheckedCreateWithoutQuoteInput>
    where?: bookingsWhereInput
  }

  export type bookingsUpdateToOneWithWhereWithoutQuoteInput = {
    where?: bookingsWhereInput
    data: XOR<bookingsUpdateWithoutQuoteInput, bookingsUncheckedUpdateWithoutQuoteInput>
  }

  export type bookingsUpdateWithoutQuoteInput = {
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    user?: usersUpdateOneRequiredWithoutBookingsNestedInput
    client?: clientsUpdateOneRequiredWithoutBookingsNestedInput
    hotel?: hotelsUpdateOneRequiredWithoutBookingsNestedInput
    invoice?: invoicesUpdateOneWithoutBookingNestedInput
    cancellations?: cancellationsUpdateManyWithoutBookingNestedInput
    transportation?: transportationUpdateManyWithoutBookingsNestedInput
    payments?: paymentsUpdateManyWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    agent_id?: IntFieldUpdateOperationsInput | number
    invoiceid?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    cancellations?: cancellationsUncheckedUpdateManyWithoutBookingNestedInput
    transportation?: transportationUncheckedUpdateManyWithoutBookingsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingsNestedInput
  }

  export type invoicesUpsertWithoutQuoteInput = {
    update: XOR<invoicesUpdateWithoutQuoteInput, invoicesUncheckedUpdateWithoutQuoteInput>
    create: XOR<invoicesCreateWithoutQuoteInput, invoicesUncheckedCreateWithoutQuoteInput>
    where?: invoicesWhereInput
  }

  export type invoicesUpdateToOneWithWhereWithoutQuoteInput = {
    where?: invoicesWhereInput
    data: XOR<invoicesUpdateWithoutQuoteInput, invoicesUncheckedUpdateWithoutQuoteInput>
  }

  export type invoicesUpdateWithoutQuoteInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUpdateOneWithoutInvoiceNestedInput
    client?: clientsUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: paymentsUpdateManyWithoutInvoiceNestedInput
    reminders?: remindersUpdateManyWithoutInvoicesNestedInput
    users?: usersUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutQuoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    client_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUncheckedUpdateOneWithoutInvoiceNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutInvoiceNestedInput
    reminders?: remindersUncheckedUpdateManyWithoutInvoicesNestedInput
    users?: usersUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type clientsUpsertWithoutQuotesInput = {
    update: XOR<clientsUpdateWithoutQuotesInput, clientsUncheckedUpdateWithoutQuotesInput>
    create: XOR<clientsCreateWithoutQuotesInput, clientsUncheckedCreateWithoutQuotesInput>
    where?: clientsWhereInput
  }

  export type clientsUpdateToOneWithWhereWithoutQuotesInput = {
    where?: clientsWhereInput
    data: XOR<clientsUpdateWithoutQuotesInput, clientsUncheckedUpdateWithoutQuotesInput>
  }

  export type clientsUpdateWithoutQuotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUpdateManyWithoutClientNestedInput
    branch?: branchesUpdateOneWithoutClientsNestedInput
    invoices?: invoicesUpdateManyWithoutClientNestedInput
  }

  export type clientsUncheckedUpdateWithoutQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    bookings?: bookingsUncheckedUpdateManyWithoutClientNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutClientNestedInput
  }

  export type rate_cardsUpsertWithoutQuotesInput = {
    update: XOR<rate_cardsUpdateWithoutQuotesInput, rate_cardsUncheckedUpdateWithoutQuotesInput>
    create: XOR<rate_cardsCreateWithoutQuotesInput, rate_cardsUncheckedCreateWithoutQuotesInput>
    where?: rate_cardsWhereInput
  }

  export type rate_cardsUpdateToOneWithWhereWithoutQuotesInput = {
    where?: rate_cardsWhereInput
    data: XOR<rate_cardsUpdateWithoutQuotesInput, rate_cardsUncheckedUpdateWithoutQuotesInput>
  }

  export type rate_cardsUpdateWithoutQuotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    users?: usersUpdateOneRequiredWithoutRate_cardsNestedInput
    hotels?: hotelsUpdateOneRequiredWithoutRate_cardsNestedInput
    rack_rates?: rack_ratesUpdateOneRequiredWithoutRate_cardsNestedInput
  }

  export type rate_cardsUncheckedUpdateWithoutQuotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rack_rate_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type hotelsCreateWithoutRack_ratesInput = {
    name: string
    location: string
    contact_email: string
    contact_phone: string
    commission_rate?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    enc_phone: string
    bookings?: bookingsCreateNestedManyWithoutHotelInput
    hotel_policies?: hotel_policiesCreateNestedManyWithoutHotelInput
    rate_cards?: rate_cardsCreateNestedManyWithoutHotelsInput
  }

  export type hotelsUncheckedCreateWithoutRack_ratesInput = {
    id?: number
    name: string
    location: string
    contact_email: string
    contact_phone: string
    commission_rate?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    enc_phone: string
    bookings?: bookingsUncheckedCreateNestedManyWithoutHotelInput
    hotel_policies?: hotel_policiesUncheckedCreateNestedManyWithoutHotelInput
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutHotelsInput
  }

  export type hotelsCreateOrConnectWithoutRack_ratesInput = {
    where: hotelsWhereUniqueInput
    create: XOR<hotelsCreateWithoutRack_ratesInput, hotelsUncheckedCreateWithoutRack_ratesInput>
  }

  export type rate_cardsCreateWithoutRack_ratesInput = {
    name: string
    base_rate: number
    commission_rate?: number | null
    markup_rate?: number | null
    discount_amount?: number | null
    discount_percent?: number | null
    final_rate: number
    currency?: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    quotes?: quotesCreateNestedManyWithoutRate_cardInput
    users: usersCreateNestedOneWithoutRate_cardsInput
    hotels: hotelsCreateNestedOneWithoutRate_cardsInput
  }

  export type rate_cardsUncheckedCreateWithoutRack_ratesInput = {
    id?: number
    name: string
    base_rate: number
    commission_rate?: number | null
    markup_rate?: number | null
    discount_amount?: number | null
    discount_percent?: number | null
    final_rate: number
    currency?: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission?: number | null
    is_active?: boolean
    hotel_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    created_by: number
    public_id: string
    status?: $Enums.shared_status
    quotes?: quotesUncheckedCreateNestedManyWithoutRate_cardInput
  }

  export type rate_cardsCreateOrConnectWithoutRack_ratesInput = {
    where: rate_cardsWhereUniqueInput
    create: XOR<rate_cardsCreateWithoutRack_ratesInput, rate_cardsUncheckedCreateWithoutRack_ratesInput>
  }

  export type rate_cardsCreateManyRack_ratesInputEnvelope = {
    data: rate_cardsCreateManyRack_ratesInput | rate_cardsCreateManyRack_ratesInput[]
    skipDuplicates?: boolean
  }

  export type hotelsUpsertWithoutRack_ratesInput = {
    update: XOR<hotelsUpdateWithoutRack_ratesInput, hotelsUncheckedUpdateWithoutRack_ratesInput>
    create: XOR<hotelsCreateWithoutRack_ratesInput, hotelsUncheckedCreateWithoutRack_ratesInput>
    where?: hotelsWhereInput
  }

  export type hotelsUpdateToOneWithWhereWithoutRack_ratesInput = {
    where?: hotelsWhereInput
    data: XOR<hotelsUpdateWithoutRack_ratesInput, hotelsUncheckedUpdateWithoutRack_ratesInput>
  }

  export type hotelsUpdateWithoutRack_ratesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUpdateManyWithoutHotelNestedInput
    hotel_policies?: hotel_policiesUpdateManyWithoutHotelNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutHotelsNestedInput
  }

  export type hotelsUncheckedUpdateWithoutRack_ratesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUncheckedUpdateManyWithoutHotelNestedInput
    hotel_policies?: hotel_policiesUncheckedUpdateManyWithoutHotelNestedInput
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutHotelsNestedInput
  }

  export type rate_cardsUpsertWithWhereUniqueWithoutRack_ratesInput = {
    where: rate_cardsWhereUniqueInput
    update: XOR<rate_cardsUpdateWithoutRack_ratesInput, rate_cardsUncheckedUpdateWithoutRack_ratesInput>
    create: XOR<rate_cardsCreateWithoutRack_ratesInput, rate_cardsUncheckedCreateWithoutRack_ratesInput>
  }

  export type rate_cardsUpdateWithWhereUniqueWithoutRack_ratesInput = {
    where: rate_cardsWhereUniqueInput
    data: XOR<rate_cardsUpdateWithoutRack_ratesInput, rate_cardsUncheckedUpdateWithoutRack_ratesInput>
  }

  export type rate_cardsUpdateManyWithWhereWithoutRack_ratesInput = {
    where: rate_cardsScalarWhereInput
    data: XOR<rate_cardsUpdateManyMutationInput, rate_cardsUncheckedUpdateManyWithoutRack_ratesInput>
  }

  export type quotesCreateWithoutRate_cardInput = {
    status?: $Enums.quotes_status
    expiration_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsCreateNestedOneWithoutQuoteInput
    invoice?: invoicesCreateNestedOneWithoutQuoteInput
    client: clientsCreateNestedOneWithoutQuotesInput
  }

  export type quotesUncheckedCreateWithoutRate_cardInput = {
    id?: number
    client_id: number
    status?: $Enums.quotes_status
    expiration_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsUncheckedCreateNestedOneWithoutQuoteInput
    invoice?: invoicesUncheckedCreateNestedOneWithoutQuoteInput
  }

  export type quotesCreateOrConnectWithoutRate_cardInput = {
    where: quotesWhereUniqueInput
    create: XOR<quotesCreateWithoutRate_cardInput, quotesUncheckedCreateWithoutRate_cardInput>
  }

  export type quotesCreateManyRate_cardInputEnvelope = {
    data: quotesCreateManyRate_cardInput | quotesCreateManyRate_cardInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutRate_cardsInput = {
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    image?: string | null
    accounts?: accountsCreateNestedManyWithoutUserInput
    bookings?: bookingsCreateNestedManyWithoutUserInput
    cancellations?: cancellationsCreateNestedManyWithoutUserInput
    events?: events_logCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    branch?: branchesCreateNestedOneWithoutUsersInput
    users_branches?: users_branchesCreateNestedManyWithoutUserInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutRate_cardsInput = {
    id?: number
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    branch_id?: number | null
    image?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutUserInput
    bookings?: bookingsUncheckedCreateNestedManyWithoutUserInput
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutUserInput
    events?: events_logUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    users_branches?: users_branchesUncheckedCreateNestedManyWithoutUserInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutRate_cardsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRate_cardsInput, usersUncheckedCreateWithoutRate_cardsInput>
  }

  export type hotelsCreateWithoutRate_cardsInput = {
    name: string
    location: string
    contact_email: string
    contact_phone: string
    commission_rate?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    enc_phone: string
    bookings?: bookingsCreateNestedManyWithoutHotelInput
    hotel_policies?: hotel_policiesCreateNestedManyWithoutHotelInput
    rack_rates?: rack_ratesCreateNestedManyWithoutHotelInput
  }

  export type hotelsUncheckedCreateWithoutRate_cardsInput = {
    id?: number
    name: string
    location: string
    contact_email: string
    contact_phone: string
    commission_rate?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    enc_phone: string
    bookings?: bookingsUncheckedCreateNestedManyWithoutHotelInput
    hotel_policies?: hotel_policiesUncheckedCreateNestedManyWithoutHotelInput
    rack_rates?: rack_ratesUncheckedCreateNestedManyWithoutHotelInput
  }

  export type hotelsCreateOrConnectWithoutRate_cardsInput = {
    where: hotelsWhereUniqueInput
    create: XOR<hotelsCreateWithoutRate_cardsInput, hotelsUncheckedCreateWithoutRate_cardsInput>
  }

  export type rack_ratesCreateWithoutRate_cardsInput = {
    rate: number
    currency?: string
    travel_period: $Enums.rack_rates_travel_period
    meal_plan: $Enums.rack_rates_meal_plan
    room_category: $Enums.rack_rates_room_category
    pdf_url?: string | null
    isProcessed?: boolean
    processed_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    hotel: hotelsCreateNestedOneWithoutRack_ratesInput
  }

  export type rack_ratesUncheckedCreateWithoutRate_cardsInput = {
    id?: number
    rate: number
    currency?: string
    travel_period: $Enums.rack_rates_travel_period
    meal_plan: $Enums.rack_rates_meal_plan
    room_category: $Enums.rack_rates_room_category
    pdf_url?: string | null
    isProcessed?: boolean
    processed_date?: Date | string | null
    hotel_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
  }

  export type rack_ratesCreateOrConnectWithoutRate_cardsInput = {
    where: rack_ratesWhereUniqueInput
    create: XOR<rack_ratesCreateWithoutRate_cardsInput, rack_ratesUncheckedCreateWithoutRate_cardsInput>
  }

  export type quotesUpsertWithWhereUniqueWithoutRate_cardInput = {
    where: quotesWhereUniqueInput
    update: XOR<quotesUpdateWithoutRate_cardInput, quotesUncheckedUpdateWithoutRate_cardInput>
    create: XOR<quotesCreateWithoutRate_cardInput, quotesUncheckedCreateWithoutRate_cardInput>
  }

  export type quotesUpdateWithWhereUniqueWithoutRate_cardInput = {
    where: quotesWhereUniqueInput
    data: XOR<quotesUpdateWithoutRate_cardInput, quotesUncheckedUpdateWithoutRate_cardInput>
  }

  export type quotesUpdateManyWithWhereWithoutRate_cardInput = {
    where: quotesScalarWhereInput
    data: XOR<quotesUpdateManyMutationInput, quotesUncheckedUpdateManyWithoutRate_cardInput>
  }

  export type usersUpsertWithoutRate_cardsInput = {
    update: XOR<usersUpdateWithoutRate_cardsInput, usersUncheckedUpdateWithoutRate_cardsInput>
    create: XOR<usersCreateWithoutRate_cardsInput, usersUncheckedCreateWithoutRate_cardsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRate_cardsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRate_cardsInput, usersUncheckedUpdateWithoutRate_cardsInput>
  }

  export type usersUpdateWithoutRate_cardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutUserNestedInput
    bookings?: bookingsUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUpdateManyWithoutUserNestedInput
    events?: events_logUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    branch?: branchesUpdateOneWithoutUsersNestedInput
    users_branches?: users_branchesUpdateManyWithoutUserNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutRate_cardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutUserNestedInput
    bookings?: bookingsUncheckedUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUncheckedUpdateManyWithoutUserNestedInput
    events?: events_logUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    users_branches?: users_branchesUncheckedUpdateManyWithoutUserNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type hotelsUpsertWithoutRate_cardsInput = {
    update: XOR<hotelsUpdateWithoutRate_cardsInput, hotelsUncheckedUpdateWithoutRate_cardsInput>
    create: XOR<hotelsCreateWithoutRate_cardsInput, hotelsUncheckedCreateWithoutRate_cardsInput>
    where?: hotelsWhereInput
  }

  export type hotelsUpdateToOneWithWhereWithoutRate_cardsInput = {
    where?: hotelsWhereInput
    data: XOR<hotelsUpdateWithoutRate_cardsInput, hotelsUncheckedUpdateWithoutRate_cardsInput>
  }

  export type hotelsUpdateWithoutRate_cardsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUpdateManyWithoutHotelNestedInput
    hotel_policies?: hotel_policiesUpdateManyWithoutHotelNestedInput
    rack_rates?: rack_ratesUpdateManyWithoutHotelNestedInput
  }

  export type hotelsUncheckedUpdateWithoutRate_cardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_phone?: StringFieldUpdateOperationsInput | string
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUncheckedUpdateManyWithoutHotelNestedInput
    hotel_policies?: hotel_policiesUncheckedUpdateManyWithoutHotelNestedInput
    rack_rates?: rack_ratesUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type rack_ratesUpsertWithoutRate_cardsInput = {
    update: XOR<rack_ratesUpdateWithoutRate_cardsInput, rack_ratesUncheckedUpdateWithoutRate_cardsInput>
    create: XOR<rack_ratesCreateWithoutRate_cardsInput, rack_ratesUncheckedCreateWithoutRate_cardsInput>
    where?: rack_ratesWhereInput
  }

  export type rack_ratesUpdateToOneWithWhereWithoutRate_cardsInput = {
    where?: rack_ratesWhereInput
    data: XOR<rack_ratesUpdateWithoutRate_cardsInput, rack_ratesUncheckedUpdateWithoutRate_cardsInput>
  }

  export type rack_ratesUpdateWithoutRate_cardsInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrack_rates_travel_periodFieldUpdateOperationsInput | $Enums.rack_rates_travel_period
    meal_plan?: Enumrack_rates_meal_planFieldUpdateOperationsInput | $Enums.rack_rates_meal_plan
    room_category?: Enumrack_rates_room_categoryFieldUpdateOperationsInput | $Enums.rack_rates_room_category
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    hotel?: hotelsUpdateOneRequiredWithoutRack_ratesNestedInput
  }

  export type rack_ratesUncheckedUpdateWithoutRate_cardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrack_rates_travel_periodFieldUpdateOperationsInput | $Enums.rack_rates_travel_period
    meal_plan?: Enumrack_rates_meal_planFieldUpdateOperationsInput | $Enums.rack_rates_meal_plan
    room_category?: Enumrack_rates_room_categoryFieldUpdateOperationsInput | $Enums.rack_rates_room_category
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotel_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type invoicesCreateWithoutRemindersInput = {
    invoice_number: string
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsCreateNestedOneWithoutInvoiceInput
    client: clientsCreateNestedOneWithoutInvoicesInput
    quote: quotesCreateNestedOneWithoutInvoiceInput
    payments?: paymentsCreateNestedManyWithoutInvoiceInput
    users?: usersCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutRemindersInput = {
    id?: number
    invoice_number: string
    quote_id: number
    client_id: number
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsUncheckedCreateNestedOneWithoutInvoiceInput
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoiceInput
    users?: usersUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutRemindersInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutRemindersInput, invoicesUncheckedCreateWithoutRemindersInput>
  }

  export type invoicesUpsertWithoutRemindersInput = {
    update: XOR<invoicesUpdateWithoutRemindersInput, invoicesUncheckedUpdateWithoutRemindersInput>
    create: XOR<invoicesCreateWithoutRemindersInput, invoicesUncheckedCreateWithoutRemindersInput>
    where?: invoicesWhereInput
  }

  export type invoicesUpdateToOneWithWhereWithoutRemindersInput = {
    where?: invoicesWhereInput
    data: XOR<invoicesUpdateWithoutRemindersInput, invoicesUncheckedUpdateWithoutRemindersInput>
  }

  export type invoicesUpdateWithoutRemindersInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUpdateOneWithoutInvoiceNestedInput
    client?: clientsUpdateOneRequiredWithoutInvoicesNestedInput
    quote?: quotesUpdateOneRequiredWithoutInvoiceNestedInput
    payments?: paymentsUpdateManyWithoutInvoiceNestedInput
    users?: usersUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutRemindersInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUncheckedUpdateOneWithoutInvoiceNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutInvoiceNestedInput
    users?: usersUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type hotel_policiesCreateWithoutSeasonsInput = {
    cancellation: string
    payment_terms: string
    commission_terms: string
    deleted_at?: Date | string | null
    created_at?: Date | string
    status?: $Enums.shared_status
    updated_at?: Date | string | null
    hotel: hotelsCreateNestedOneWithoutHotel_policiesInput
  }

  export type hotel_policiesUncheckedCreateWithoutSeasonsInput = {
    id?: number
    cancellation: string
    payment_terms: string
    commission_terms: string
    hotel_id: number
    deleted_at?: Date | string | null
    created_at?: Date | string
    status?: $Enums.shared_status
    updated_at?: Date | string | null
  }

  export type hotel_policiesCreateOrConnectWithoutSeasonsInput = {
    where: hotel_policiesWhereUniqueInput
    create: XOR<hotel_policiesCreateWithoutSeasonsInput, hotel_policiesUncheckedCreateWithoutSeasonsInput>
  }

  export type hotel_policiesUpsertWithoutSeasonsInput = {
    update: XOR<hotel_policiesUpdateWithoutSeasonsInput, hotel_policiesUncheckedUpdateWithoutSeasonsInput>
    create: XOR<hotel_policiesCreateWithoutSeasonsInput, hotel_policiesUncheckedCreateWithoutSeasonsInput>
    where?: hotel_policiesWhereInput
  }

  export type hotel_policiesUpdateToOneWithWhereWithoutSeasonsInput = {
    where?: hotel_policiesWhereInput
    data: XOR<hotel_policiesUpdateWithoutSeasonsInput, hotel_policiesUncheckedUpdateWithoutSeasonsInput>
  }

  export type hotel_policiesUpdateWithoutSeasonsInput = {
    cancellation?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    commission_terms?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotel?: hotelsUpdateOneRequiredWithoutHotel_policiesNestedInput
  }

  export type hotel_policiesUncheckedUpdateWithoutSeasonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    cancellation?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    commission_terms?: StringFieldUpdateOperationsInput | string
    hotel_id?: IntFieldUpdateOperationsInput | number
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateWithoutSessionsInput = {
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    image?: string | null
    accounts?: accountsCreateNestedManyWithoutUserInput
    bookings?: bookingsCreateNestedManyWithoutUserInput
    cancellations?: cancellationsCreateNestedManyWithoutUserInput
    events?: events_logCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsCreateNestedManyWithoutUsersInput
    branch?: branchesCreateNestedOneWithoutUsersInput
    users_branches?: users_branchesCreateNestedManyWithoutUserInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSessionsInput = {
    id?: number
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    branch_id?: number | null
    image?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutUserInput
    bookings?: bookingsUncheckedCreateNestedManyWithoutUserInput
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutUserInput
    events?: events_logUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutUsersInput
    users_branches?: users_branchesUncheckedCreateNestedManyWithoutUserInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSessionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
  }

  export type usersUpsertWithoutSessionsInput = {
    update: XOR<usersUpdateWithoutSessionsInput, usersUncheckedUpdateWithoutSessionsInput>
    create: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSessionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSessionsInput, usersUncheckedUpdateWithoutSessionsInput>
  }

  export type usersUpdateWithoutSessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutUserNestedInput
    bookings?: bookingsUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUpdateManyWithoutUserNestedInput
    events?: events_logUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutUsersNestedInput
    branch?: branchesUpdateOneWithoutUsersNestedInput
    users_branches?: users_branchesUpdateManyWithoutUserNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutUserNestedInput
    bookings?: bookingsUncheckedUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUncheckedUpdateManyWithoutUserNestedInput
    events?: events_logUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutUsersNestedInput
    users_branches?: users_branchesUncheckedUpdateManyWithoutUserNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type bookingsCreateWithoutTransportationInput = {
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    user: usersCreateNestedOneWithoutBookingsInput
    client: clientsCreateNestedOneWithoutBookingsInput
    hotel: hotelsCreateNestedOneWithoutBookingsInput
    invoice?: invoicesCreateNestedOneWithoutBookingInput
    quote: quotesCreateNestedOneWithoutBookingInput
    cancellations?: cancellationsCreateNestedManyWithoutBookingInput
    payments?: paymentsCreateNestedManyWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutTransportationInput = {
    id?: number
    quote_id: number
    client_id: number
    hotel_id: number
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    agent_id: number
    invoiceid?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutBookingInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingsInput
  }

  export type bookingsCreateOrConnectWithoutTransportationInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutTransportationInput, bookingsUncheckedCreateWithoutTransportationInput>
  }

  export type bookingsUpsertWithoutTransportationInput = {
    update: XOR<bookingsUpdateWithoutTransportationInput, bookingsUncheckedUpdateWithoutTransportationInput>
    create: XOR<bookingsCreateWithoutTransportationInput, bookingsUncheckedCreateWithoutTransportationInput>
    where?: bookingsWhereInput
  }

  export type bookingsUpdateToOneWithWhereWithoutTransportationInput = {
    where?: bookingsWhereInput
    data: XOR<bookingsUpdateWithoutTransportationInput, bookingsUncheckedUpdateWithoutTransportationInput>
  }

  export type bookingsUpdateWithoutTransportationInput = {
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    user?: usersUpdateOneRequiredWithoutBookingsNestedInput
    client?: clientsUpdateOneRequiredWithoutBookingsNestedInput
    hotel?: hotelsUpdateOneRequiredWithoutBookingsNestedInput
    invoice?: invoicesUpdateOneWithoutBookingNestedInput
    quote?: quotesUpdateOneRequiredWithoutBookingNestedInput
    cancellations?: cancellationsUpdateManyWithoutBookingNestedInput
    payments?: paymentsUpdateManyWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutTransportationInput = {
    id?: IntFieldUpdateOperationsInput | number
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    agent_id?: IntFieldUpdateOperationsInput | number
    invoiceid?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    cancellations?: cancellationsUncheckedUpdateManyWithoutBookingNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingsNestedInput
  }

  export type accountsCreateWithoutUserInput = {
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type accountsUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type accountsCreateOrConnectWithoutUserInput = {
    where: accountsWhereUniqueInput
    create: XOR<accountsCreateWithoutUserInput, accountsUncheckedCreateWithoutUserInput>
  }

  export type accountsCreateManyUserInputEnvelope = {
    data: accountsCreateManyUserInput | accountsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type bookingsCreateWithoutUserInput = {
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    client: clientsCreateNestedOneWithoutBookingsInput
    hotel: hotelsCreateNestedOneWithoutBookingsInput
    invoice?: invoicesCreateNestedOneWithoutBookingInput
    quote: quotesCreateNestedOneWithoutBookingInput
    cancellations?: cancellationsCreateNestedManyWithoutBookingInput
    transportation?: transportationCreateNestedManyWithoutBookingsInput
    payments?: paymentsCreateNestedManyWithoutBookingsInput
  }

  export type bookingsUncheckedCreateWithoutUserInput = {
    id?: number
    quote_id: number
    client_id: number
    hotel_id: number
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    invoiceid?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutBookingInput
    transportation?: transportationUncheckedCreateNestedManyWithoutBookingsInput
    payments?: paymentsUncheckedCreateNestedManyWithoutBookingsInput
  }

  export type bookingsCreateOrConnectWithoutUserInput = {
    where: bookingsWhereUniqueInput
    create: XOR<bookingsCreateWithoutUserInput, bookingsUncheckedCreateWithoutUserInput>
  }

  export type bookingsCreateManyUserInputEnvelope = {
    data: bookingsCreateManyUserInput | bookingsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type cancellationsCreateWithoutUserInput = {
    cancellation_date?: Date | string
    reason?: string | null
    hotel_charges: number
    credit_note_url?: string | null
    refund_amount: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    booking: bookingsCreateNestedOneWithoutCancellationsInput
  }

  export type cancellationsUncheckedCreateWithoutUserInput = {
    id?: number
    booking_id: number
    cancellation_date?: Date | string
    reason?: string | null
    hotel_charges: number
    credit_note_url?: string | null
    refund_amount: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type cancellationsCreateOrConnectWithoutUserInput = {
    where: cancellationsWhereUniqueInput
    create: XOR<cancellationsCreateWithoutUserInput, cancellationsUncheckedCreateWithoutUserInput>
  }

  export type cancellationsCreateManyUserInputEnvelope = {
    data: cancellationsCreateManyUserInput | cancellationsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type events_logCreateWithoutUsersInput = {
    tbl: string
    fld: number
    details: string
    event_date?: Date | string
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
  }

  export type events_logUncheckedCreateWithoutUsersInput = {
    id?: number
    tbl: string
    fld: number
    details: string
    event_date?: Date | string
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
  }

  export type events_logCreateOrConnectWithoutUsersInput = {
    where: events_logWhereUniqueInput
    create: XOR<events_logCreateWithoutUsersInput, events_logUncheckedCreateWithoutUsersInput>
  }

  export type events_logCreateManyUsersInputEnvelope = {
    data: events_logCreateManyUsersInput | events_logCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutUsersInput = {
    title: string
    message: string
    is_read?: boolean
    read_at?: Date | string | null
    type: $Enums.notifications_type
    reference_id?: number | null
    reference_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type notificationsUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    message: string
    is_read?: boolean
    read_at?: Date | string | null
    type: $Enums.notifications_type
    reference_id?: number | null
    reference_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type notificationsCreateOrConnectWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput>
  }

  export type notificationsCreateManyUsersInputEnvelope = {
    data: notificationsCreateManyUsersInput | notificationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type rate_cardsCreateWithoutUsersInput = {
    name: string
    base_rate: number
    commission_rate?: number | null
    markup_rate?: number | null
    discount_amount?: number | null
    discount_percent?: number | null
    final_rate: number
    currency?: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission?: number | null
    is_active?: boolean
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    quotes?: quotesCreateNestedManyWithoutRate_cardInput
    hotels: hotelsCreateNestedOneWithoutRate_cardsInput
    rack_rates: rack_ratesCreateNestedOneWithoutRate_cardsInput
  }

  export type rate_cardsUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    base_rate: number
    commission_rate?: number | null
    markup_rate?: number | null
    discount_amount?: number | null
    discount_percent?: number | null
    final_rate: number
    currency?: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission?: number | null
    is_active?: boolean
    rack_rate_id: number
    hotel_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    quotes?: quotesUncheckedCreateNestedManyWithoutRate_cardInput
  }

  export type rate_cardsCreateOrConnectWithoutUsersInput = {
    where: rate_cardsWhereUniqueInput
    create: XOR<rate_cardsCreateWithoutUsersInput, rate_cardsUncheckedCreateWithoutUsersInput>
  }

  export type rate_cardsCreateManyUsersInputEnvelope = {
    data: rate_cardsCreateManyUsersInput | rate_cardsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type sessionsCreateWithoutUsersInput = {
    session_token: string
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
    expires_at: Date | string
  }

  export type sessionsUncheckedCreateWithoutUsersInput = {
    id?: number
    session_token: string
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
    expires_at: Date | string
  }

  export type sessionsCreateOrConnectWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput>
  }

  export type sessionsCreateManyUsersInputEnvelope = {
    data: sessionsCreateManyUsersInput | sessionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type branchesCreateWithoutUsersInput = {
    name: string
    location: string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    clients?: clientsCreateNestedManyWithoutBranchInput
    users_branches?: users_branchesCreateNestedManyWithoutBranchInput
  }

  export type branchesUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    location: string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    clients?: clientsUncheckedCreateNestedManyWithoutBranchInput
    users_branches?: users_branchesUncheckedCreateNestedManyWithoutBranchInput
  }

  export type branchesCreateOrConnectWithoutUsersInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutUsersInput, branchesUncheckedCreateWithoutUsersInput>
  }

  export type users_branchesCreateWithoutUserInput = {
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    branch: branchesCreateNestedOneWithoutUsers_branchesInput
  }

  export type users_branchesUncheckedCreateWithoutUserInput = {
    id?: number
    branch_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type users_branchesCreateOrConnectWithoutUserInput = {
    where: users_branchesWhereUniqueInput
    create: XOR<users_branchesCreateWithoutUserInput, users_branchesUncheckedCreateWithoutUserInput>
  }

  export type users_branchesCreateManyUserInputEnvelope = {
    data: users_branchesCreateManyUserInput | users_branchesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type invoicesCreateWithoutUsersInput = {
    invoice_number: string
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsCreateNestedOneWithoutInvoiceInput
    client: clientsCreateNestedOneWithoutInvoicesInput
    quote: quotesCreateNestedOneWithoutInvoiceInput
    payments?: paymentsCreateNestedManyWithoutInvoiceInput
    reminders?: remindersCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesUncheckedCreateWithoutUsersInput = {
    id?: number
    invoice_number: string
    quote_id: number
    client_id: number
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    booking?: bookingsUncheckedCreateNestedOneWithoutInvoiceInput
    payments?: paymentsUncheckedCreateNestedManyWithoutInvoiceInput
    reminders?: remindersUncheckedCreateNestedManyWithoutInvoicesInput
  }

  export type invoicesCreateOrConnectWithoutUsersInput = {
    where: invoicesWhereUniqueInput
    create: XOR<invoicesCreateWithoutUsersInput, invoicesUncheckedCreateWithoutUsersInput>
  }

  export type accountsUpsertWithWhereUniqueWithoutUserInput = {
    where: accountsWhereUniqueInput
    update: XOR<accountsUpdateWithoutUserInput, accountsUncheckedUpdateWithoutUserInput>
    create: XOR<accountsCreateWithoutUserInput, accountsUncheckedCreateWithoutUserInput>
  }

  export type accountsUpdateWithWhereUniqueWithoutUserInput = {
    where: accountsWhereUniqueInput
    data: XOR<accountsUpdateWithoutUserInput, accountsUncheckedUpdateWithoutUserInput>
  }

  export type accountsUpdateManyWithWhereWithoutUserInput = {
    where: accountsScalarWhereInput
    data: XOR<accountsUpdateManyMutationInput, accountsUncheckedUpdateManyWithoutUserInput>
  }

  export type accountsScalarWhereInput = {
    AND?: accountsScalarWhereInput | accountsScalarWhereInput[]
    OR?: accountsScalarWhereInput[]
    NOT?: accountsScalarWhereInput | accountsScalarWhereInput[]
    id?: IntFilter<"accounts"> | number
    userId?: IntFilter<"accounts"> | number
    type?: StringFilter<"accounts"> | string
    provider?: StringFilter<"accounts"> | string
    provider_account_id?: StringFilter<"accounts"> | string
    refresh_token?: StringNullableFilter<"accounts"> | string | null
    access_token?: StringNullableFilter<"accounts"> | string | null
    expires_at?: IntNullableFilter<"accounts"> | number | null
    token_type?: StringNullableFilter<"accounts"> | string | null
    scope?: StringNullableFilter<"accounts"> | string | null
    id_token?: StringNullableFilter<"accounts"> | string | null
    session_state?: StringNullableFilter<"accounts"> | string | null
    created_at?: DateTimeFilter<"accounts"> | Date | string
    updated_at?: DateTimeFilter<"accounts"> | Date | string
    deleted_at?: DateTimeNullableFilter<"accounts"> | Date | string | null
  }

  export type bookingsUpsertWithWhereUniqueWithoutUserInput = {
    where: bookingsWhereUniqueInput
    update: XOR<bookingsUpdateWithoutUserInput, bookingsUncheckedUpdateWithoutUserInput>
    create: XOR<bookingsCreateWithoutUserInput, bookingsUncheckedCreateWithoutUserInput>
  }

  export type bookingsUpdateWithWhereUniqueWithoutUserInput = {
    where: bookingsWhereUniqueInput
    data: XOR<bookingsUpdateWithoutUserInput, bookingsUncheckedUpdateWithoutUserInput>
  }

  export type bookingsUpdateManyWithWhereWithoutUserInput = {
    where: bookingsScalarWhereInput
    data: XOR<bookingsUpdateManyMutationInput, bookingsUncheckedUpdateManyWithoutUserInput>
  }

  export type cancellationsUpsertWithWhereUniqueWithoutUserInput = {
    where: cancellationsWhereUniqueInput
    update: XOR<cancellationsUpdateWithoutUserInput, cancellationsUncheckedUpdateWithoutUserInput>
    create: XOR<cancellationsCreateWithoutUserInput, cancellationsUncheckedCreateWithoutUserInput>
  }

  export type cancellationsUpdateWithWhereUniqueWithoutUserInput = {
    where: cancellationsWhereUniqueInput
    data: XOR<cancellationsUpdateWithoutUserInput, cancellationsUncheckedUpdateWithoutUserInput>
  }

  export type cancellationsUpdateManyWithWhereWithoutUserInput = {
    where: cancellationsScalarWhereInput
    data: XOR<cancellationsUpdateManyMutationInput, cancellationsUncheckedUpdateManyWithoutUserInput>
  }

  export type events_logUpsertWithWhereUniqueWithoutUsersInput = {
    where: events_logWhereUniqueInput
    update: XOR<events_logUpdateWithoutUsersInput, events_logUncheckedUpdateWithoutUsersInput>
    create: XOR<events_logCreateWithoutUsersInput, events_logUncheckedCreateWithoutUsersInput>
  }

  export type events_logUpdateWithWhereUniqueWithoutUsersInput = {
    where: events_logWhereUniqueInput
    data: XOR<events_logUpdateWithoutUsersInput, events_logUncheckedUpdateWithoutUsersInput>
  }

  export type events_logUpdateManyWithWhereWithoutUsersInput = {
    where: events_logScalarWhereInput
    data: XOR<events_logUpdateManyMutationInput, events_logUncheckedUpdateManyWithoutUsersInput>
  }

  export type events_logScalarWhereInput = {
    AND?: events_logScalarWhereInput | events_logScalarWhereInput[]
    OR?: events_logScalarWhereInput[]
    NOT?: events_logScalarWhereInput | events_logScalarWhereInput[]
    id?: IntFilter<"events_log"> | number
    tbl?: StringFilter<"events_log"> | string
    fld?: IntFilter<"events_log"> | number
    details?: StringFilter<"events_log"> | string
    event_date?: DateTimeFilter<"events_log"> | Date | string
    event_by?: IntFilter<"events_log"> | number
    status?: Enumshared_statusFilter<"events_log"> | $Enums.shared_status
    deleted_at?: DateTimeNullableFilter<"events_log"> | Date | string | null
  }

  export type notificationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutUsersInput, notificationsUncheckedUpdateWithoutUsersInput>
    create: XOR<notificationsCreateWithoutUsersInput, notificationsUncheckedCreateWithoutUsersInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutUsersInput, notificationsUncheckedUpdateWithoutUsersInput>
  }

  export type notificationsUpdateManyWithWhereWithoutUsersInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    id?: IntFilter<"notifications"> | number
    user_id?: IntFilter<"notifications"> | number
    title?: StringFilter<"notifications"> | string
    message?: StringFilter<"notifications"> | string
    is_read?: BoolFilter<"notifications"> | boolean
    read_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    type?: Enumnotifications_typeFilter<"notifications"> | $Enums.notifications_type
    reference_id?: IntNullableFilter<"notifications"> | number | null
    reference_type?: StringNullableFilter<"notifications"> | string | null
    created_at?: DateTimeFilter<"notifications"> | Date | string
    updated_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    status?: Enumshared_statusFilter<"notifications"> | $Enums.shared_status
  }

  export type rate_cardsUpsertWithWhereUniqueWithoutUsersInput = {
    where: rate_cardsWhereUniqueInput
    update: XOR<rate_cardsUpdateWithoutUsersInput, rate_cardsUncheckedUpdateWithoutUsersInput>
    create: XOR<rate_cardsCreateWithoutUsersInput, rate_cardsUncheckedCreateWithoutUsersInput>
  }

  export type rate_cardsUpdateWithWhereUniqueWithoutUsersInput = {
    where: rate_cardsWhereUniqueInput
    data: XOR<rate_cardsUpdateWithoutUsersInput, rate_cardsUncheckedUpdateWithoutUsersInput>
  }

  export type rate_cardsUpdateManyWithWhereWithoutUsersInput = {
    where: rate_cardsScalarWhereInput
    data: XOR<rate_cardsUpdateManyMutationInput, rate_cardsUncheckedUpdateManyWithoutUsersInput>
  }

  export type sessionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    update: XOR<sessionsUpdateWithoutUsersInput, sessionsUncheckedUpdateWithoutUsersInput>
    create: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput>
  }

  export type sessionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    data: XOR<sessionsUpdateWithoutUsersInput, sessionsUncheckedUpdateWithoutUsersInput>
  }

  export type sessionsUpdateManyWithWhereWithoutUsersInput = {
    where: sessionsScalarWhereInput
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type sessionsScalarWhereInput = {
    AND?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
    OR?: sessionsScalarWhereInput[]
    NOT?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
    id?: IntFilter<"sessions"> | number
    session_token?: StringFilter<"sessions"> | string
    user_id?: IntFilter<"sessions"> | number
    created_at?: DateTimeFilter<"sessions"> | Date | string
    updated_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    status?: Enumshared_statusFilter<"sessions"> | $Enums.shared_status
    deleted_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    expires_at?: DateTimeFilter<"sessions"> | Date | string
  }

  export type branchesUpsertWithoutUsersInput = {
    update: XOR<branchesUpdateWithoutUsersInput, branchesUncheckedUpdateWithoutUsersInput>
    create: XOR<branchesCreateWithoutUsersInput, branchesUncheckedCreateWithoutUsersInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutUsersInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutUsersInput, branchesUncheckedUpdateWithoutUsersInput>
  }

  export type branchesUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    clients?: clientsUpdateManyWithoutBranchNestedInput
    users_branches?: users_branchesUpdateManyWithoutBranchNestedInput
  }

  export type branchesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    clients?: clientsUncheckedUpdateManyWithoutBranchNestedInput
    users_branches?: users_branchesUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type users_branchesUpsertWithWhereUniqueWithoutUserInput = {
    where: users_branchesWhereUniqueInput
    update: XOR<users_branchesUpdateWithoutUserInput, users_branchesUncheckedUpdateWithoutUserInput>
    create: XOR<users_branchesCreateWithoutUserInput, users_branchesUncheckedCreateWithoutUserInput>
  }

  export type users_branchesUpdateWithWhereUniqueWithoutUserInput = {
    where: users_branchesWhereUniqueInput
    data: XOR<users_branchesUpdateWithoutUserInput, users_branchesUncheckedUpdateWithoutUserInput>
  }

  export type users_branchesUpdateManyWithWhereWithoutUserInput = {
    where: users_branchesScalarWhereInput
    data: XOR<users_branchesUpdateManyMutationInput, users_branchesUncheckedUpdateManyWithoutUserInput>
  }

  export type users_branchesScalarWhereInput = {
    AND?: users_branchesScalarWhereInput | users_branchesScalarWhereInput[]
    OR?: users_branchesScalarWhereInput[]
    NOT?: users_branchesScalarWhereInput | users_branchesScalarWhereInput[]
    id?: IntFilter<"users_branches"> | number
    user_id?: IntFilter<"users_branches"> | number
    branch_id?: IntFilter<"users_branches"> | number
    created_at?: DateTimeFilter<"users_branches"> | Date | string
    updated_at?: DateTimeNullableFilter<"users_branches"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"users_branches"> | Date | string | null
    status?: Enumshared_statusFilter<"users_branches"> | $Enums.shared_status
  }

  export type invoicesUpsertWithWhereUniqueWithoutUsersInput = {
    where: invoicesWhereUniqueInput
    update: XOR<invoicesUpdateWithoutUsersInput, invoicesUncheckedUpdateWithoutUsersInput>
    create: XOR<invoicesCreateWithoutUsersInput, invoicesUncheckedCreateWithoutUsersInput>
  }

  export type invoicesUpdateWithWhereUniqueWithoutUsersInput = {
    where: invoicesWhereUniqueInput
    data: XOR<invoicesUpdateWithoutUsersInput, invoicesUncheckedUpdateWithoutUsersInput>
  }

  export type invoicesUpdateManyWithWhereWithoutUsersInput = {
    where: invoicesScalarWhereInput
    data: XOR<invoicesUpdateManyMutationInput, invoicesUncheckedUpdateManyWithoutUsersInput>
  }

  export type clientsCreateWithoutBranchInput = {
    name: string
    email: string
    phone: string
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone: string
    bookings?: bookingsCreateNestedManyWithoutClientInput
    invoices?: invoicesCreateNestedManyWithoutClientInput
    quotes?: quotesCreateNestedManyWithoutClientInput
  }

  export type clientsUncheckedCreateWithoutBranchInput = {
    id?: number
    name: string
    email: string
    phone: string
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone: string
    bookings?: bookingsUncheckedCreateNestedManyWithoutClientInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutClientInput
    quotes?: quotesUncheckedCreateNestedManyWithoutClientInput
  }

  export type clientsCreateOrConnectWithoutBranchInput = {
    where: clientsWhereUniqueInput
    create: XOR<clientsCreateWithoutBranchInput, clientsUncheckedCreateWithoutBranchInput>
  }

  export type clientsCreateManyBranchInputEnvelope = {
    data: clientsCreateManyBranchInput | clientsCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutBranchInput = {
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    image?: string | null
    accounts?: accountsCreateNestedManyWithoutUserInput
    bookings?: bookingsCreateNestedManyWithoutUserInput
    cancellations?: cancellationsCreateNestedManyWithoutUserInput
    events?: events_logCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    users_branches?: users_branchesCreateNestedManyWithoutUserInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutBranchInput = {
    id?: number
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    image?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutUserInput
    bookings?: bookingsUncheckedCreateNestedManyWithoutUserInput
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutUserInput
    events?: events_logUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    users_branches?: users_branchesUncheckedCreateNestedManyWithoutUserInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutBranchInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBranchInput, usersUncheckedCreateWithoutBranchInput>
  }

  export type usersCreateManyBranchInputEnvelope = {
    data: usersCreateManyBranchInput | usersCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type users_branchesCreateWithoutBranchInput = {
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    user: usersCreateNestedOneWithoutUsers_branchesInput
  }

  export type users_branchesUncheckedCreateWithoutBranchInput = {
    id?: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type users_branchesCreateOrConnectWithoutBranchInput = {
    where: users_branchesWhereUniqueInput
    create: XOR<users_branchesCreateWithoutBranchInput, users_branchesUncheckedCreateWithoutBranchInput>
  }

  export type users_branchesCreateManyBranchInputEnvelope = {
    data: users_branchesCreateManyBranchInput | users_branchesCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type clientsUpsertWithWhereUniqueWithoutBranchInput = {
    where: clientsWhereUniqueInput
    update: XOR<clientsUpdateWithoutBranchInput, clientsUncheckedUpdateWithoutBranchInput>
    create: XOR<clientsCreateWithoutBranchInput, clientsUncheckedCreateWithoutBranchInput>
  }

  export type clientsUpdateWithWhereUniqueWithoutBranchInput = {
    where: clientsWhereUniqueInput
    data: XOR<clientsUpdateWithoutBranchInput, clientsUncheckedUpdateWithoutBranchInput>
  }

  export type clientsUpdateManyWithWhereWithoutBranchInput = {
    where: clientsScalarWhereInput
    data: XOR<clientsUpdateManyMutationInput, clientsUncheckedUpdateManyWithoutBranchInput>
  }

  export type clientsScalarWhereInput = {
    AND?: clientsScalarWhereInput | clientsScalarWhereInput[]
    OR?: clientsScalarWhereInput[]
    NOT?: clientsScalarWhereInput | clientsScalarWhereInput[]
    id?: IntFilter<"clients"> | number
    name?: StringFilter<"clients"> | string
    email?: StringFilter<"clients"> | string
    phone?: StringFilter<"clients"> | string
    address?: StringNullableFilter<"clients"> | string | null
    created_at?: DateTimeFilter<"clients"> | Date | string
    updated_at?: DateTimeNullableFilter<"clients"> | Date | string | null
    deleted_at?: DateTimeNullableFilter<"clients"> | Date | string | null
    public_id?: StringFilter<"clients"> | string
    status?: Enumshared_statusFilter<"clients"> | $Enums.shared_status
    enc_phone?: StringFilter<"clients"> | string
    branch_id?: IntNullableFilter<"clients"> | number | null
  }

  export type usersUpsertWithWhereUniqueWithoutBranchInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutBranchInput, usersUncheckedUpdateWithoutBranchInput>
    create: XOR<usersCreateWithoutBranchInput, usersUncheckedCreateWithoutBranchInput>
  }

  export type usersUpdateWithWhereUniqueWithoutBranchInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutBranchInput, usersUncheckedUpdateWithoutBranchInput>
  }

  export type usersUpdateManyWithWhereWithoutBranchInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutBranchInput>
  }

  export type users_branchesUpsertWithWhereUniqueWithoutBranchInput = {
    where: users_branchesWhereUniqueInput
    update: XOR<users_branchesUpdateWithoutBranchInput, users_branchesUncheckedUpdateWithoutBranchInput>
    create: XOR<users_branchesCreateWithoutBranchInput, users_branchesUncheckedCreateWithoutBranchInput>
  }

  export type users_branchesUpdateWithWhereUniqueWithoutBranchInput = {
    where: users_branchesWhereUniqueInput
    data: XOR<users_branchesUpdateWithoutBranchInput, users_branchesUncheckedUpdateWithoutBranchInput>
  }

  export type users_branchesUpdateManyWithWhereWithoutBranchInput = {
    where: users_branchesScalarWhereInput
    data: XOR<users_branchesUpdateManyMutationInput, users_branchesUncheckedUpdateManyWithoutBranchInput>
  }

  export type branchesCreateWithoutUsers_branchesInput = {
    name: string
    location: string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    clients?: clientsCreateNestedManyWithoutBranchInput
    users?: usersCreateNestedManyWithoutBranchInput
  }

  export type branchesUncheckedCreateWithoutUsers_branchesInput = {
    id?: number
    name: string
    location: string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    clients?: clientsUncheckedCreateNestedManyWithoutBranchInput
    users?: usersUncheckedCreateNestedManyWithoutBranchInput
  }

  export type branchesCreateOrConnectWithoutUsers_branchesInput = {
    where: branchesWhereUniqueInput
    create: XOR<branchesCreateWithoutUsers_branchesInput, branchesUncheckedCreateWithoutUsers_branchesInput>
  }

  export type usersCreateWithoutUsers_branchesInput = {
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    image?: string | null
    accounts?: accountsCreateNestedManyWithoutUserInput
    bookings?: bookingsCreateNestedManyWithoutUserInput
    cancellations?: cancellationsCreateNestedManyWithoutUserInput
    events?: events_logCreateNestedManyWithoutUsersInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    branch?: branchesCreateNestedOneWithoutUsersInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUsers_branchesInput = {
    id?: number
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    branch_id?: number | null
    image?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutUserInput
    bookings?: bookingsUncheckedCreateNestedManyWithoutUserInput
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutUserInput
    events?: events_logUncheckedCreateNestedManyWithoutUsersInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUsers_branchesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUsers_branchesInput, usersUncheckedCreateWithoutUsers_branchesInput>
  }

  export type branchesUpsertWithoutUsers_branchesInput = {
    update: XOR<branchesUpdateWithoutUsers_branchesInput, branchesUncheckedUpdateWithoutUsers_branchesInput>
    create: XOR<branchesCreateWithoutUsers_branchesInput, branchesUncheckedCreateWithoutUsers_branchesInput>
    where?: branchesWhereInput
  }

  export type branchesUpdateToOneWithWhereWithoutUsers_branchesInput = {
    where?: branchesWhereInput
    data: XOR<branchesUpdateWithoutUsers_branchesInput, branchesUncheckedUpdateWithoutUsers_branchesInput>
  }

  export type branchesUpdateWithoutUsers_branchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    clients?: clientsUpdateManyWithoutBranchNestedInput
    users?: usersUpdateManyWithoutBranchNestedInput
  }

  export type branchesUncheckedUpdateWithoutUsers_branchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    clients?: clientsUncheckedUpdateManyWithoutBranchNestedInput
    users?: usersUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type usersUpsertWithoutUsers_branchesInput = {
    update: XOR<usersUpdateWithoutUsers_branchesInput, usersUncheckedUpdateWithoutUsers_branchesInput>
    create: XOR<usersCreateWithoutUsers_branchesInput, usersUncheckedCreateWithoutUsers_branchesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUsers_branchesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUsers_branchesInput, usersUncheckedUpdateWithoutUsers_branchesInput>
  }

  export type usersUpdateWithoutUsers_branchesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutUserNestedInput
    bookings?: bookingsUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUpdateManyWithoutUserNestedInput
    events?: events_logUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    branch?: branchesUpdateOneWithoutUsersNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUsers_branchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutUserNestedInput
    bookings?: bookingsUncheckedUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUncheckedUpdateManyWithoutUserNestedInput
    events?: events_logUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutEventsInput = {
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    image?: string | null
    accounts?: accountsCreateNestedManyWithoutUserInput
    bookings?: bookingsCreateNestedManyWithoutUserInput
    cancellations?: cancellationsCreateNestedManyWithoutUserInput
    notifications?: notificationsCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
    branch?: branchesCreateNestedOneWithoutUsersInput
    users_branches?: users_branchesCreateNestedManyWithoutUserInput
    invoices?: invoicesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutEventsInput = {
    id?: number
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    branch_id?: number | null
    image?: string | null
    accounts?: accountsUncheckedCreateNestedManyWithoutUserInput
    bookings?: bookingsUncheckedCreateNestedManyWithoutUserInput
    cancellations?: cancellationsUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutUsersInput
    rate_cards?: rate_cardsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
    users_branches?: users_branchesUncheckedCreateNestedManyWithoutUserInput
    invoices?: invoicesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutEventsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutEventsInput, usersUncheckedCreateWithoutEventsInput>
  }

  export type usersUpsertWithoutEventsInput = {
    update: XOR<usersUpdateWithoutEventsInput, usersUncheckedUpdateWithoutEventsInput>
    create: XOR<usersCreateWithoutEventsInput, usersUncheckedCreateWithoutEventsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutEventsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutEventsInput, usersUncheckedUpdateWithoutEventsInput>
  }

  export type usersUpdateWithoutEventsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutUserNestedInput
    bookings?: bookingsUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUpdateManyWithoutUserNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    branch?: branchesUpdateOneWithoutUsersNestedInput
    users_branches?: users_branchesUpdateManyWithoutUserNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutEventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutUserNestedInput
    bookings?: bookingsUncheckedUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    users_branches?: users_branchesUncheckedUpdateManyWithoutUserNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type cancellationsCreateManyBookingInput = {
    id?: number
    cancellation_date?: Date | string
    reason?: string | null
    hotel_charges: number
    credit_note_url?: string | null
    refund_amount: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    processed_by: number
    status?: $Enums.shared_status
  }

  export type transportationCreateManyBookingsInput = {
    id?: number
    type: $Enums.transportation_type
    provider: string
    booking_ref?: string | null
    departure_date: Date | string
    return_date?: Date | string | null
    departure_point: string
    arrival_point: string
    cost: number
    status?: $Enums.transportation_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
  }

  export type cancellationsUpdateWithoutBookingInput = {
    cancellation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    hotel_charges?: FloatFieldUpdateOperationsInput | number
    credit_note_url?: NullableStringFieldUpdateOperationsInput | string | null
    refund_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    user?: usersUpdateOneRequiredWithoutCancellationsNestedInput
  }

  export type cancellationsUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    cancellation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    hotel_charges?: FloatFieldUpdateOperationsInput | number
    credit_note_url?: NullableStringFieldUpdateOperationsInput | string | null
    refund_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed_by?: IntFieldUpdateOperationsInput | number
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type cancellationsUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    cancellation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    hotel_charges?: FloatFieldUpdateOperationsInput | number
    credit_note_url?: NullableStringFieldUpdateOperationsInput | string | null
    refund_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processed_by?: IntFieldUpdateOperationsInput | number
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type transportationUpdateWithoutBookingsInput = {
    type?: Enumtransportation_typeFieldUpdateOperationsInput | $Enums.transportation_type
    provider?: StringFieldUpdateOperationsInput | string
    booking_ref?: NullableStringFieldUpdateOperationsInput | string | null
    departure_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departure_point?: StringFieldUpdateOperationsInput | string
    arrival_point?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    status?: Enumtransportation_statusFieldUpdateOperationsInput | $Enums.transportation_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transportationUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: Enumtransportation_typeFieldUpdateOperationsInput | $Enums.transportation_type
    provider?: StringFieldUpdateOperationsInput | string
    booking_ref?: NullableStringFieldUpdateOperationsInput | string | null
    departure_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departure_point?: StringFieldUpdateOperationsInput | string
    arrival_point?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    status?: Enumtransportation_statusFieldUpdateOperationsInput | $Enums.transportation_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transportationUncheckedUpdateManyWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: Enumtransportation_typeFieldUpdateOperationsInput | $Enums.transportation_type
    provider?: StringFieldUpdateOperationsInput | string
    booking_ref?: NullableStringFieldUpdateOperationsInput | string | null
    departure_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departure_point?: StringFieldUpdateOperationsInput | string
    arrival_point?: StringFieldUpdateOperationsInput | string
    cost?: FloatFieldUpdateOperationsInput | number
    status?: Enumtransportation_statusFieldUpdateOperationsInput | $Enums.transportation_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUpdateWithoutBookingsInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayments_payment_methodFieldUpdateOperationsInput | $Enums.payments_payment_method
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    invoice?: invoicesUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayments_payment_methodFieldUpdateOperationsInput | $Enums.payments_payment_method
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsUncheckedUpdateManyWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayments_payment_methodFieldUpdateOperationsInput | $Enums.payments_payment_method
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bookingsCreateManyClientInput = {
    id?: number
    quote_id: number
    hotel_id: number
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    agent_id: number
    invoiceid?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
  }

  export type invoicesCreateManyClientInput = {
    id?: number
    invoice_number: string
    quote_id: number
    amount: number
    tax_amount?: number
    total_amount: number
    due_date: Date | string
    status?: $Enums.invoices_status
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
  }

  export type quotesCreateManyClientInput = {
    id?: number
    rate_card_id: number
    status?: $Enums.quotes_status
    expiration_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
  }

  export type bookingsUpdateWithoutClientInput = {
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    user?: usersUpdateOneRequiredWithoutBookingsNestedInput
    hotel?: hotelsUpdateOneRequiredWithoutBookingsNestedInput
    invoice?: invoicesUpdateOneWithoutBookingNestedInput
    quote?: quotesUpdateOneRequiredWithoutBookingNestedInput
    cancellations?: cancellationsUpdateManyWithoutBookingNestedInput
    transportation?: transportationUpdateManyWithoutBookingsNestedInput
    payments?: paymentsUpdateManyWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    quote_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    agent_id?: IntFieldUpdateOperationsInput | number
    invoiceid?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    cancellations?: cancellationsUncheckedUpdateManyWithoutBookingNestedInput
    transportation?: transportationUncheckedUpdateManyWithoutBookingsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    quote_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    agent_id?: IntFieldUpdateOperationsInput | number
    invoiceid?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
  }

  export type invoicesUpdateWithoutClientInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUpdateOneWithoutInvoiceNestedInput
    quote?: quotesUpdateOneRequiredWithoutInvoiceNestedInput
    payments?: paymentsUpdateManyWithoutInvoiceNestedInput
    reminders?: remindersUpdateManyWithoutInvoicesNestedInput
    users?: usersUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    quote_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUncheckedUpdateOneWithoutInvoiceNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutInvoiceNestedInput
    reminders?: remindersUncheckedUpdateManyWithoutInvoicesNestedInput
    users?: usersUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    quote_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
  }

  export type quotesUpdateWithoutClientInput = {
    status?: Enumquotes_statusFieldUpdateOperationsInput | $Enums.quotes_status
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUpdateOneWithoutQuoteNestedInput
    invoice?: invoicesUpdateOneWithoutQuoteNestedInput
    rate_card?: rate_cardsUpdateOneRequiredWithoutQuotesNestedInput
  }

  export type quotesUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate_card_id?: IntFieldUpdateOperationsInput | number
    status?: Enumquotes_statusFieldUpdateOperationsInput | $Enums.quotes_status
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUncheckedUpdateOneWithoutQuoteNestedInput
    invoice?: invoicesUncheckedUpdateOneWithoutQuoteNestedInput
  }

  export type quotesUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate_card_id?: IntFieldUpdateOperationsInput | number
    status?: Enumquotes_statusFieldUpdateOperationsInput | $Enums.quotes_status
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
  }

  export type seasonsCreateManyHotel_policiesInput = {
    id?: number
    name: string
    period_type: $Enums.seasons_period_type
    start_date: Date | string
    end_date: Date | string
    created_at?: Date | string
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
    updated_at?: Date | string | null
  }

  export type seasonsUpdateWithoutHotel_policiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    period_type?: Enumseasons_period_typeFieldUpdateOperationsInput | $Enums.seasons_period_type
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type seasonsUncheckedUpdateWithoutHotel_policiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    period_type?: Enumseasons_period_typeFieldUpdateOperationsInput | $Enums.seasons_period_type
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type seasonsUncheckedUpdateManyWithoutHotel_policiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    period_type?: Enumseasons_period_typeFieldUpdateOperationsInput | $Enums.seasons_period_type
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bookingsCreateManyHotelInput = {
    id?: number
    quote_id: number
    client_id: number
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    agent_id: number
    invoiceid?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
  }

  export type hotel_policiesCreateManyHotelInput = {
    id?: number
    cancellation: string
    payment_terms: string
    commission_terms: string
    deleted_at?: Date | string | null
    created_at?: Date | string
    status?: $Enums.shared_status
    updated_at?: Date | string | null
  }

  export type rack_ratesCreateManyHotelInput = {
    id?: number
    rate: number
    currency?: string
    travel_period: $Enums.rack_rates_travel_period
    meal_plan: $Enums.rack_rates_meal_plan
    room_category: $Enums.rack_rates_room_category
    pdf_url?: string | null
    isProcessed?: boolean
    processed_date?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
  }

  export type rate_cardsCreateManyHotelsInput = {
    id?: number
    name: string
    base_rate: number
    commission_rate?: number | null
    markup_rate?: number | null
    discount_amount?: number | null
    discount_percent?: number | null
    final_rate: number
    currency?: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission?: number | null
    is_active?: boolean
    rack_rate_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    created_by: number
    public_id: string
    status?: $Enums.shared_status
  }

  export type bookingsUpdateWithoutHotelInput = {
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    user?: usersUpdateOneRequiredWithoutBookingsNestedInput
    client?: clientsUpdateOneRequiredWithoutBookingsNestedInput
    invoice?: invoicesUpdateOneWithoutBookingNestedInput
    quote?: quotesUpdateOneRequiredWithoutBookingNestedInput
    cancellations?: cancellationsUpdateManyWithoutBookingNestedInput
    transportation?: transportationUpdateManyWithoutBookingsNestedInput
    payments?: paymentsUpdateManyWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    agent_id?: IntFieldUpdateOperationsInput | number
    invoiceid?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    cancellations?: cancellationsUncheckedUpdateManyWithoutBookingNestedInput
    transportation?: transportationUncheckedUpdateManyWithoutBookingsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    agent_id?: IntFieldUpdateOperationsInput | number
    invoiceid?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
  }

  export type hotel_policiesUpdateWithoutHotelInput = {
    cancellation?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    commission_terms?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasons?: seasonsUpdateManyWithoutHotel_policiesNestedInput
  }

  export type hotel_policiesUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    cancellation?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    commission_terms?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    seasons?: seasonsUncheckedUpdateManyWithoutHotel_policiesNestedInput
  }

  export type hotel_policiesUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    cancellation?: StringFieldUpdateOperationsInput | string
    payment_terms?: StringFieldUpdateOperationsInput | string
    commission_terms?: StringFieldUpdateOperationsInput | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rack_ratesUpdateWithoutHotelInput = {
    rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrack_rates_travel_periodFieldUpdateOperationsInput | $Enums.rack_rates_travel_period
    meal_plan?: Enumrack_rates_meal_planFieldUpdateOperationsInput | $Enums.rack_rates_meal_plan
    room_category?: Enumrack_rates_room_categoryFieldUpdateOperationsInput | $Enums.rack_rates_room_category
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    rate_cards?: rate_cardsUpdateManyWithoutRack_ratesNestedInput
  }

  export type rack_ratesUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrack_rates_travel_periodFieldUpdateOperationsInput | $Enums.rack_rates_travel_period
    meal_plan?: Enumrack_rates_meal_planFieldUpdateOperationsInput | $Enums.rack_rates_meal_plan
    room_category?: Enumrack_rates_room_categoryFieldUpdateOperationsInput | $Enums.rack_rates_room_category
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutRack_ratesNestedInput
  }

  export type rack_ratesUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrack_rates_travel_periodFieldUpdateOperationsInput | $Enums.rack_rates_travel_period
    meal_plan?: Enumrack_rates_meal_planFieldUpdateOperationsInput | $Enums.rack_rates_meal_plan
    room_category?: Enumrack_rates_room_categoryFieldUpdateOperationsInput | $Enums.rack_rates_room_category
    pdf_url?: NullableStringFieldUpdateOperationsInput | string | null
    isProcessed?: BoolFieldUpdateOperationsInput | boolean
    processed_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type rate_cardsUpdateWithoutHotelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    quotes?: quotesUpdateManyWithoutRate_cardNestedInput
    users?: usersUpdateOneRequiredWithoutRate_cardsNestedInput
    rack_rates?: rack_ratesUpdateOneRequiredWithoutRate_cardsNestedInput
  }

  export type rate_cardsUncheckedUpdateWithoutHotelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rack_rate_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    quotes?: quotesUncheckedUpdateManyWithoutRate_cardNestedInput
  }

  export type rate_cardsUncheckedUpdateManyWithoutHotelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rack_rate_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type paymentsCreateManyInvoiceInput = {
    id?: number
    amount: number
    payment_date?: Date | string
    payment_method: $Enums.payments_payment_method
    transaction_id?: string | null
    receipt_url?: string | null
    is_confirmed?: boolean
    confirmed_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone?: string | null
    phone?: string | null
  }

  export type remindersCreateManyInvoicesInput = {
    id?: number
    reminder_date: Date | string
    message: string
    is_sent?: boolean
    sent_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type paymentsUpdateWithoutInvoiceInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayments_payment_methodFieldUpdateOperationsInput | $Enums.payments_payment_method
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: bookingsUpdateManyWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayments_payment_methodFieldUpdateOperationsInput | $Enums.payments_payment_method
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    bookings?: bookingsUncheckedUpdateManyWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: Enumpayments_payment_methodFieldUpdateOperationsInput | $Enums.payments_payment_method
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    receipt_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_confirmed?: BoolFieldUpdateOperationsInput | boolean
    confirmed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type remindersUpdateWithoutInvoicesInput = {
    reminder_date?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    is_sent?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type remindersUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    reminder_date?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    is_sent?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type remindersUncheckedUpdateManyWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    reminder_date?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: StringFieldUpdateOperationsInput | string
    is_sent?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type usersUpdateWithoutInvoicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutUserNestedInput
    bookings?: bookingsUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUpdateManyWithoutUserNestedInput
    events?: events_logUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    branch?: branchesUpdateOneWithoutUsersNestedInput
    users_branches?: users_branchesUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutUserNestedInput
    bookings?: bookingsUncheckedUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUncheckedUpdateManyWithoutUserNestedInput
    events?: events_logUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    users_branches?: users_branchesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateManyWithoutInvoicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type bookingsUpdateWithoutPaymentsInput = {
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    user?: usersUpdateOneRequiredWithoutBookingsNestedInput
    client?: clientsUpdateOneRequiredWithoutBookingsNestedInput
    hotel?: hotelsUpdateOneRequiredWithoutBookingsNestedInput
    invoice?: invoicesUpdateOneWithoutBookingNestedInput
    quote?: quotesUpdateOneRequiredWithoutBookingNestedInput
    cancellations?: cancellationsUpdateManyWithoutBookingNestedInput
    transportation?: transportationUpdateManyWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    agent_id?: IntFieldUpdateOperationsInput | number
    invoiceid?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    cancellations?: cancellationsUncheckedUpdateManyWithoutBookingNestedInput
    transportation?: transportationUncheckedUpdateManyWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateManyWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    agent_id?: IntFieldUpdateOperationsInput | number
    invoiceid?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
  }

  export type rate_cardsCreateManyRack_ratesInput = {
    id?: number
    name: string
    base_rate: number
    commission_rate?: number | null
    markup_rate?: number | null
    discount_amount?: number | null
    discount_percent?: number | null
    final_rate: number
    currency?: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission?: number | null
    is_active?: boolean
    hotel_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    created_by: number
    public_id: string
    status?: $Enums.shared_status
  }

  export type rate_cardsUpdateWithoutRack_ratesInput = {
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    quotes?: quotesUpdateManyWithoutRate_cardNestedInput
    users?: usersUpdateOneRequiredWithoutRate_cardsNestedInput
    hotels?: hotelsUpdateOneRequiredWithoutRate_cardsNestedInput
  }

  export type rate_cardsUncheckedUpdateWithoutRack_ratesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    hotel_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    quotes?: quotesUncheckedUpdateManyWithoutRate_cardNestedInput
  }

  export type rate_cardsUncheckedUpdateManyWithoutRack_ratesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    hotel_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: IntFieldUpdateOperationsInput | number
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type quotesCreateManyRate_cardInput = {
    id?: number
    client_id: number
    status?: $Enums.quotes_status
    expiration_date: Date | string
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
  }

  export type quotesUpdateWithoutRate_cardInput = {
    status?: Enumquotes_statusFieldUpdateOperationsInput | $Enums.quotes_status
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUpdateOneWithoutQuoteNestedInput
    invoice?: invoicesUpdateOneWithoutQuoteNestedInput
    client?: clientsUpdateOneRequiredWithoutQuotesNestedInput
  }

  export type quotesUncheckedUpdateWithoutRate_cardInput = {
    id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    status?: Enumquotes_statusFieldUpdateOperationsInput | $Enums.quotes_status
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUncheckedUpdateOneWithoutQuoteNestedInput
    invoice?: invoicesUncheckedUpdateOneWithoutQuoteNestedInput
  }

  export type quotesUncheckedUpdateManyWithoutRate_cardInput = {
    id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    status?: Enumquotes_statusFieldUpdateOperationsInput | $Enums.quotes_status
    expiration_date?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
  }

  export type accountsCreateManyUserInput = {
    id?: number
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    deleted_at?: Date | string | null
  }

  export type bookingsCreateManyUserInput = {
    id?: number
    quote_id: number
    client_id: number
    hotel_id: number
    travel_date: Date | string
    return_date: Date | string
    meal_plan: $Enums.bookings_meal_plan
    room_category: $Enums.bookings_room_category
    status?: $Enums.bookings_status
    voucher_url?: string | null
    invoiceid?: number | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
  }

  export type cancellationsCreateManyUserInput = {
    id?: number
    booking_id: number
    cancellation_date?: Date | string
    reason?: string | null
    hotel_charges: number
    credit_note_url?: string | null
    refund_amount: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type events_logCreateManyUsersInput = {
    id?: number
    tbl: string
    fld: number
    details: string
    event_date?: Date | string
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
  }

  export type notificationsCreateManyUsersInput = {
    id?: number
    title: string
    message: string
    is_read?: boolean
    read_at?: Date | string | null
    type: $Enums.notifications_type
    reference_id?: number | null
    reference_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type rate_cardsCreateManyUsersInput = {
    id?: number
    name: string
    base_rate: number
    commission_rate?: number | null
    markup_rate?: number | null
    discount_amount?: number | null
    discount_percent?: number | null
    final_rate: number
    currency?: string
    travel_period: $Enums.rate_cards_travel_period
    meal_plan: $Enums.rate_cards_meal_plan
    room_category: $Enums.rate_cards_room_category
    commission?: number | null
    is_active?: boolean
    rack_rate_id: number
    hotel_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
  }

  export type sessionsCreateManyUsersInput = {
    id?: number
    session_token: string
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.shared_status
    deleted_at?: Date | string | null
    expires_at: Date | string
  }

  export type users_branchesCreateManyUserInput = {
    id?: number
    branch_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type accountsUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type accountsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type accountsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type bookingsUpdateWithoutUserInput = {
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    client?: clientsUpdateOneRequiredWithoutBookingsNestedInput
    hotel?: hotelsUpdateOneRequiredWithoutBookingsNestedInput
    invoice?: invoicesUpdateOneWithoutBookingNestedInput
    quote?: quotesUpdateOneRequiredWithoutBookingNestedInput
    cancellations?: cancellationsUpdateManyWithoutBookingNestedInput
    transportation?: transportationUpdateManyWithoutBookingsNestedInput
    payments?: paymentsUpdateManyWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceid?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    cancellations?: cancellationsUncheckedUpdateManyWithoutBookingNestedInput
    transportation?: transportationUncheckedUpdateManyWithoutBookingsNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutBookingsNestedInput
  }

  export type bookingsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    travel_date?: DateTimeFieldUpdateOperationsInput | Date | string
    return_date?: DateTimeFieldUpdateOperationsInput | Date | string
    meal_plan?: Enumbookings_meal_planFieldUpdateOperationsInput | $Enums.bookings_meal_plan
    room_category?: Enumbookings_room_categoryFieldUpdateOperationsInput | $Enums.bookings_room_category
    status?: Enumbookings_statusFieldUpdateOperationsInput | $Enums.bookings_status
    voucher_url?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceid?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
  }

  export type cancellationsUpdateWithoutUserInput = {
    cancellation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    hotel_charges?: FloatFieldUpdateOperationsInput | number
    credit_note_url?: NullableStringFieldUpdateOperationsInput | string | null
    refund_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    booking?: bookingsUpdateOneRequiredWithoutCancellationsNestedInput
  }

  export type cancellationsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    booking_id?: IntFieldUpdateOperationsInput | number
    cancellation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    hotel_charges?: FloatFieldUpdateOperationsInput | number
    credit_note_url?: NullableStringFieldUpdateOperationsInput | string | null
    refund_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type cancellationsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    booking_id?: IntFieldUpdateOperationsInput | number
    cancellation_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    hotel_charges?: FloatFieldUpdateOperationsInput | number
    credit_note_url?: NullableStringFieldUpdateOperationsInput | string | null
    refund_amount?: FloatFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type events_logUpdateWithoutUsersInput = {
    tbl?: StringFieldUpdateOperationsInput | string
    fld?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type events_logUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    tbl?: StringFieldUpdateOperationsInput | string
    fld?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type events_logUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    tbl?: StringFieldUpdateOperationsInput | string
    fld?: IntFieldUpdateOperationsInput | number
    details?: StringFieldUpdateOperationsInput | string
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationsUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: Enumnotifications_typeFieldUpdateOperationsInput | $Enums.notifications_type
    reference_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type notificationsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: Enumnotifications_typeFieldUpdateOperationsInput | $Enums.notifications_type
    reference_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type notificationsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    type?: Enumnotifications_typeFieldUpdateOperationsInput | $Enums.notifications_type
    reference_id?: NullableIntFieldUpdateOperationsInput | number | null
    reference_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type rate_cardsUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    quotes?: quotesUpdateManyWithoutRate_cardNestedInput
    hotels?: hotelsUpdateOneRequiredWithoutRate_cardsNestedInput
    rack_rates?: rack_ratesUpdateOneRequiredWithoutRate_cardsNestedInput
  }

  export type rate_cardsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rack_rate_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    quotes?: quotesUncheckedUpdateManyWithoutRate_cardNestedInput
  }

  export type rate_cardsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    base_rate?: FloatFieldUpdateOperationsInput | number
    commission_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    markup_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_amount?: NullableFloatFieldUpdateOperationsInput | number | null
    discount_percent?: NullableFloatFieldUpdateOperationsInput | number | null
    final_rate?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    travel_period?: Enumrate_cards_travel_periodFieldUpdateOperationsInput | $Enums.rate_cards_travel_period
    meal_plan?: Enumrate_cards_meal_planFieldUpdateOperationsInput | $Enums.rate_cards_meal_plan
    room_category?: Enumrate_cards_room_categoryFieldUpdateOperationsInput | $Enums.rate_cards_room_category
    commission?: NullableFloatFieldUpdateOperationsInput | number | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rack_rate_id?: IntFieldUpdateOperationsInput | number
    hotel_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type sessionsUpdateWithoutUsersInput = {
    session_token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sessionsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    session_token?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type users_branchesUpdateWithoutUserInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    branch?: branchesUpdateOneRequiredWithoutUsers_branchesNestedInput
  }

  export type users_branchesUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    branch_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type users_branchesUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    branch_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type invoicesUpdateWithoutUsersInput = {
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUpdateOneWithoutInvoiceNestedInput
    client?: clientsUpdateOneRequiredWithoutInvoicesNestedInput
    quote?: quotesUpdateOneRequiredWithoutInvoiceNestedInput
    payments?: paymentsUpdateManyWithoutInvoiceNestedInput
    reminders?: remindersUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    booking?: bookingsUncheckedUpdateOneWithoutInvoiceNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutInvoiceNestedInput
    reminders?: remindersUncheckedUpdateManyWithoutInvoicesNestedInput
  }

  export type invoicesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoice_number?: StringFieldUpdateOperationsInput | string
    quote_id?: IntFieldUpdateOperationsInput | number
    client_id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    tax_amount?: FloatFieldUpdateOperationsInput | number
    total_amount?: FloatFieldUpdateOperationsInput | number
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: Enuminvoices_statusFieldUpdateOperationsInput | $Enums.invoices_status
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
  }

  export type clientsCreateManyBranchInput = {
    id?: number
    name: string
    email: string
    phone: string
    address?: string | null
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    public_id: string
    status?: $Enums.shared_status
    enc_phone: string
  }

  export type usersCreateManyBranchInput = {
    id?: number
    name: string
    email: string
    email_verified?: Date | string | null
    password: string
    role?: $Enums.users_role
    created_at?: Date | string
    updated_at?: Date | string | null
    status?: $Enums.users_status
    deleted_at?: Date | string | null
    public_id: string
    password_expiry?: Date | string
    two_factor_enabled?: boolean
    national_id?: string | null
    phone?: string | null
    image?: string | null
  }

  export type users_branchesCreateManyBranchInput = {
    id?: number
    user_id: number
    created_at?: Date | string
    updated_at?: Date | string | null
    deleted_at?: Date | string | null
    status?: $Enums.shared_status
  }

  export type clientsUpdateWithoutBranchInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUpdateManyWithoutClientNestedInput
    invoices?: invoicesUpdateManyWithoutClientNestedInput
    quotes?: quotesUpdateManyWithoutClientNestedInput
  }

  export type clientsUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
    bookings?: bookingsUncheckedUpdateManyWithoutClientNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutClientNestedInput
    quotes?: quotesUncheckedUpdateManyWithoutClientNestedInput
  }

  export type clientsUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    enc_phone?: StringFieldUpdateOperationsInput | string
  }

  export type usersUpdateWithoutBranchInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUpdateManyWithoutUserNestedInput
    bookings?: bookingsUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUpdateManyWithoutUserNestedInput
    events?: events_logUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
    users_branches?: users_branchesUpdateManyWithoutUserNestedInput
    invoices?: invoicesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: accountsUncheckedUpdateManyWithoutUserNestedInput
    bookings?: bookingsUncheckedUpdateManyWithoutUserNestedInput
    cancellations?: cancellationsUncheckedUpdateManyWithoutUserNestedInput
    events?: events_logUncheckedUpdateManyWithoutUsersNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutUsersNestedInput
    rate_cards?: rate_cardsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
    users_branches?: users_branchesUncheckedUpdateManyWithoutUserNestedInput
    invoices?: invoicesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: Enumusers_roleFieldUpdateOperationsInput | $Enums.users_role
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumusers_statusFieldUpdateOperationsInput | $Enums.users_status
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    public_id?: StringFieldUpdateOperationsInput | string
    password_expiry?: DateTimeFieldUpdateOperationsInput | Date | string
    two_factor_enabled?: BoolFieldUpdateOperationsInput | boolean
    national_id?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type users_branchesUpdateWithoutBranchInput = {
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
    user?: usersUpdateOneRequiredWithoutUsers_branchesNestedInput
  }

  export type users_branchesUncheckedUpdateWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }

  export type users_branchesUncheckedUpdateManyWithoutBranchInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: Enumshared_statusFieldUpdateOperationsInput | $Enums.shared_status
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}